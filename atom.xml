<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悲伤逆流</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zy943453722.ink/"/>
  <updated>2019-01-13T13:20:08.548Z</updated>
  <id>http://zy943453722.ink/</id>
  
  <author>
    <name>悲伤逆流</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>彻底弄懂MySQL锁机制</title>
    <link href="http://zy943453722.ink/post/4a00a237.html"/>
    <id>http://zy943453722.ink/post/4a00a237.html</id>
    <published>2018-10-13T16:22:23.000Z</published>
    <updated>2019-01-13T13:20:08.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">伟大的人物都走过了荒沙大漠，才登上光荣的高峰。<br><b>巴尔扎克</b></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><blockquote><p>之前对MySQL的锁机制基本是敬而远之，因为设计的太过于复杂，而且现实中还没有遇到并发量很大的情况，故而锁也很少遇到。但随着并发量的增大，我决定要啃一下这块硬骨头！！<br><font color="red"></font></p></blockquote><h3 id="锁的分类"><a class="header-anchor" href="#锁的分类">¶</a>锁的分类</h3><p><strong>按概念分:</strong><br></p><ul><li><strong>悲观锁:</strong><br><br>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li><li><strong>乐观锁:</strong><br><br>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</li></ul><p><strong>按粒度分：<br></strong></p><ul><li><strong>行锁：</strong><br>给某个数据记录加锁,实际是对索引加锁</li><li><strong>表锁：</strong><br>给某个表加锁</li><li><strong>页锁：</strong><br>给某个页加锁</li></ul><blockquote><p>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p></blockquote><hr><blockquote><p>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></blockquote><hr><blockquote><p>行锁：锁开销大，粒度小，发生冲突概率低，但并发度高，可能出现死锁。</p></blockquote><hr><blockquote><p>表锁: 锁开销小，加锁快，不会出现死锁，锁粒度大，但并发度低，发生冲突概率高</p></blockquote><hr><blockquote><p>页锁：基于行锁和表锁之间<br><font color="red"></font></p></blockquote><h3 id="概念前提"><a class="header-anchor" href="#概念前提">¶</a>概念前提</h3><blockquote><p>MyISAM中读和共享一个意思，写和独占一个意思，这是因为读时就隐式加了共享，写时就隐式加了独占。<br>而InnoDB中不同，写和排他一个意思，读和共享不一个意思，即读也可以加排他锁，因为select不存在隐式加锁。</p></blockquote><hr><blockquote><p>MyISAM采取的是读写均隐式加锁。<br>InnoDB采取的是基于多版本的并发控制协议----MVCC：即读不加锁，读写不冲突。（后面会提到MVCC的概念）<br><font color="red"></font></p></blockquote><h3 id="myisam中的锁"><a class="header-anchor" href="#myisam中的锁">¶</a>MyISAM中的锁</h3><blockquote><p>MyISAM中的锁为表锁，其只有两种模式：表共享读锁+表独占写锁。<br>MyISAM不会死锁的原因：<strong>Mysql一次获取了sql语句需要的所有的锁，不存在去等待他人释放的问题。</strong></p></blockquote><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。 这样就不适合有大量更新操作和查询操作的情景，会出现&quot;饿死&quot;现象。</p><p>可以设置改变读锁和写锁的优先级：</p><ul><li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li><li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li><li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li><li>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li></ul><p><strong>对于MyISAM的加锁情况与其他用户行为关系，请看下图：</strong><br><img src="/post/1.png" alt="图1"><br><font color="red"></font></p><h4 id="隐式加锁"><a class="header-anchor" href="#隐式加锁">¶</a>隐式加锁</h4><blockquote><p>MyISAM在执行读写之前都会自动加锁,隐式加锁的作用如下：</p></blockquote><p><strong><em>注：因为隐式加锁只涉及一条sql语句所以不存在对加锁方的影响</em></strong></p><ul><li>表共享读锁：不会阻塞其他用户读，但会阻塞其他用户写（也可以说不会阻塞其他用户加共享锁，但会阻塞其他用户加排他锁）</li><li>表独占写锁：既会阻塞其他用户读，也会阻塞其他用户写（也可以说既会阻塞其他用户加共享锁，也会阻塞其他用户加排他锁）<br><font color="red"></font></li></ul><h4 id="显式加锁"><a class="header-anchor" href="#显式加锁">¶</a>显式加锁</h4><blockquote><p>利用lock table(s) xxxx read/write [local]命令加锁，相当于多条SQL语句形成个整体或者是会话，然后加锁。有点像InnoDB中的事务。显式加锁的作用：</p></blockquote><ul><li>对加锁方而言：<ul><li>表读锁：当前会话只能执行加锁的表上的select，既不能对加锁的表进行update、insert、delete,也不能执行其他未加锁表上的任何操作</li><li>表写锁：当前会话仍不能访问其他未加锁表的任何操作，但可以对加锁表执行select、update、insert、delete操作</li></ul></li><li>对其他并发用户而言：<ul><li>表读锁：能顺利select，执行update/delete会阻塞，如果开了并发插入功能，且无空隙那么能顺利insert，否则阻塞</li><li>表写锁：做任何操作都会阻塞。<br><font color="red"></font></li></ul></li></ul><h4 id="并发插入"><a class="header-anchor" href="#并发插入">¶</a>并发插入</h4><blockquote><p>特别需要提一下的是并发插入，对于MyISAM表存在这个原理。</p></blockquote><p>如果你使用LOCK TABLES显式获取表锁，则可以请求READ LOCAL锁而不是READ锁，以便在锁定表时，其他会话可以使用并发插入。</p><ul><li>当concurrent_insert设置为0时，不允许并发插入。</li><li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。</li><li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。<br><font color="red"></font></li></ul><h3 id="innodb中的锁"><a class="header-anchor" href="#innodb中的锁">¶</a>InnoDB中的锁</h3><blockquote><p>众所周知，InnoDB中的锁分为行锁和表锁，那下面就分开来谈谈行锁和表锁~~</p></blockquote><p><strong>对于InnoDB的行加锁情况与其他用户行为关系，请看下图：</strong><br><img src="/post/2.png" alt="图1"><br><font color="red"></font></p><h4 id="innodb的行锁"><a class="header-anchor" href="#innodb的行锁">¶</a>InnoDB的行锁</h4><blockquote><p>InnoDB 实现了以下两种类型的行锁：</p></blockquote><blockquote><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul></blockquote><hr><blockquote><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p></blockquote><blockquote><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。<br><font color="red"></font></li></ul></blockquote><h5 id="隐式加锁-v2"><a class="header-anchor" href="#隐式加锁-v2">¶</a>隐式加锁</h5><blockquote><ul><li>意向锁(IS/IX)是引擎自己加，不需要用户干预</li><li>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)</li><li>对于普通 SELECT 语句，InnoDB 不会加任何锁</li></ul></blockquote><p><strong>注：InnoDB在事务执行过程中，使用两阶段锁协议：<br>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；<br>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</strong><br><font color="red"></font></p><h5 id="显式加锁-v2"><a class="header-anchor" href="#显式加锁-v2">¶</a>显式加锁</h5><blockquote><p>select … lock in share mode //共享锁 <br><br>select … for update //排他锁</p></blockquote><p><strong>由上图可以看出：</strong><br><br>加了共享锁，其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。<br>而加了排他锁，其他 session仍 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁<br><font color="red"></font></p><h5 id="行锁实现及mvcc"><a class="header-anchor" href="#行锁实现及mvcc">¶</a>行锁实现及MVCC</h5><blockquote><p><strong>实现方式:</strong><br><br>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！<br><br><strong>但是，如果索引是个非主键非唯一索引，那么可能存在两行数据其中的索引列数据一致，这时候加锁就会出现锁冲突！！</strong></p></blockquote><hr><blockquote><p><strong>MVCC解释：</strong><br>多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。<br>（更多MVCC内容请参见<a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MVCC</a>）<br><font color="red"></font></p></blockquote><h4 id="innodb的表锁"><a class="header-anchor" href="#innodb的表锁">¶</a>InnoDB的表锁</h4><blockquote><p>值得一提的是，InnoDB的表锁实际是由MySQL Server管理的，而非InnoDB引擎，仅当autocommit=0、innodb_table_locks=1(默认设置)，InnoDB层才知道MySQL加的表锁，因此做表锁时，<strong>记得set autocommit = 0</strong></p></blockquote><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29150809</a><br><a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012650596</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;伟大的人物都走过了荒沙大漠，才登上光荣的高峰。
&lt;br&gt;&lt;b&gt;巴尔扎克&lt;/b&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://zy943453722.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://zy943453722.ink/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>PHP进阶基础知识剖析(五)之通信神器socket</title>
    <link href="http://zy943453722.ink/post/ba6dd70.html"/>
    <id>http://zy943453722.ink/post/ba6dd70.html</id>
    <published>2018-05-12T14:51:16.000Z</published>
    <updated>2019-01-12T08:00:10.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">人若志趣不远，心不在焉，虽学不成。<br><b>张载<b></b></b></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><blockquote><p>上一篇我们讲解了php网络通信中的传输利器cURL，同样的，作为在网络中不可或缺的一部分，socket也是必须要了解的。下面，让我们一同探寻PHP与socket的故事~~~</p></blockquote><h2 id="socket介绍"><a class="header-anchor" href="#socket介绍">¶</a>Socket介绍</h2><blockquote><p>Socket通常称之为套接字，用于描述ip和端口，是一个通信链的句柄。应用程序中可以通过其向网络发送请求或应答网络请求。socket不是一个程序，也不是一种协议，而是操作系统提供的传输层与应用层之间的一组抽象API。</p></blockquote><h2 id="php与socket"><a class="header-anchor" href="#php与socket">¶</a>PHP与Socket</h2><blockquote><p>而在PHP中，由于PHP自身是由c语言开发而成，因此，无法涉及到底层API和系统调用。仅仅是将API进行封装之后的调用。<br><br>另外，由于历史的缘故，PHP中的socket不像c/java中那般智能，其作为服务器的效率较低，因此一般不用其作为服务器编程的利器，同时PHP的socket中对I/O复用的封装仅仅实现了select，而现阶段大多数服务器采用的epoll模型并未涉及。如果想要用PHP实现网络的高效通信，可以添加swoole扩展，具体介绍请移步：<a href="https://www.swoole.com/" target="_blank" rel="noopener">swoole</a></p></blockquote><h3 id="php中socket原型"><a class="header-anchor" href="#php中socket原型">¶</a>PHP中Socket原型</h3><p><strong>原型定义如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOCKET socket(int af, int type, int protocol);</span><br><span class="line">该函数共有三个参数：</span><br><span class="line">af: 指定应用程序的通信协议族，对于TCP/IP协议族该置为AF_INET</span><br><span class="line">type: 是指创建socket的类型：</span><br><span class="line">    包括基于TCP协议的流套接字类型：SOCK_STREAM</span><br><span class="line">    基于UDP协议的数据报套接字类型：SOCK_DGRAM</span><br><span class="line">    原始套接字类型：SOCK_RAW</span><br><span class="line">protocol:指定使用的通信协议</span><br></pre></td></tr></table></figure><h3 id="几种使用socket的方法"><a class="header-anchor" href="#几种使用socket的方法">¶</a>几种使用socket的方法</h3><blockquote><ol><li>使用原始方式创建一个套接字：<br>socket_create(int $domain,int $type,int $protocol)</li></ol></blockquote><blockquote><ol start="2"><li>使用fsockopen方式:<br>fsockopen($host, $port, &amp;errno, &amp;errstr, $timeout)</li></ol></blockquote><blockquote><ol start="3"><li>使用pfsockopen方式：<br>跟fsockopen定义一致，只不过fsockopen是长连接</li></ol></blockquote><blockquote><ol start="4"><li>使用stream_socket_server/stream_socket_client方式：<br>以流方式执行socket</li></ol></blockquote><h3 id="其他方法"><a class="header-anchor" href="#其他方法">¶</a>其他方法</h3><blockquote><p>其实其他方法和原始c语言中的socket API大同小异，只不过是做了一层封装而已。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">socket_bind ( resource $socket , string $address [, int $port = 0 ] ) : bool//绑定函数</span><br><span class="line"></span><br><span class="line">socket_listen ( resource $socket [, int $backlog = 0 ] ) : bool//监听函数</span><br><span class="line"></span><br><span class="line">socket_read ( resource $socket , int $length [, int $type = PHP_BINARY_READ ] ) : string//读数据函数</span><br><span class="line"></span><br><span class="line">socket_recv ( resource $socket , string &amp;$buf , int $len , int $flags ) : int//接收数据函数</span><br><span class="line"></span><br><span class="line">socket_select ( array &amp;$read , array &amp;$write , array &amp;$except , int $tv_sec [, int $tv_usec = 0 ] ) : int//I/O复用的select函数</span><br><span class="line"></span><br><span class="line">socket_send ( resource $socket , string $buf , int $len , int $flags ) : int//发送函数</span><br><span class="line"></span><br><span class="line">socket_set_block ( resource $socket ) : bool//设置阻塞模式</span><br><span class="line"></span><br><span class="line">socket_write ( resource $socket , string $buffer [, int $length = 0 ] ) : int//写数据函数</span><br><span class="line"></span><br><span class="line">socket_accept ( resource $socket ) : resource//服务端接受请求函数</span><br><span class="line"></span><br><span class="line">socket_connect ( resource $socket , string $address [, int $port = 0 ] ) : bool//客户端连接服务器函数</span><br><span class="line"></span><br><span class="line">socket_close ( resource $socket ) : void//关闭套接口资源函数</span><br></pre></td></tr></table></figure><h5 id="代码示例"><a class="header-anchor" href="#代码示例">¶</a><strong>代码示例</strong></h5><p>请移步我的<a href="https://github.com/zy943453722/php-basic-code/tree/master/php-socket" target="_blank" rel="noopener">github</a>查看示例代码实现c/s聊天室和smtp客户端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;人若志趣不远，心不在焉，虽学不成。
&lt;br&gt;&lt;b&gt;张载&lt;b&gt;
&lt;/b&gt;&lt;/b&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php" scheme="http://zy943453722.ink/tags/php/"/>
    
      <category term="编程基础" scheme="http://zy943453722.ink/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP进阶基础知识剖析(四)之传输利器curl</title>
    <link href="http://zy943453722.ink/post/d44b0051.html"/>
    <id>http://zy943453722.ink/post/d44b0051.html</id>
    <published>2018-05-10T20:28:45.000Z</published>
    <updated>2019-01-11T02:39:20.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">让自己的内心藏着一条巨龙，既是一种苦刑，也是一种乐趣<br><b>雨果<b></b></b></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><blockquote><p>本期来讲述一下web服务中很重要的传输利器cURL，同时讲述它与PHP不得不说的秘密~~~</p></blockquote><h3 id="curl简介"><a class="header-anchor" href="#curl简介">¶</a>cURL简介</h3><blockquote><p>cURL是使用URL语法传输数据的命令行工具，及客户端向服务器请求的工具，可支持多种协议。可用于编写 网页爬虫、获取web services服务、下载/上传文件等</p></blockquote><h3 id="curl用法"><a class="header-anchor" href="#curl用法">¶</a>cURL用法</h3><p><strong>cURL的用法很多，在此仅仅简单的列出几种比较常用的！</strong></p><blockquote><ul><li>cURL <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  //不带任何参数，用以获取此网页源码</li><li>cURL -o [fileName] <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> //将网页保存起来，相当于下载</li><li>cURL -i <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> //不仅获取网页源码还获取响应头信息</li><li>cURL -L <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> //使自动跳转的网页跳转到新网址</li><li>cURL -v <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> //显示通信整个过程包括请求头、响应头和资源</li><li>cURL -X GET/POST/DELETE/PUT <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> //通过加-X参数指定获取资源的方法</li></ul></blockquote><hr><blockquote><p><strong>cURL实例：</strong><br></p><ol><li>POST提交表单数据：<br>curl -X POST --data “data=xxx” <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></li><li>请求时添加http头：<br>curl --xxx <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a>(此xxx即为请求头)</li><li>登陆认证时：<br>curl --user name:password <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></li></ol></blockquote><h3 id="php与curl"><a class="header-anchor" href="#php与curl">¶</a>PHP与cURL</h3><p><strong>讲完了cURL的基础之后，重点讲解一下PHP中的用法。其实作为PHP的扩展之一，cURL的支持还是比较完善的。</strong></p><p><img src="/post/1.png" alt="图1"></p><blockquote><p><strong>相关的方法如下：</strong><br><br><br><strong><em>curl作为http客户端发送http请求：<br></em></strong><br>curl_init初始化curl会话<br><br>curl_escape对url进行编码<br><br>curl_unescape对url进行解码<br><br>curl_setopt和curl_setopt_array分别是对curl句柄进行会话设置<br><br>curl_exec执行curl会话<br><br>curl_close关闭curl会话<br><br>curl_getinfo获取一个cURL连接资源句柄的信息<br><br><strong><em>接口并发处理：<br></em></strong><br>curl_multi_init 返回一个新的curl批处理句柄<br><br>curl_multi_setopt 为curl并行处理设置一个选项<br><br>curl_multi_add_handle 往curl批处理中增加一个句柄<br><br>curl_multi_remove_handle 移除一个<br><br>curl_multi_exec 运行当前批处理中每一个句柄<br><br>curl_multi_select 阻塞直到cURL批处理连接中有活动连接(轮询等待)<br><br>curl_multi_close 关闭批处理<br></p></blockquote><p><strong>重点是setopt方法中的option参数，常见的如下所示：<br></strong></p><blockquote><ul><li><strong>post方法获取资源相关：</strong><br><br>CURLOPT_POST: 设置使用post方法<br><br>CURLOPT_POSTFIELDS： 设置post方法上传的资源<br><br>CURLOPT_HTTPHEADER： 设置提交的http头<br></li><li><strong>cookie相关：</strong><br><br>CURLOPT_COOKIESESSION：将开启新的一次 cookie 会话<br><br>CURLOPT_COOKIEFILE：包含cookie数据的文件<br><br>CURLOPT_COOKIEJAR：连接结束后，比如，调用 curl_close 后，保存 cookie 信息的文件<br><br>CURLOPT_COOKIE：设置具体cookie<br></li><li><strong>文件传输相关：</strong><br><br>CURLOPT_URL：设置请求URL<br><br>CURLOPT_RETURNTRANSFER：设置执行后不直接输出而是以文件流形式返回<br><br>CURLOPT_HEADER：是否打印头部信息<br><br>CURLOPT_FOLLOWLOCATION：是否支持页面跳转<br></li></ul></blockquote><h4 id="代码示例"><a class="header-anchor" href="#代码示例">¶</a>代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$data = &apos;username=xxxxx&amp;password=xxx&amp;remember=1&apos;;</span><br><span class="line">$curl = curl_init();//初始化curl对象</span><br><span class="line">//设置url</span><br><span class="line">curl_setopt($curl, CURLOPT_URL, &quot;http://www.imooc.com/usr/login&quot;);</span><br><span class="line">curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);//设置执行后不直接打印</span><br><span class="line"></span><br><span class="line">date_default_timezone_set(&apos;PRC&apos;);//设置时区</span><br><span class="line">curl_setopt($curl, CURLOPT_COOKIESESSION, 1);//设置cookie和session</span><br><span class="line">curl_setopt($curl, CURLOPT_COOKIEFILE, &quot;cookfile&quot;);//cookie保存的文件</span><br><span class="line">curl_setopt($curl, CURLOPT_COOKIEJAR, &quot;cookfile&quot;);//cookie读取</span><br><span class="line">//cookie是什么</span><br><span class="line">curl_setopt($curl, CURLOPT_COOKIE, session_name().&apos;=&apos;.session_id());</span><br><span class="line">curl_setopt($curl, CURLOPT_HEADER, 0);//不打印头部信息</span><br><span class="line">curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);//支持页面跳转</span><br><span class="line">curl_setopt($curl, CURLOPT_POST, 1);//使用post方法</span><br><span class="line">curl_setopt($curl, CURLOPT_POSTFIELDS, $data);</span><br><span class="line">curl_setopt($curl, CURLOPT_HTTPHEADER, array(&quot;application/x-www-form-urlencoded;</span><br><span class="line">               charset=utf-8&quot;,</span><br><span class="line">               &quot;Content_length:&quot;.strlen($data)</span><br><span class="line">));</span><br><span class="line">curl_exec($curl);</span><br><span class="line">curl_close($curl);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;让自己的内心藏着一条巨龙，既是一种苦刑，也是一种乐趣
&lt;br&gt;&lt;b&gt;雨果&lt;b&gt;
&lt;/b&gt;&lt;/b&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; hre
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php" scheme="http://zy943453722.ink/tags/php/"/>
    
      <category term="编程基础" scheme="http://zy943453722.ink/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP进阶基础知识剖析(三)之自动加载</title>
    <link href="http://zy943453722.ink/post/ec09671a.html"/>
    <id>http://zy943453722.ink/post/ec09671a.html</id>
    <published>2018-05-09T17:01:05.000Z</published>
    <updated>2019-01-11T01:35:24.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">雄心壮志是茫茫黑夜中的北斗星<br><b>罗·勃朗宁<b></b></b></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><blockquote><p>这次我们来介绍又一种很有趣的技术，叫做自动加载，也是实现动态引入文件的技术。好吧，话不多说，让我们进入它的世界！</p></blockquote><p><strong><em>那么本期要讲述的是关于自动加载的知识</em></strong></p><h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><blockquote><p><strong>来源：</strong><br>在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。</p></blockquote><hr><blockquote><p>自动加载，顾名思义，不是静态的靠include/require引入，而是自动的将需要的类引入进来，这就需要依赖一个神奇的函数：<br><br><strong>spl_autoload_register</strong></p></blockquote><h5 id="spl-autoload-register"><a class="header-anchor" href="#spl-autoload-register">¶</a><strong>spl_autoload_register</strong></h5><blockquote><p>该函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。<br>请看下方函数定义！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )</span><br><span class="line"></span><br><span class="line">autoload_function</span><br><span class="line">欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。</span><br><span class="line"></span><br><span class="line">throw</span><br><span class="line">此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。</span><br><span class="line"></span><br><span class="line">prepend</span><br><span class="line">如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。</span><br><span class="line"></span><br><span class="line">void __autoload ( string $class )//这个函数来启动自动加载，但用这个注册的话只能注册一个函数就是它本身，而spl_register_autoload则可以注册任意个自定义的autoload</span><br></pre></td></tr></table></figure><p><strong>实际上此函数是注册用户自定义的函数作为__autoload去使用，而此函数相当于建立了一个__autoload类型的队列，而__autoload函数底层就是加载未定义的类</strong></p><h5 id="代码示例"><a class="header-anchor" href="#代码示例">¶</a><strong>代码示例</strong></h5><blockquote><p>下面的示例代码就是很典型的框架中为了引入外部的类而作的自动加载</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static function autoload($className)</span><br><span class="line">&#123;</span><br><span class="line">    $className = str_replace(&apos;\\&apos;,&apos;/&apos;,ltrim($className,&apos;\\&apos;));</span><br><span class="line">    $lastPos = strrpos($className,&apos;/&apos;);</span><br><span class="line">    $classDir = substr($className,0,$lastPos);//从0开始，长度为$lastPos</span><br><span class="line">    $classPublic = $classDir.&apos;/public/&apos;.substr($className,$lastPos+1);</span><br><span class="line">    $classPrivate = $classDir.&apos;/private/&apos;.substr($className,$lastPos+1);</span><br><span class="line">    if (isset(self::$classMap[$className])) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (is_file(PROJECT_PATH.&quot;/&quot;.$className.&quot;.php&quot;)) &#123;</span><br><span class="line">            require_once PROJECT_PATH.&quot;/&quot;.$className.&quot;.php&quot;;</span><br><span class="line">            self::$classMap[$className] = $className;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (is_file(PROJECT_PATH.&quot;/&quot;.$classPrivate.&quot;.php&quot;)) &#123;</span><br><span class="line">            require_once PROJECT_PATH.&quot;/&quot;.$classPrivate.&quot;.php&quot;;</span><br><span class="line">            self::$classMap[$className] = $className;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (is_file(PROJECT_PATH.&quot;/&quot;.$classPublic.&quot;.php&quot;)) &#123;</span><br><span class="line">            require_once PROJECT_PATH.&quot;/&quot;.$classPublic.&quot;.php&quot;;</span><br><span class="line">            self::$classMap[$className] = $className;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $str = &quot;没找到对应的文件\n&quot;;</span><br><span class="line">            self::exceptionHandle($str);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">spl_autoload_register(&apos;self::autoload&apos;);</span><br></pre></td></tr></table></figure><h4 id="其他"><a class="header-anchor" href="#其他">¶</a><strong>其他</strong></h4><p><strong>SPL Autoload 具体有几个函数：</strong></p><blockquote><ol><li>spl_autoload_register：注册 _autoload() 函数</li><li>spl_autoload_unregister：注销已注册的函数</li><li>spl_autoload_functions：返回所有已注册的函数</li><li>spl_autoload_call：尝试所有已注册的函数来加载类</li><li>spl_autoload ：_autoload() 的默认实现</li><li>spl_autoload_extionsions： 注册并返回 spl_autoload 函数使用的默认文件扩展名。</li></ol></blockquote><p>详细的信息请查看<a href="http://php.net/manual/zh/function.spl-autoload-register.php" target="_blank" rel="noopener">php.net</a>!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;雄心壮志是茫茫黑夜中的北斗星
&lt;br&gt;&lt;b&gt;罗·勃朗宁&lt;b&gt;
&lt;/b&gt;&lt;/b&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php" scheme="http://zy943453722.ink/tags/php/"/>
    
      <category term="编程基础" scheme="http://zy943453722.ink/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP进阶基础知识剖析(二)之反射API</title>
    <link href="http://zy943453722.ink/post/561dc37c.html"/>
    <id>http://zy943453722.ink/post/561dc37c.html</id>
    <published>2018-05-08T14:50:01.000Z</published>
    <updated>2019-01-09T09:01:25.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">烈火试真金，逆境试强者。<br><b>塞内加<b></b></b></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><blockquote><p>既写了魔术方法之后，接下来再来剖析另外一个很有趣的东西--------反射API，这个语法在很多OOPL中都存在，PHP中自然也少不了。接下来我们就进入他的世界！！</p></blockquote><p><strong><em>那么本期要讲述的是关于反射API的知识</em></strong></p><h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><blockquote><p>反射，顾名思义，直观理解就是根据到达地找到出发地和来源。通俗点说，就是给你一个光秃秃的对象，我们可以通过它知道他所属的类、以及属性、方法、参数甚至注释等一切。。。。。</p></blockquote><hr><blockquote><p><strong>这是一种动态获取信息以及动态调用对象方法的功能</strong></p></blockquote><h3 id="主要作用"><a class="header-anchor" href="#主要作用">¶</a>主要作用</h3><blockquote><ul><li>用于自动生成类的定义文档</li><li>当需要去实例化一个类，但是这个类完全就是封闭或者说是未知的，你可以创建反射来与映射这个类，通过一系列的探测来最终实例化这个类，尤其还在动态运行中的。</li><li>可以做动态代理和做hook实现插件功能</li><li>可用于调试和单元测试</li></ul></blockquote><h3 id="详解具体api"><a class="header-anchor" href="#详解具体api">¶</a>详解具体API</h3><blockquote><p>首先，反射API的实现是从一个接口实现开始，这个接口叫做<strong>Reflector</strong>，接口定义如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Reflector &#123;</span><br><span class="line">/* 方法 */</span><br><span class="line">public static string export ( void )</span><br><span class="line">public string __toString ( void )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他的基础反射类都是基于此接口实现。请看下图列出了几种常见的反射类：</p></blockquote><p><img src="/post/1.png" alt="图1"></p><blockquote><p><strong>我们以ReflectionClass类来说明，对于这个类其中提供了很多的方法，下面展示的是官方给出的其中的方法。</strong></p></blockquote><hr><blockquote><p>ReflectionClass::__construct — 初始化 ReflectionClass 类</p></blockquote><hr><blockquote><p>ReflectionClass::export — 导出一个类</p></blockquote><hr><blockquote><p>ReflectionClass::getConstant — 获取定义过的一个常量<br>ReflectionClass::getConstants — 获取一组常量<br>ReflectionClass::getConstructor — 获取类的构造函数<br>ReflectionClass::getDefaultProperties — 获取默认属性<br>ReflectionClass::getDocComment — 获取文档注释<br>ReflectionClass::getEndLine — 获取最后一行的行数<br>ReflectionClass::getExtension — 根据已定义的类获取所在扩展的 ReflectionExtension 对象<br>ReflectionClass::getExtensionName — 获取定义的类所在的扩展的名称<br>ReflectionClass::getFileName — 获取定义类的文件名<br>ReflectionClass::getInterfaceNames — 获取接口（interface）名称<br>ReflectionClass::getInterfaces — 获取接口<br>ReflectionClass::getMethod — 获取一个类方法的 ReflectionMethod。<br>ReflectionClass::getMethods — 获取方法的数组<br>ReflectionClass::getModifiers — 获取类的修饰符<br>ReflectionClass::getName — 获取类名<br>ReflectionClass::getNamespaceName — 获取命名空间的名称<br>ReflectionClass::getParentClass — 获取父类<br>ReflectionClass::getProperties — 获取一组属性<br>ReflectionClass::getProperty — 获取类的一个属性的 ReflectionProperty<br>ReflectionClass::getReflectionConstant — Gets a ReflectionClassConstant for a class’s constant<br>ReflectionClass::getReflectionConstants — Gets class constants<br>ReflectionClass::getShortName — 获取短名<br>ReflectionClass::getStartLine — 获取起始行号<br>ReflectionClass::getStaticProperties — 获取静态（static）属性<br>ReflectionClass::getStaticPropertyValue — 获取静态（static）属性的值<br>ReflectionClass::getTraitAliases — 返回 trait 别名的一个数组<br>ReflectionClass::getTraitNames — 返回这个类所使用 traits 的名称的数组<br>ReflectionClass::getTraits — 返回这个类所使用的 traits 数组</p></blockquote><hr><blockquote><p>ReflectionClass::hasConstant — 检查常量是否已经定义<br>ReflectionClass::hasMethod — 检查方法是否已定义<br>ReflectionClass::hasProperty — 检查属性是否已定义<br>ReflectionClass::implementsInterface — 接口的实现<br>ReflectionClass::inNamespace — 检查是否位于命名空间中<br>ReflectionClass::isAbstract — 检查类是否是抽象类（abstract）<br>ReflectionClass::isAnonymous — 检查类是否是匿名类<br>ReflectionClass::isCloneable — 返回了一个类是否可复制<br>ReflectionClass::isFinal — 检查类是否声明为 final<br>ReflectionClass::isInstance — 检查类的实例<br>ReflectionClass::isInstantiable — 检查类是否可实例化<br>ReflectionClass::isInterface — 检查类是否是一个接口（interface）<br>ReflectionClass::isInternal — 检查类是否由扩展或核心在内部定义<br>ReflectionClass::isIterateable — 检查是否可迭代（iterateable）<br>ReflectionClass::isSubclassOf — 检查是否为一个子类<br>ReflectionClass::isTrait — 返回了是否为一个 trait<br>ReflectionClass::isUserDefined — 检查是否由用户定义的</p></blockquote><hr><blockquote><p>ReflectionClass::newInstance — 从指定的参数创建一个新的类实例<br>ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。<br>ReflectionClass::newInstanceWithoutConstructor — 创建一个新的类实例而不调用它的构造函数<br>ReflectionClass::setStaticPropertyValue — 设置静态属性的值<br>ReflectionClass::__toString — 返回 ReflectionClass 对象字符串的表示形式。</p></blockquote><p><strong><em>那么方法众多，我们也无法一一讲解，大体分为几类：构造函数、打印类信息(export)、获取类信息(getxxx方法)、检查类、创建新类等</em></strong></p><blockquote><p>对于获取类信息的方法，PHP本身内置了许多诸如get_class_methods、get_class、get_called_class等方法用来快速获取类及方法、属性等信息，但完全没有反射API强大</p></blockquote><h3 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h3><blockquote><p>接下来，我来展示一个反射API使用示例，很多框架中也是如此实现Ioc容器的，可以说反射还是很好用的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Container</span><br><span class="line">&#123;</span><br><span class="line">    protected static $classMap = array();</span><br><span class="line">    protected static $container;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return Container</span><br><span class="line">     * 单例模式获取全局唯一的容器对象</span><br><span class="line">     */</span><br><span class="line">    public static function getSingleton()</span><br><span class="line">    &#123;</span><br><span class="line">        if (self::$container === null) &#123;</span><br><span class="line">            self::$container = new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param $componentName</span><br><span class="line">     * @param array $params</span><br><span class="line">     * @return mixed</span><br><span class="line">     * @throws \ReflectionException</span><br><span class="line">     * 经典的Ioc容器获取对应类</span><br><span class="line">     */</span><br><span class="line">    public static function getClass($componentName,$params = [])</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$classMap[$componentName])) &#123;</span><br><span class="line">            $ref = new \ReflectionClass($componentName);</span><br><span class="line">            self::$classMap[$componentName] = $ref-&gt;newInstanceArgs($params);//给构造函数以数组形式传参</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$classMap[$componentName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析:</strong><br><br>很多经典的框架结构动态实现都是运用了反射API，他们在不用知道具体类如何实现的前提下，根据需要的服务类名，通过反射机制，生成对应的服务对象加入服务容器中，供框架使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;烈火试真金，逆境试强者。
&lt;br&gt;&lt;b&gt;塞内加&lt;b&gt;
&lt;/b&gt;&lt;/b&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php" scheme="http://zy943453722.ink/tags/php/"/>
    
      <category term="编程基础" scheme="http://zy943453722.ink/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP进阶基础知识剖析(一)之魔术方法</title>
    <link href="http://zy943453722.ink/post/edd048d1.html"/>
    <id>http://zy943453722.ink/post/edd048d1.html</id>
    <published>2018-05-07T15:17:15.000Z</published>
    <updated>2019-01-07T14:53:21.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">成功的唯一秘诀——坚持到最后一分钟。<br><b>柏拉图</b></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><blockquote><p><strong>笔者近期开始一个专栏----PHP进阶基础知识剖析，专门对于那些比较生僻但很重要的语法内容，核心用法，进阶函数等等进行整理和总结，欢迎大家阅读！</strong></p></blockquote><p><strong><em>那么本期要讲述的是关于魔术方法的知识</em></strong></p><h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><blockquote><p>魔术方法是PHP中一类很特殊的系统内置方法，将所有以 __（两个下划线）开头的类方法保留为魔术方法。可以看作PHP的“语法糖”。</p></blockquote><h3 id="分类"><a class="header-anchor" href="#分类">¶</a>分类</h3><p><strong>魔术方法种类繁多，今天也不过多赘述，就简单讲解几种重要的</strong></p><blockquote><ul><li>__set和__get方法</li><li>__construct、__destruct、__clone方法</li><li>__call和__callStatic方法</li><li>__sleep和__wakeup方法</li><li>__toString和__debugInfo方法</li><li>__invoke方法</li><li>__isset和__unset方法</li></ul></blockquote><h5 id="set和-get方法"><a class="header-anchor" href="#set和-get方法">¶</a><strong>__set和__get方法</strong></h5><blockquote><p>作用:用于给对象属性赋值或者取值时，即使这个属性不存在或者这个属性有访问限制，也会能够正确执行。(请看如下示例)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Account</span><br><span class="line">&#123;</span><br><span class="line">    private $user;</span><br><span class="line">    public function __set($name, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        //注：此处name是外来变量不属于成员变量，因此$this-&gt;$name,否则$this-&gt;name   </span><br><span class="line">        $this-&gt;$name = $value;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset($this-&gt;$name)) &#123;</span><br><span class="line">            $this-&gt;$name = &quot;默认值&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return $this-&gt;$name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong><br><br>正如代码所示，有了这两个函数之后，不用向其他语言一样需要创建set方法和get方法获取访问限制的变量，其实本身这两个函数都是public的，只不过这样操作更加简单，属于PHP属性重载的一类。</p><h4 id="construct-destruct-clone方法"><a class="header-anchor" href="#construct-destruct-clone方法">¶</a><strong>__construct、__destruct、__clone方法</strong></h4><blockquote><p>作用：分别是PHP的构造函数、析构函数和对象复制函数</p></blockquote><hr><blockquote><p>注意点：<br><br>析构函数的执行时间：<br><br>1、对象的所有引用都被删除时<br>2、对象被显式销毁时(可以使用unset，或者赋值NULL，或者改变对象的值)<br>3、页面加载完成时(此时内存已经被GC机制自动释放，所有实例化的类自然也被销毁，最后实例化的类先销毁，最先实例化的类最后被销毁)</p></blockquote><hr><blockquote><p>析构函数作用场景：<br><br>一个需要循环执行的脚本，这其中可能会涉及到频繁的创建某个对象，它可以将对象打开的一些资源及时的释放，以防止内存溢出或单个进程占用过多内存。</p></blockquote><hr><blockquote><p>__clone函数：<br><br>其是对对象实例进行的浅复制,当调用clone方法是会自动调用此__clone方法，<strong>对象内的基本数值类型进行的是传值复制，而对象内的对象型成员变量</strong>,如果不重写__clone方法,<strong>显式的clone这个对象成员变量的话,这个成员变量就是传引用复制,而不是生成一个新的对象。<strong>所有的引用属性仍然会是一个指向原来的变量的引用。<br><br>当</strong>复制完成</strong>时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。<br><br>其实，clone方法克隆出来的对象是一个新的对象，除了其中引用属性的成员变量外，其他的与原对象都无关，因此一般解决断开引用属性的成员变量和原对象关系的方法就是在__clone函数中再调用clone方法（如示例）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class SubObject</span><br><span class="line">&#123;</span><br><span class="line">    static $instances = 0;</span><br><span class="line">    public $instance;</span><br><span class="line"></span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $this-&gt;instance = ++self::$instances;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __clone() &#123;</span><br><span class="line">        $this-&gt;instance = ++self::$instances;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCloneable</span><br><span class="line">&#123;</span><br><span class="line">    public $object1;</span><br><span class="line">    public $object2;</span><br><span class="line"></span><br><span class="line">    function __clone()</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        // 强制复制一份this-&gt;object， 否则仍然指向同一个对象</span><br><span class="line">        $this-&gt;object1 = clone $this-&gt;object1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = new MyCloneable();</span><br><span class="line"></span><br><span class="line">$obj-&gt;object1 = new SubObject();</span><br><span class="line">$obj-&gt;object2 = new SubObject();</span><br><span class="line"></span><br><span class="line">$obj2 = clone $obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;Original Object:\n&quot;);</span><br><span class="line">print_r($obj);</span><br><span class="line"></span><br><span class="line">print(&quot;Cloned Object:\n&quot;);</span><br><span class="line">print_r($obj2);</span><br></pre></td></tr></table></figure><h4 id="call和-callstatic方法"><a class="header-anchor" href="#call和-callstatic方法">¶</a><strong>__call和__callStatic方法</strong></h4><blockquote><p>作用：当访问<strong>对象</strong>一个不可访问的方法或未定义的方法时，__call会被调用。<br>在<strong>静态上下文</strong>中调用一个不可访问方法时，__callStatic() 会被调用。属于方法重载<br><br>其实，设置这两个方法的本意是让动态创建变成可能（<strong>即根据参数的不同后期创建不同的方法</strong>），另外__callStatic还可以实现延迟绑定。（请看下方示例）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class MethodTest </span><br><span class="line">&#123;</span><br><span class="line">    public function __call($name, $arguments) </span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;Calling object method &apos;$name&apos; &quot;</span><br><span class="line">             . implode(&apos;, &apos;, $arguments). &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static function __callStatic($name, $arguments) </span><br><span class="line">    &#123;</span><br><span class="line">        //根据参数实现不同的方法后期动态创建</span><br><span class="line">        $method = preg_replace(&apos;/^run(\w*)$/&apos;,&apos;$&#123;1&#125;&apos;,$name);</span><br><span class="line">        return self::$method();</span><br><span class="line">    &#125;</span><br><span class="line">    private static function Test()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;test\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    private static function date()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;date\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = new MethodTest;</span><br><span class="line">$obj-&gt;runTest(&apos;in object context&apos;);</span><br><span class="line">MethodTest::runTest(&apos;in static context&apos;);</span><br></pre></td></tr></table></figure><h4 id="sleep和-wakeup方法"><a class="header-anchor" href="#sleep和-wakeup方法">¶</a><strong>__sleep和__wakeup方法</strong></h4><blockquote><p><strong>作用：</strong><br>用于序列化的时候调用，即serialize方法时会自动检测类中是否包含__sleep方法，<strong>__sleep方法会先被调用，然后才执行序列化操作，<strong>同理，__wakeup方法如果存在类中，会</strong>先于unserialize执行</strong></p></blockquote><hr><blockquote><p><strong>注意：</strong> <br><br>__sleep() 方法常用于提交未提交的数据，或类似的清理操作。但必须<strong>返回</strong>所有应被序列化的变量名称的<strong>数组</strong>。<br><br>__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。(请看下方示例！)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Connection </span><br><span class="line">&#123;</span><br><span class="line">    protected $link;</span><br><span class="line">    private $server, $username, $password, $db;</span><br><span class="line">    </span><br><span class="line">    public function __construct($server, $username, $password, $db)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;server = $server;</span><br><span class="line">        $this-&gt;username = $username;</span><br><span class="line">        $this-&gt;password = $password;</span><br><span class="line">        $this-&gt;db = $db;</span><br><span class="line">        $this-&gt;connect();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private function connect()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password);</span><br><span class="line">        mysql_select_db($this-&gt;db, $this-&gt;link);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function __sleep()</span><br><span class="line">    &#123;</span><br><span class="line">    //返回数组</span><br><span class="line">        return array(&apos;server&apos;, &apos;username&apos;, &apos;password&apos;, &apos;db&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    //重新创建连接</span><br><span class="line">    public function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$conn = new Connection();</span><br><span class="line">$arr = serialize($conn);</span><br><span class="line">$e = unseralize($arr);</span><br></pre></td></tr></table></figure><h4 id="tostring和-debuginfo方法"><a class="header-anchor" href="#tostring和-debuginfo方法">¶</a><strong>__toString和__debugInfo方法</strong></h4><blockquote><p><strong>作用：</strong><br><br>格式化echo输出某个对象时（因为本身对象无法用echo输出），而__debugInfo是在格式化var_dump和print_r输出。</p></blockquote><hr><blockquote><p>用了这两个方法，可以更好的格式化输出（请看下方代码示例）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    public $foo;</span><br><span class="line">    public $a;</span><br><span class="line">    public function __construct($foo) </span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;foo = $foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __toString() &#123;</span><br><span class="line">        return &quot;这个对象的属性是$this-&gt;foo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __debugInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        return [</span><br><span class="line">            &apos;foo&apos; =&gt; $this-&gt;foo,</span><br><span class="line">            &apos;a&apos;=&gt; $this-&gt;a</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class = new TestClass(&apos;Hello&apos;);</span><br><span class="line">echo $class;</span><br><span class="line">print_r($class);</span><br></pre></td></tr></table></figure><h4 id="invoke方法"><a class="header-anchor" href="#invoke方法">¶</a><strong>__invoke方法</strong></h4><blockquote><p><strong>作用：</strong><br><br>当尝试用函数的方式调用一个对象是触发此方法。（请看下方代码示例！）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CallableClass </span><br><span class="line">&#123;</span><br><span class="line">    function __invoke($x) &#123;</span><br><span class="line">        var_dump($x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$obj = new CallableClass;</span><br><span class="line">$obj(5); // int(5)</span><br><span class="line">var_dump(is_callable($obj)) // 检测变量内容是否可当作函数调用bool(true)</span><br></pre></td></tr></table></figure><h4 id="isset和-unset方法"><a class="header-anchor" href="#isset和-unset方法">¶</a><strong>__isset和__unset方法</strong></h4><blockquote><p><strong>作用：</strong><br>也属于属性重载的一类，与__set、__get类似</p></blockquote><hr><blockquote><p><strong>用法：</strong><br>当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用,是属于检查属性的用法<br><br>当对不可访问属性调用 unset() 时，__unset() 会被调用，是属于删除属性的用法。（请看下方代码示例！）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;  </span><br><span class="line">    private $name;  </span><br><span class="line">    private $sex;  </span><br><span class="line">    private $age;  </span><br><span class="line">    public function __get($property_name) &#123;  </span><br><span class="line">        if(isset($this-&gt;$property_name))  </span><br><span class="line">        &#123;  </span><br><span class="line">            return ($this-&gt;$property_name);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            return (NULL);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function __set($property_name, $value) &#123;  </span><br><span class="line">        $this-&gt;$property_name = $value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public  function __isset($param) &#123;  </span><br><span class="line">        echo &quot;isset()函数测定私有成员时，自动调用&lt;br&gt;&quot;;  </span><br><span class="line">        return isset($this-&gt;$param);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public  function __unset($param) &#123;  </span><br><span class="line">        echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;;  </span><br><span class="line">        unset($this-&gt;$param);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">$p = new Person();  </span><br><span class="line">$p-&gt;name = &quot;LinDD&quot;;  </span><br><span class="line">echo var_dump(isset($p-&gt;name)).&quot;&lt;br&gt;&quot;;  </span><br><span class="line">echo $p-&gt;name.&quot;&lt;br&gt;&quot;;  </span><br><span class="line">unset($p-&gt;name);  </span><br><span class="line">echo $p-&gt;name;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;成功的唯一秘诀——坚持到最后一分钟。
&lt;br&gt;&lt;b&gt;柏拉图&lt;/b&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php" scheme="http://zy943453722.ink/tags/php/"/>
    
      <category term="编程基础" scheme="http://zy943453722.ink/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>http历史及请求报文和响应报文</title>
    <link href="http://zy943453722.ink/post/cc12a58f.html"/>
    <id>http://zy943453722.ink/post/cc12a58f.html</id>
    <published>2018-02-06T16:35:31.000Z</published>
    <updated>2019-01-02T01:58:41.850Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">书籍是人类进步的阶梯<br><b>高尔基</b></blockquote><img src="/4.jpg" class="full-image"><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p><strong><em>笔者最近看了&lt;&lt;图解HTTP&gt;&gt;这本书，了解了web开发人员需要了解的http协议的基础知识，并且在此整理一下重点的知识。</em></strong></p><h2 id="http的历史"><a class="header-anchor" href="#http的历史">¶</a>http的历史</h2><p>http在1990年面世，但最开始并没有作为正式的标准建立。这时候的http，更多的被称为HTTP/0.9版本。<br><br>之后在1996年的5月，http被正式作为标准公布，称为HTTP/1.0。<br><br>之后在1997年的1月，公布了HTTP/1.1是目前主流的HTTP协议版本。<br><br>目前HTTP/2.0正在制定中，但是仍然没有成为主流的版本。</p><p>##http请求和响应</p><h3 id="http请求"><a class="header-anchor" href="#http请求">¶</a>http请求</h3><p>请求报文 = 请求方法 + 请求URI + 请求协议版本<br>+ 可选择的首部字段 + 内容实体<br>= 报文首部 + 空行(CR+LF) + 报文主体<br><br>请求行 = 请求方法 + 请求URI + 请求协议版本<br><br>可选择的首部字段 = 请求首部 + 通用首部 + 实体首部 + 其他<br><br>如图：<br><br><img src="/home/zy/zy/myblog/source/_posts/http%E5%8E%86%E5%8F%B2%E5%8F%8A%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/1.png" alt="图1"><br>ex:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1     请求行</span><br><span class="line">Host: hackr.jp     </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0.8</span><br><span class="line">Accept-Language: ja,en-us;q=0.7,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">DNT: 1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class="line">If-None-Match: &quot;45bae1-16a-46d776ac&quot;</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">//空行(CR+LF)</span><br></pre></td></tr></table></figure><h3 id="http响应"><a class="header-anchor" href="#http响应">¶</a>http响应</h3><p>响应报文 = 协议版本 + 状态码 + 原因原语 + 可选择的首部字段 + 内容实体<br>= 报文首部 + 空行(CR+LF) + 报文主体<br><br>状态行 = 协议版本 + 状态码 + 原因原语<br><br>可选择的首部字段 = 响应首部字段 + 通用首部字段 + 实体首部字段 + 其他<br><br>如图:<br><br><img src="/home/zy/zy/myblog/source/_posts/http%E5%8E%86%E5%8F%B2%E5%8F%8A%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/2.png" alt="图2"><br>ex:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK    响应行</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line">//空行</span><br><span class="line">&lt;html&gt;        内容实体</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="首部字段"><a class="header-anchor" href="#首部字段">¶</a>首部字段</h3><p><strong>首部字段包括通用首部字段、请求首部字段、响应首部字段、实体首部字段和其他。</strong><br></p><ol><li><p>通用首部字段：General Header Fields<br>​ 请求报文和响应报文两方都会使用的首部。</p></li><li><p>请求首部字段：Request Header Fields<br>​ 客户端发送请求报文给服务器时使用，补充了请求的附加内容，客户端信息，响应内容相关的优先级等信息</p></li><li><p>响应首部字段：Response Header Fields<br>​ 服务器向客户端返回响应报文时使用的首部，补充响应的附加内容，也会要求客户端附加额外的内容信息。</p></li><li><p>实体首部字段：Entity header Fields<br>​ 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p></li></ol><h3 id="http可使用的方法"><a class="header-anchor" href="#http可使用的方法">¶</a>http可使用的方法</h3><ol><li>GET方法：<br><br>用来请求访问被URI识别的资源。指定的资源经服务器解析处理后返回响应内容。</li><li>POST方法:<br><br>用来传输实体的主体，但其主要目的并不是获取响应的主体内容。</li><li>PUT方法：<br><br>用来传输文件，但HTTP/1.1的PUT方法本身不带验证机制，存在安全性问题，因此一般不使用。</li><li>HEAD方法：<br><br>用来查看URI指定的资源的有效性，仅返回响应头部，不返回实体主体。</li><li>DELETE方法：<br><br>用来删除请求URI指定的资源，与PUT方法相反，因此也一般不使用。</li><li>OPTIONS方法：<br><br>用来询问针对请求URI指定的资源支持的方法。</li><li>TRACE方法：<br><br>用来追踪路径，将客户端请求怎么发往服务器经过的路径反馈回去。</li><li>CONNECT方法：<br><br>此方法主要是与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议将通信内容加密后传输到隧道。</li></ol><h3 id="http状态码"><a class="header-anchor" href="#http状态码">¶</a>http状态码</h3><p>状态码的类别：<br><br><img src="http%E5%8E%86%E5%8F%B2%E5%8F%8A%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/3.png" alt="图3"><br>具体例子如下:<br></p><ul><li>200 OK 表示从客户端发来的请求在服务器端被正常处理了。</li><li>204 No Content 表示服务器接收成功受理，但是返回的响应报文中不含实体的主体部分。</li><li>206 Partial Content 表示客户端请求一定的范围内容，然后获取成功返回状态</li><li>301 Moved Permanently 表示永久性重定向，所请求的资源已经分配到了新的URI，以后资源都指向这个URI</li><li>302 Found 表示临时性重定向，希望用户本次使用新的URI，实际运用中允许POST方法改成GET方法。</li><li>303 See Other 也表示临时性重定向，但指定客户端采用GET方法。</li><li>304 Not Modified 该状态码表示发送附带条件时,不满足条件，则返回这个。</li><li>307 Temporary Redirect也表示临时的重定向，且不会从POST变为GET.</li><li>400 Bad Request 表示请求报文出错</li><li>401 Unauthorized 表示发送的请求需要有通过HTTP认证信息。</li><li>403 Forbidden 该状态码表示对请求资源的访问被服务器拒绝了。</li><li>404 Not Found 服务器上无法找到请求的资源。</li><li>500 Internal Server Error 表示服务器端在执行请求时发生了错误。</li><li>503 Service Unavailable 表示服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;书籍是人类进步的阶梯
&lt;br&gt;&lt;b&gt;高尔基&lt;/b&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/4.jpg&quot; class=&quot;full-image&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;he
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zy943453722.ink/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://zy943453722.ink/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络协议" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>划分子网与构造超网</title>
    <link href="http://zy943453722.ink/post/40d97749.html"/>
    <id>http://zy943453722.ink/post/40d97749.html</id>
    <published>2018-02-01T10:02:21.000Z</published>
    <updated>2019-01-02T01:58:41.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p><strong><em>笔者上一篇分享了<a href="http://zy943453722.ink/tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%844%E7%A7%8D%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2/">tcp层可靠传输和流量控制的4种协议</a>，这次来分享一下ip层的重要知识，也就是划分子网和构造超网。</em></strong></p><h2 id="前提"><a class="header-anchor" href="#前提">¶</a>前提</h2><p><strong>在讲述划分子网和构造超网之前，让我们先来回忆一下ip地址的划分。</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip地址::=&#123;&lt;网络号&gt;,&lt;主机号&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>ip地址的划分以下几个特点：</strong></p><ol><li>ip地址划分为A类、B类、C类、D类、E类5种</li><li>A、B、C类地址都是常用的单播地址，而D类是多播地址，E类地址保留为以后用</li><li>ip地址都是32位的二进制代码，为提高可读性，IP地址每8位插入一个点，叫做点分十进制表示法</li><li>一般的，A类地址第一位二进制是0，B类地址前两位是10，C类地址前三位是110，D类地址前4位是1110，E类地址前4位地址是1111</li><li>A类地址前8位为网络号，7位可用，但7位全0（0.x.x.x)是个保留地址，表示本网络，7位全1(127.x.x.x)也是个保留地址，作为本地回环测试。因此可以指派2^7-2地址最为网络地址。</li><li>A类地址的主机号24位，但是全0(x.0.0.0)为网络地址即网关(网段)地址，全1(x.255.255.255)为该网段内的所有的主机</li><li>B类地址前16位为网络号，14为可用，但是14位中全1(128.0.0.0)不指派,因此B类地址可以指派网络数为2^14-1</li><li>B类地址主机号16位，全0，全1不指派，因此主机数为2^16-2</li><li>c类地址前24位为网络号，21位可用，但是21位全0(192.0.0.x)不指派，因此C类地址可以指派网络数为2^21-1</li><li>C类地址主机号8位，全0，全1不指派，因此主机数为2^8-2</li></ol><p><strong><em>特殊的不使用的ip地址</em></strong><br><br><img src="/home/zy/zy/myblog/source/_posts/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E4%B8%8E%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/zz.png" alt="图1"></p><h2 id="划分子网"><a class="header-anchor" href="#划分子网">¶</a>划分子网</h2><h3 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h3><p>由于ip地址空间利用率低，ip地址不够用等原因，急需要一种措施解决，因此出现了划分子网。</p><h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3><p>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网，因此这个子网地址并不是真是网络通信中用到的外部地址，而是一个内部地址，因此这个单位对外仍表现为一个地址，即网关地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip地址 ::= &#123;&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;&#125;</span><br><span class="line">即从主机号拿出一部分作为子网号。</span><br></pre></td></tr></table></figure><h3 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h3><p>要想在路由转发时找到相应的子网，需要用到子网掩码。子网掩码是一个网络或一个子网的重要属性。<br>![图2](划分子网与构造超网/1.png<br><br><strong><em>子网划分举例：</em></strong><br></p><h3 id="求网络地址"><a class="header-anchor" href="#求网络地址">¶</a>求网络地址</h3><p><strong><em>网络地址:<br></em></strong><br>即网关地址，一个单位千千万万台主机对外的地址</p><p><strong><em>求法:<br></em></strong><br>ip地址 和 子网掩码 相与。<br><br>ex:已知ip地址为141.14.72.24，子网掩码为255.255.192.0，求网络地址(即子网地址)？<br><br>解答：<br><br>将十进制转化成二进制，逐位相与。<br><br>ip十进制：141   .    14    .   72     .    24<br><br>ip二进制：10001101.    00001110  .  01001000.   00011000<br><br>子网掩码：11111111.    11111111  .</p><ol start="11000000"><li>00000000<br><br>因此相与可得<br>网络地址二进制：10001101. 00001110. 01000000. 00000000<br><br>网络地址十进制：141.14.64.0<br><br><strong>求主机号：</strong><br></li><li>首先观察子网掩码与默认子网掩码的区别，比如此题，这是B类的ip，子网掩码默认应为255.255.0.0，而实际为255.255.192.0，即拿出了一部分主机号作为子网号。</li><li>从子网掩码二进制可以看出第三节前2位与默认子网掩码不同，那么也就是拿出了2位主机号作为子网号，子网号2位，主机号14位。</li><li>由ip地址可以看出主机号为001000.00011000，再化成10进制。</li></ol><h3 id="子网规划"><a class="header-anchor" href="#子网规划">¶</a>子网规划</h3><p><strong>例题</strong><br><br><img src="/post/5.png" alt="图5"><br><img src="/post/6.png" alt="图6"></p><h2 id="构造超网-无分类编址cidr"><a class="header-anchor" href="#构造超网-无分类编址cidr">¶</a>构造超网(无分类编址CIDR)</h2><h3 id="背景-v2"><a class="header-anchor" href="#背景-v2">¶</a>背景</h3><p><strong><em>划分子网缓解了一定的困难，但是ipv4地址眼看就要耗尽，人们研究出了无分类域间路由选择CIDR。</em></strong></p><h3 id="概念-v2"><a class="header-anchor" href="#概念-v2">¶</a>概念</h3><p>CIDR使ip地址从三级编址再次变为二级编址，但是无分类的二级编址，不分A.B.C类。记法为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址 ::=&#123;&lt;网络前缀&gt;，&lt;主机号&gt;&#125;</span><br><span class="line">a.b.c.d/x  x为地址中网络部分的位数，32-x为主机位数。</span><br></pre></td></tr></table></figure><p>此外，CIDR还采用斜线/记法,然后写上网络前缀所占的位数。</p><h2 id="应用"><a class="header-anchor" href="#应用">¶</a>应用</h2><p>由CIDR的某个IP地址可以看出子网掩码。<br><br>ex:128.14.35.7/20<br><br>隐含的指出子网掩码中有20个1，由观察可知此地址是B类地址，默认子网掩码为255.255.0.0，32-20=12位主机号，则4位主机号，因此子网掩码为255.255.240.0<br><br><br>使用CIDR地址块后，网络路由器中的路由表项可以表示很多个传统IP地址的路由信息，相当于把若干个网络合并为一个超网来进行路由，这种地址的聚合称为路由聚合，也称为构造超网.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;笔者上一篇分享了&lt;a href=&quot;http://zy943453722.ink/tcp%E5%8F%AF%E9%9D%A0%E4
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zy943453722.ink/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://zy943453722.ink/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="ip" scheme="http://zy943453722.ink/tags/ip/"/>
    
  </entry>
  
  <entry>
    <title>tcp可靠传输和流量控制的4种协议的演变史</title>
    <link href="http://zy943453722.ink/post/ed84d9d4.html"/>
    <id>http://zy943453722.ink/post/ed84d9d4.html</id>
    <published>2018-01-30T09:35:04.000Z</published>
    <updated>2019-01-02T01:58:41.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p><strong><em>学习了计算机网络之后，发现很多基础知识其中的奥秘是经过前人一步步探索得来的，故而搜索了很多的资料，在这里用几篇博文进行总结。</em></strong><br><br><strong><font color="blue">首先要说到的就是tcp可靠传输和流量控制的4种协议，这4种协议从无到有，从最初的单工停等协议(停止等待ARQ协议)到连续ARQ协议、选择重传ARQ协议，直到最终的滑动窗口协议，经过了一系列的演变过程。本博文就来浅析一下它们的区别和演变过程。</font></strong></p><h2 id="单工停等协议"><a class="header-anchor" href="#单工停等协议">¶</a>单工停等协议</h2><h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3><p><strong><em>即发送方每次发送完一个分组(此处可能是tcp报文也可能是MAC帧)就停止发送，等待接收方的确认，只有在收到确认之后才能够再发送下一个分组。</em></strong></p><h3 id="具体描述"><a class="header-anchor" href="#具体描述">¶</a>具体描述</h3><p><strong><em><font size="3">工作原理:</font></em></strong></p><ol><li>发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。(利用超时计时器计时)</li><li>在等待过程中，发送点停止发送新的数据包。</li><li>当数据包没有成功被接收点接收时候，接收点不会发送ACK.这样发送点在等待一定时间后，重新发送数据包。</li><li>反复以上步骤直到收到从接收点发送的ACK.</li></ol><p><strong><em><font size="3">原理图如下:</font><br></em></strong><br><img src="/post/1.png" alt="无差错"><br><br>如图1即在无差错的情况下，A发送，B接收，只有A收到B的确认时才可以发送下一个分组。<br><img src="/post/2.png" alt="有差错"><br>如图2即出现差错时利用的一种机制叫做超时重传机制，B没有收到A的报文，A也没收到来自B的确认报文，经过一个设定时间后，超时计时器到期，那么就要重传。<br><img src="/post/3.png" alt="3"><br><br>如图3即当A的发送分组没有差错和丢弃，但是B的确认分组出现差错，那么A收不到确认也就无法判断是确认出错还是发送分组出错,因此B需要丢弃当前接收的分组，等待超时计时器到期A重新发送，而后接收。<br><img src="/post/4.png" alt="4"><br><br>如图4即B的确认没有出错或者丢失，只是因为信道拥塞导致延时到达，因此A无法收到确认y而是需要重新发送之前的发送分组。</p><h3 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h3><p><strong>这个协议的缺点是较长的等待时间导致低的数据传输速度。在低速传输时，对连接频道的利用率比较好，但是在高速传输时，频道的利用率会显著下降。</strong></p><h2 id="连续arq协议"><a class="header-anchor" href="#连续arq协议">¶</a>连续ARQ协议</h2><h3 id="定义-v2"><a class="header-anchor" href="#定义-v2">¶</a>定义</h3><p><strong><em>为了克服停止等待协议需要长时间等待的缺点，故而出现了连续ARQ协议，它是指发送方维护着一个窗口,这个窗口中不止一个分组,有好几个分组,窗口的大小是由接收方返回的win值决定的,所以窗口的大小是动态变化的,只要在窗口中的分组都可以被发送,这就使得TCP一次不是只发送一个分组了,从而大大提高了信道的利用率.并且它采用<font color="red">累积确认</font>的方式,对于<font color="red">按序</font>到达的最后一个分组发送确认。</em></strong></p><h3 id="具体描述-v2"><a class="header-anchor" href="#具体描述-v2">¶</a>具体描述</h3><p><strong><font size="3">原理：</font></strong><br><br><img src="/post/5.png" alt="3"><br><br><br>如图可知发送方维护一个5分组大小的窗口，只有收到接收方的一个确认后才将窗口向前挪动。<br>但是接收方由于<strong>累计确认</strong>方式,虽然一次性仍然只能接收一个确认分组，但是发送方不必等待接收方确认便可以再次发送。因此，接收方可以在收到几个分组之后，对<strong>按序到达</strong>的最后一个分组发送确认，这就表示到这个分组之前的所有分组都正确收到了。<br><strong><br>重传机制：</strong><br><br>采用回退N机制(Go-back-N)即GBN,表示凡是被发送出去尚未被确认的分组都放在发送方提供的较大的缓冲区内，若得到确认则取出。当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧。其中利用超时计时器，若在规定时间内没有收到对应的应答帧，或者累计的应答帧，那么就说明出错了。</p><h3 id="缺点-v2"><a class="header-anchor" href="#缺点-v2">¶</a>缺点</h3><p>虽然连续ARQ的链路效率大大提升，但是相应的需要更大的缓冲空间，且接收方窗口大小总是1，浪费很多链路的带宽。</p><h2 id="选择重传arq协议"><a class="header-anchor" href="#选择重传arq协议">¶</a>选择重传ARQ协议</h2><h3 id="定义-v3"><a class="header-anchor" href="#定义-v3">¶</a>定义</h3><p>发送方据一个指定大小的窗口持续发送若干分组，即使发送过程中丢失分组，也会继续发送。和Go-back-N ARQ不一样，接收进程在出错后还是继续接收和确认帧。</p><h3 id="具体描述-v3"><a class="header-anchor" href="#具体描述-v3">¶</a>具体描述</h3><p><strong><em>基本原理：<br></em></strong><br>如果一个发送的帧没有到达接收方，发送方继续发送后面的帧，直到它填满发送窗口 。接收方持续用接收的帧填充它的接收窗口，并且每次回复一个带有序列号的ACK帧。一旦发送窗口所有帧都发送了 ，发送方重新发送的帧号与ACK不对应的帧，然后继续。<br><img src="/post/6.png" alt="4"><br><br><br>如图可知在2号分组出错时，继续发送其他的分组，接收方同时也接收其他的分组，但是并不提交给上层，只有等待重传的分组到达之后，再按序提交给高层。</p><p><strong>注意：</strong> 接收方窗口大小与发送方要相同，并且最大的窗口值取最大序列号的一半。</p><h3 id="缺点-v3"><a class="header-anchor" href="#缺点-v3">¶</a>缺点</h3><ol><li>通信信道的利用率不高，也就是说，信道还远远没有被数据比特填满。</li><li>是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送数据包来纠正错误的方法也严重的影响了它的传输速度。</li></ol><h2 id="滑动窗口协议"><a class="header-anchor" href="#滑动窗口协议">¶</a>滑动窗口协议</h2><h3 id="定义-v4"><a class="header-anchor" href="#定义-v4">¶</a>定义</h3><p>滑动窗口协议实际是选择重传ARQ的特殊情况。</p><h3 id="前提"><a class="header-anchor" href="#前提">¶</a>前提</h3><ol><li>TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收)。</li><li>发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li><li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；</li><li>每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；</li></ol><h3 id="具体实现"><a class="header-anchor" href="#具体实现">¶</a>具体实现</h3><p><strong>原理图：<br></strong><br><img src="/post/7.png" alt="7"><br><br><br>分析图中可以看出：</p><ol><li>初始时发送窗口前沿是0，后沿也是0，因为前沿是指下一发送的序号，而后沿是指下一应答序号。</li><li>而初始时接收窗口前沿是1，后沿是0，因为前沿和后沿之间的部分是指下一期望接收的序号。</li><li>发送方前沿是发送完一个分组后就移动，后沿是收到接收确认分组之后才移动。</li><li>接收方的前后沿同时移动，当接收到一个分组之后就向后移动。</li></ol><h2 id="4种协议的比较"><a class="header-anchor" href="#4种协议的比较">¶</a>4种协议的比较</h2><table><thead><tr><th></th><th style="text-align:center">单工停等</th><th style="text-align:center">连续ARQ</th><th style="text-align:center">选择重传ARQ</th><th style="text-align:center">滑动窗口</th></tr></thead><tbody><tr><td>应答帧是否需要编号</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>分组是否按序</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>发送窗口大小</td><td style="text-align:center">1</td><td style="text-align:center">&gt;1</td><td style="text-align:center">&gt;1,最大值为最大确认序列号的一半</td><td style="text-align:center">同选择重传ARQ</td></tr><tr><td>接收窗口大小</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">&gt;1,同发送窗口</td><td style="text-align:center">同选择重传ARQ</td></tr></tbody></table><h3 id="参考资料："><a class="header-anchor" href="#参考资料：">¶</a>参考资料：</h3><p><a href="http://blog.csdn.net/guoweimelon/article/details/50879588" target="_blank" rel="noopener">http://blog.csdn.net/guoweimelon/article/details/50879588</a><br><a href="http://blog.csdn.net/wbw1985/article/details/4879224" target="_blank" rel="noopener">http://blog.csdn.net/wbw1985/article/details/4879224</a><br><a href="http://pmghong.blog.51cto.com/3221425/1242470" target="_blank" rel="noopener">http://pmghong.blog.51cto.com/3221425/1242470</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;学习了计算机网络之后，发现很多基础知识其中的奥秘是经过前人一步步探索得来的，故而搜索了很多的资料，在这里用几篇博文进行总结。&lt;/
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zy943453722.ink/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://zy943453722.ink/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="tcp" scheme="http://zy943453722.ink/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>php中静态类、抽象类和接口类的区别</title>
    <link href="http://zy943453722.ink/post/a888efb7.html"/>
    <id>http://zy943453722.ink/post/a888efb7.html</id>
    <published>2018-01-11T14:30:20.000Z</published>
    <updated>2019-01-02T01:58:41.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p><strong>最近笔者学习了php的基本知识，其基本语法像极了c语言，但是取消了指针等特性，且操作起来更加简便。下面就浅析一下php面向对象中的特性：静态类、抽象类和接口以及很好用的代码复用技术trait。</strong></p><h2 id="静态类"><a class="header-anchor" href="#静态类">¶</a>静态类</h2><h3 id="静态类定义："><a class="header-anchor" href="#静态类定义：">¶</a>静态类定义：</h3><p><strong><em>类中含有static修饰的方法或者属性的类。</em></strong></p><h3 id="静态类的特性和易错点"><a class="header-anchor" href="#静态类的特性和易错点">¶</a>静态类的特性和易错点</h3><ol><li>静态类中的成员不用实例化对象访问。用类名：：属性名/方法名 访问。</li><li>实例化的对象只能访问静态方法，不可访问静态属性。</li><li>继承时子类可以继承父类的公有和受保护的方法和属性。</li><li>可以说静态方法和属性不属于这个类，所以不能用自引用指针$this去引用，但却可以通过self或者parent访问。</li></ol><h3 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Foo&#123;</span><br><span class="line">    public $my = &quot;zy&quot;;</span><br><span class="line">    public static $my_static = &apos;foo&apos;;//初始化附常量</span><br><span class="line">    public function staticValue()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;my;</span><br><span class="line">        //echo $this-&gt;my_static;这些属性不属于类</span><br><span class="line">        return self::$my_static;</span><br><span class="line">    &#125;</span><br><span class="line">    public static function handle()</span><br><span class="line">    &#123;</span><br><span class="line">        //$this-&gt;$my_static;静态方法中没有$this这个伪变量</span><br><span class="line">        echo &quot;这是静态变量\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    protected static function func()</span><br><span class="line">    &#123;</span><br><span class="line">       echo &quot;protected static\n&quot;;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bar extends Foo&#123;</span><br><span class="line">    public function fooStatic()&#123;</span><br><span class="line">        return parent::$my_static;       </span><br><span class="line">    &#125;</span><br><span class="line">    public function funn()</span><br><span class="line">    &#123;</span><br><span class="line">        echo self::func().&quot;\n&quot;;//继承了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">echo Foo::$my_static.&quot;\n&quot;;</span><br><span class="line">echo Foo::handle().&quot;\n&quot;;</span><br><span class="line">$foo = new Foo();</span><br><span class="line">//echo $foo-&gt;$my_static.&quot;\n&quot;;//不可用对象直接访问静态属性</span><br><span class="line">echo $foo-&gt;handle().&quot;\n&quot;;//用对象可直接访问静态方法</span><br><span class="line">echo $foo-&gt;staticValue().&quot;\n&quot;;</span><br><span class="line">echo Bar::$my_static.&quot;\n&quot;;</span><br><span class="line">$bar = new Bar();</span><br><span class="line">echo $bar-&gt;fooStatic().&quot;\n&quot;;</span><br><span class="line">echo $bar-&gt;handle();</span><br><span class="line">$bar-&gt;funn();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h2><h3 id="抽象类的定义"><a class="header-anchor" href="#抽象类的定义">¶</a>抽象类的定义</h3><p>*** 被abstract修饰的类。***</p><h3 id="抽象类的特性和易错点"><a class="header-anchor" href="#抽象类的特性和易错点">¶</a>抽象类的特性和易错点</h3><ol><li>抽象类不可被实例化</li><li>任何一个类，若其中至少有一个抽象方法，那么该类就必须定义为抽象类，类中可以有非抽象的方法或属性。</li><li>抽象方法只声明其调用方式，不定义具体功能。</li><li>继承某个抽象类后，其子类必须实现所有的抽象方法，且不论函数名、参数都不能改变，但是继承访问控制可以一致或更宽松。</li><li>若子类继承的父类抽象方法中参数列表是可选参数，那么也可以与父类参数个数不一致，即子类可以有个默认参数列表。</li></ol><h3 id="实例："><a class="header-anchor" href="#实例：">¶</a>实例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">abstract class AbstractClass&#123;//此类不可实例化对象</span><br><span class="line">    abstract protected function getValue();</span><br><span class="line">    abstract protected function prefixValue($prefix);//只声明，不作具体实现</span><br><span class="line">    abstract public function pre($han);</span><br><span class="line">    const i = 12;</span><br><span class="line">    public $a = 13;</span><br><span class="line">    public function printOut()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;a.&quot;\n&quot;;</span><br><span class="line">        echo $this-&gt;getValue().&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">class ConcreteClass1 extends AbstractClass</span><br><span class="line">&#123;</span><br><span class="line">    protected function getValue() &#123;</span><br><span class="line">        return &quot;ConcreteClass1&quot;;//实现具体实现，必须保持一致</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function prefixValue($prefix) &#123;</span><br><span class="line">        return &quot;$prefix.ConcreteClass1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function pre($han,$ren = &apos;a&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">       echo $han.$ren.&quot;\n&quot;;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteClass2 extends AbstractClass</span><br><span class="line">&#123;</span><br><span class="line">    public function getValue() &#123;</span><br><span class="line">        return &quot;ConcreteClass2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function prefixValue($prefix) &#123;</span><br><span class="line">        return &quot;&#123;$prefix&#125;ConcreteClass2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function pre($han,$ren = &apos;a&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">       echo $han.$ren.&quot;\n&quot;;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class1 = new ConcreteClass1;//继承抽象类的类才可以实例化</span><br><span class="line">$class1-&gt;printOut();</span><br><span class="line">echo $class1-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;</span><br><span class="line">$class1-&gt;pre(&quot;zy&quot;);//可以打印出默认的参数</span><br><span class="line">$class2 = new ConcreteClass2;</span><br><span class="line">$class2-&gt;printOut();</span><br><span class="line">echo $class2-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;</span><br><span class="line">echo AbstractClass::i;//同样可以输出常量，无法输出变量</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h2><h3 id="接口的定义"><a class="header-anchor" href="#接口的定义">¶</a>接口的定义</h3><p>*** interface修饰的一个特殊的抽象类，但不是类。***</p><h3 id="接口特性和易错点"><a class="header-anchor" href="#接口特性和易错点">¶</a>接口特性和易错点</h3><ol><li>接口定义的所有方法都是空的</li><li>接口中的所有方法都是公有的，这是接口的特性</li><li>接口的定义使用interface，但是接口的实现就要用到implements,实现接口的实际是类</li><li>接口实现过程中要实现全部定义的接口</li><li>接口可以继承，用extends实现，与接口的实现不是一个意思,继承之后用类实现时要全部实现</li><li>接口中可以声明常量但是不可声明变量</li><li>可以说接口是特殊的抽象类，他里面的方法也是不实现功能的抽象类但是为了方便，不写abstract还有定义成interface而非类</li><li>一个类虽然是单继承的，但是一个类可以实现多个接口,多个接口之间用逗号隔开</li></ol><h3 id="实例-v2"><a class="header-anchor" href="#实例-v2">¶</a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">interface iTemplate</span><br><span class="line">  &#123;</span><br><span class="line">      const name = &quot;ha&quot;;</span><br><span class="line">      public function setVariable($name,$var);//必须是公有的方法</span><br><span class="line">      public function getHtml($template);</span><br><span class="line">  &#125;</span><br><span class="line">  interface inTel&#123;</span><br><span class="line">    public function handle();   </span><br><span class="line">  &#125;</span><br><span class="line">  //一个接口类可以实现多个定义的接口</span><br><span class="line">  class Template implements iTemplate,inTel&#123;</span><br><span class="line">      private $vars = array();</span><br><span class="line">      public function setVariable($name,$var)</span><br><span class="line">      &#123;</span><br><span class="line">          $this-&gt;vars[$name] = $var;</span><br><span class="line">      &#125;</span><br><span class="line">      public function getHtml($template)</span><br><span class="line">      &#123;</span><br><span class="line">          foreach($this-&gt;vars as $name =&gt; $value)</span><br><span class="line">          &#123;</span><br><span class="line">              $template = str_replace($name,$value,$template);//把字符串template中的name字符换成value</span><br><span class="line">          &#125;</span><br><span class="line">          return $template;</span><br><span class="line">      &#125;</span><br><span class="line">      public function handle()</span><br><span class="line">      &#123;</span><br><span class="line">          echo &quot;handle things\n&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;//用一个类去实现接口  </span><br><span class="line">    //$te = new iTemplate();因为是一种特殊的抽象类，因此也是不能实例化对象的</span><br><span class="line">    $tel = new Template();</span><br><span class="line">    $tel-&gt;setVariable(&apos;zy&apos;,&apos;人才&apos;);</span><br><span class="line">    echo $tel-&gt;getHtml(&apos;zyzsddw&apos;).&quot;\n&quot;;</span><br><span class="line">    $tel-&gt;handle();</span><br><span class="line">    echo iTemplate::name;//输出接口中定义的常量</span><br><span class="line">  ?&gt;</span><br></pre></td></tr></table></figure><h2 id="trait"><a class="header-anchor" href="#trait">¶</a>trait</h2><h3 id="trait的定义"><a class="header-anchor" href="#trait的定义">¶</a>trait的定义</h3><p><strong><em>Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制</em></strong></p><h3 id="trait的特性和易错点"><a class="header-anchor" href="#trait的特性和易错点">¶</a>trait的特性和易错点</h3><ol><li>trait是一种代码复用技术，相当于一种池技术，把好多功能(方法)写在其中，用的时候调用即可。可代替继承技术</li><li>他的调用优先级高于继承后的同名方法的优先级</li><li>它本身无法进行实例化</li><li>可以同时有多个trait，类中use声明时用逗号隔开</li><li>trait也可以使用多个trait作为成员</li><li>不可以声明静态成员，可在方法中定义静态变量</li></ol><h3 id="实例-v3"><a class="header-anchor" href="#实例-v3">¶</a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Base&#123;</span><br><span class="line">    public function sayHello()&#123;</span><br><span class="line">        echo &apos;hello&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">trait mysay&#123;</span><br><span class="line">    public function mysays()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;this is my says\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">trait SayWorld&#123;//声明方式相当于一个类</span><br><span class="line">    //static public $c = 1;除非定义在方法中</span><br><span class="line">    public $name = &quot;zy&quot;;</span><br><span class="line">    public function sayHello()&#123;</span><br><span class="line">      parent::sayHello();</span><br><span class="line">      echo &quot;World\n&quot;;</span><br><span class="line">   &#125;  </span><br><span class="line">   public function says()&#123;</span><br><span class="line">       echo &quot;zwdfw\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   public static function func()</span><br><span class="line">   &#123;</span><br><span class="line">       static $c = 1;</span><br><span class="line">       echo &quot;$c.this is static\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   protected function sayno()</span><br><span class="line">   &#123;</span><br><span class="line">       echo &quot;sayno&quot;.&quot;\n&quot;;</span><br><span class="line">   &#125; </span><br><span class="line">   abstract public function getworld();//允许定义抽象方法</span><br><span class="line">&#125;</span><br><span class="line">class Myhello extends Base&#123;</span><br><span class="line">   use SayWorld,mysay;//用这种方式调用trait,相当于把所有的方法都继承到了  </span><br><span class="line">   public function getworld()</span><br><span class="line">   &#123;</span><br><span class="line">       echo &quot;nihao world\n&quot;;//使用了trait就要实现抽象方法</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">$foo = new Myhello();</span><br><span class="line">$foo-&gt;sayHello();//优先级高于继承来的同名方法</span><br><span class="line">$foo-&gt;says();//随意调用其中的方法</span><br><span class="line">//$foo-&gt;sayno();//私有方法和受保护的方法无法从trait中获取</span><br><span class="line">$foo-&gt;func();</span><br><span class="line">$foo-&gt;mysays();</span><br><span class="line">mysay::mysays();//无法实例化trait的对象访问，可以用trait名::方法/变量的形式访问</span><br><span class="line">echo $foo-&gt;name.&quot;\n&quot;;</span><br><span class="line">//echo $foo-&gt;c.&quot;\n&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="这四种php中oo特性的代表的区别"><a class="header-anchor" href="#这四种php中oo特性的代表的区别">¶</a>这四种php中oo特性的代表的区别</h2><table><thead><tr><th></th><th style="text-align:center">静态类</th><th style="text-align:center">抽象类</th><th style="text-align:center">接口</th><th style="text-align:center">trait</th></tr></thead><tbody><tr><td>是否可以实例化对象</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td>类外访问方式</td><td style="text-align:center">1.类名::属性/方法 <br>   2.对象名-&gt;方法</td><td style="text-align:center">子类继承实现，<br>实例化子类，<br>子类对象调用属性/方法</td><td style="text-align:center">子类implements实现，子类实例化对象调用属性/方法</td><td style="text-align:center">类中use实现，类外实例化对象调用属性/方法</td></tr><tr><td>方法是否立即实现</td><td style="text-align:center">类内外都可以</td><td style="text-align:center">子类实现</td><td style="text-align:center">子类实现</td><td style="text-align:center">类内外都可以</td></tr><tr><td>方法的访问控制</td><td style="text-align:center">都可以</td><td style="text-align:center">抽象方法公有或者受保护，普通方法都可以</td><td style="text-align:center">均为公有</td><td style="text-align:center">都可以</td></tr><tr><td>实现方式</td><td style="text-align:center">类内类外都可以</td><td style="text-align:center">子类继承实现</td><td style="text-align:center">子类继承实现</td><td style="text-align:center">内部实现</td></tr><tr><td>是否可以声明常量/变量</td><td style="text-align:center">都可以</td><td style="text-align:center">都可以，但变量无法类外访问</td><td style="text-align:center">常量可以，变量不可以</td><td style="text-align:center">都可以</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;最近笔者学习了php的基本知识，其基本语法像极了c语言，但是取消了指针等特性，且操作起来更加简便。下面就浅析一下php面向对象中的特性：
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php基本语法" scheme="http://zy943453722.ink/tags/php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>探寻psr标准</title>
    <link href="http://zy943453722.ink/post/b09a0ec3.html"/>
    <id>http://zy943453722.ink/post/b09a0ec3.html</id>
    <published>2018-01-02T09:47:01.000Z</published>
    <updated>2019-01-02T01:58:41.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p><strong>笔者学习symfony框架，看源码之时，发现好多函数带有psr的后缀，心想这是个什么东东。。。于是乎google了一番，发现这正是“心仪已久”的PHP开发的标准规范啊！！！</strong><br><br>但是好多东西在对应的官方文档<a href="https://psr.phphub.org/" target="_blank" rel="noopener">PSR标准规范文档</a>都有，因此笔者在此只做代码的示范，用代码来表示规范。</p><h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>PSR 是 PHP Standard Recommendations 的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。<br><br>目前已表决通过了 6 套标准，已经得到大部分 PHP 框架的支持和认可。<br><br><strong>标准目录如下：<br></strong><br><img src="/post/1.png" alt="图1"></p><h2 id="详解"><a class="header-anchor" href="#详解">¶</a>详解</h2><h3 id="基本代码规范和编程风格规范"><a class="header-anchor" href="#基本代码规范和编程风格规范">¶</a>基本代码规范和编程风格规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">/**</span><br><span class="line"> * psr标准中的大部分语言规范</span><br><span class="line"> * </span><br><span class="line"> * @author zy</span><br><span class="line"> */</span><br><span class="line">//php代码文件必须以这个标签或者&lt;?= 开始</span><br><span class="line">//每行的字符数控制在80~120之间</span><br><span class="line">namespace Vender\Package;//命名空间块后都有一个空行，命名空间和子命名空间必须和相应的文件基目录(文件绝对路径)匹配。</span><br><span class="line">namespace Symfony\Component\Routing;//完整的类名必须有个顶级命名空间和一个或多个子命名空间，末尾的类名与对应的.php文件同名</span><br><span class="line"></span><br><span class="line">use Symfony\Component\Routing\Route;</span><br><span class="line">use FooInterface;//use语句后面也要有一行空行,use务必声明在namespace之后</span><br><span class="line"></span><br><span class="line">//类名必须遵循StudlyCaps大写驼峰命名法即多个单词组成名字每个单词首字母大写</span><br><span class="line">class FooFunction extends Bars implements FooInterface,</span><br><span class="line">    \ArrayAccess,</span><br><span class="line">    \Countable</span><br><span class="line">&#123;//多实现可以多行显示，但是要有缩进，且每个接口自成一行</span><br><span class="line"> //类的前后花括号均自成一行</span><br><span class="line">    public $superStar;//每个属性都要添加访问修饰符</span><br><span class="line">    public $commonPeople;//类的普通属性用哪种命名方式均可，但要统一</span><br><span class="line">    protected $files = null;//null,true,false这些关键字都小写</span><br><span class="line">    const MAX_COUNT = 120;//const定义的变量必须大写且单词间用下划线分隔</span><br><span class="line">    //方法名遵循camelCase式的小写驼峰命名法即多个单词组成名字时首单词小写，之后的每个单词首字母大写</span><br><span class="line">    public function sampleFunction($a, $b = null)</span><br><span class="line">    &#123;//方法的前后花括号也均自成一行</span><br><span class="line">        //缩进时不能使用tab要用4个空格进行缩进</span><br><span class="line">        if ($a === $b) &#123;</span><br><span class="line">            //控制结构诸如if-else，switch-case，while，for，foreach等等书写时这些关键字后要有一个空格</span><br><span class="line">            //前括号之前也要有一个空格，且前括号在关键字同一行，后括号自成一行</span><br><span class="line">            bar();</span><br><span class="line">        &#125; elseif ($a &gt; $b) &#123;//变量与运算符之间要有空格</span><br><span class="line">            $foo-&gt;bar($arg1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            BazClass::bar($arg2, $arg3);//方法的参数每个逗号后必须要有一个空格，有默认值的放到参数列表末尾</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //参数列表可以单独一行,结束括号必须和方法前花括号自成一行,final、abstract必须在访问修饰符前面，static在访问修饰符之后</span><br><span class="line">    final public static function aVeryLongMethod(</span><br><span class="line">        ClassTypeHint $arg1,</span><br><span class="line">        &amp;$arg2,</span><br><span class="line">        array $arg3 = []</span><br><span class="line">    )&#123;</span><br><span class="line">        switch ($expr) &#123;//case相对switch要有缩进</span><br><span class="line">            case 0: </span><br><span class="line">                echo &apos;xxxxxxx&apos;;//执行语句相对case也要缩进</span><br><span class="line">                break;</span><br><span class="line">            case 1://遇到这种case没有break的直穿语句，要有no break的注明 </span><br><span class="line">                echo &apos;second&apos;;</span><br><span class="line">                //no break</span><br><span class="line">            case 2:</span><br><span class="line">            case 3:</span><br><span class="line">                echo &apos;third&apos;;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                echo &quot;default case&quot;;</span><br><span class="line">                break;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    public function simpleFunction()</span><br><span class="line">    &#123;</span><br><span class="line">        while ($exp) &#123;//同样的诸如do-while，try-catch控制结构需要相同的结构</span><br><span class="line">            echo &apos;zzz&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        $clouseWith = function ($arg1, $arg2) use ($var1, $var2) &#123;</span><br><span class="line">            /*对于闭包函数也就是匿名函数，function后要有一个空格，use的前后都要有一个空格，并且前括号要和关键字在同一行，</span><br><span class="line">            但后括号单独成行*/</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">诸如此类产生副作用的操作，ex：</span><br><span class="line">                 生成输出</span><br><span class="line">                 直接的 require 或 include</span><br><span class="line">                 连接外部服务</span><br><span class="line">                 修改 ini 配置</span><br><span class="line">                 抛出错误或异常</span><br><span class="line">                 修改全局或静态变量</span><br><span class="line">                 读或写文件等</span><br><span class="line">的操作不能和声明类、函数等在同一个php文件下</span><br><span class="line">include &quot;file.php&quot;;</span><br><span class="line">echo &quot;&lt;html&gt;\n&quot;;</span><br><span class="line">ini_set(&apos;error_reporting&apos;,E_ALL);</span><br><span class="line">*/</span><br><span class="line">//纯php代码文件最后必须省略“?&gt;”标签</span><br><span class="line">//同时php文件最后必须要有一行空行作为结束</span><br></pre></td></tr></table></figure><h3 id="其他规范"><a class="header-anchor" href="#其他规范">¶</a>其他规范</h3><p>其他规范都是在框架或者项目中需要用的诸如日志、自动加载、缓存规范。因此就不在此赘述，贴出官方的规范：<a href="https://psr.phphub.org/" target="_blank" rel="noopener">https://psr.phphub.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;笔者学习symfony框架，看源码之时，发现好多函数带有psr的后缀，心想这是个什么东东。。。于是乎google了一番，发现这正是“心仪
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php" scheme="http://zy943453722.ink/tags/php/"/>
    
      <category term="编程基础" scheme="http://zy943453722.ink/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>IPC之管道通信的dup和dup2函数</title>
    <link href="http://zy943453722.ink/post/c37ff4aa.html"/>
    <id>http://zy943453722.ink/post/c37ff4aa.html</id>
    <published>2017-12-06T14:56:51.000Z</published>
    <updated>2019-01-02T01:58:41.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a class="header-anchor" href="#前言：">¶</a>前言：</h2><p><strong>前面笔者详细分析了网络编程中重要的通信技术：<font color="red">I/O复用技术</font>,接下来的几篇文章，我将重点来分析一下网络编程中另外一个重要的技术，即：<font color="blue">管道通信技术</font>。</strong></p><h2 id="dup-dup2函数基础"><a class="header-anchor" href="#dup-dup2函数基础">¶</a>dup、dup2函数基础</h2><p>由于利用管道实现进程间通信，是通过创建2个文件描述符，但是初始化文件描述符都是随机的，或者说是从可用的文件描述符中去除，并与相对应的文件建立映射关系，如果我们想要将管道的两头与其他流相关，或者说重定向一个文件描述符，那么，我们就需要dup和dup2函数。</p><p>可以说，这两个函数的作用就是：<br><br><strong><em>1.重定向文件描述符</em></strong><br><strong><em>2.复制文件描述符</em></strong></p><h3 id="dup函数："><a class="header-anchor" href="#dup函数：">¶</a>dup函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int dup(int fd);//fd为文件描述符，失败返回-1</span><br></pre></td></tr></table></figure><p><strong>dup函数创建一个新的文件描述符，该文件描述符和原有文件描述符指向相同的文件、管道或者网络链接，并且此fd总是系统当前可用的最小的文件描述符。</strong></p><h3 id="dup2函数："><a class="header-anchor" href="#dup2函数：">¶</a>dup2函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int dup2(int fd1, int fd2);</span><br><span class="line">//fd1是指需要重定向的文件描述符，fd2是定向到的文件描述符。失败返回-1</span><br></pre></td></tr></table></figure><p><strong>dup2函数中fd2不做原本的工作，而改做fd1的工作，若此fd2文件描述符已经存在，则需要关闭他，再执行。</strong></p><p><font size="3" color="green">需要注意的是：这两个函数创建的文件描述符并不继承原有的文件描述符的属性(ex：close_on_exec,non-blocking等)，因为每个文件描述符都有一套文件描述符标志，新描述符执行时关闭(close_on_exec)标志总是由dup和dup2函数执行。只继承他的同一文件状态标志(读、写、添加等)。</font><br><br><br>其实对于文件描述符在内核中的存储有必要提一下：</p><ul><li>每个进程在进程表中都有一个记录项，每个记录项中有一张打开文件描述符表，可将视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<br><br>(1) 文件描述符标志(close_on_exec,close_on_exec是一个进程所有文件描述符的标记位图，每个比特位代表一个打开的文件描述符，用于确定在系统调用execve()时需要关闭的文件句柄)。<br><br>(2) 指向一个文件表项的指针。</li><li>内核为所有打开文件维持一张文件表。每个文件表项包含：<br><br>(a) 文件状态标志(读、写、增写、同步、非阻塞等)。<br><br>(b) 当前文件位移量。<br><br>© 指向该文件v节点表项的指针。</li><li>节点表项。每个打开的文件都有一个v-node结构，v-node中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，V-node中还包含了文件inode节点信息，这些信息是打开文件时从磁盘上读入内存的，所以文件所有信息都是随时可用的。<br><br> 1. v节点的信息<br><br> 2. 当前文件的长度<br><br> 3. i节点的信息<br><br>**也就是对应下图。<br><br><strong>图解过程：</strong><br><br><strong>假设执行了dup(1)函数，下一个可用的文件描述符是3。两个文件描述符指向同一文件表项。因此文件状态标志、当前文件位移量、指向文件的v节点表项指针共享。</strong><br><br><img src="/post/file.png" alt="图1"></li></ul><h2 id="函数的简单实例："><a class="header-anchor" href="#函数的简单实例：">¶</a>函数的简单实例：</h2><p>下面的例子便是运用dup函数或者dup2函数，将新建的文件描述符指向之前建立好的网络连接，因为关闭了标准输出，因此文件描述符1空闲下来，可以使用，即相当于将标准输出定向到了网络连接中，实现CGI服务器功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">   if(argc &lt;= 2)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    const char* ip = argv[1];</span><br><span class="line">    int port = atoi(argv[2]);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in address;</span><br><span class="line">    bzero(&amp;address,sizeof(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    int sock = socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">    assert(sock &gt;= 0);</span><br><span class="line"></span><br><span class="line">    int ret = bind(sock,(struct sockaddr*)&amp;address,sizeof(address));</span><br><span class="line">    assert(ret != -1);</span><br><span class="line"></span><br><span class="line">    ret = listen(sock,5);</span><br><span class="line">    assert(ret != -1);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in client;</span><br><span class="line">    socklen_t client_addrlength = sizeof(client);</span><br><span class="line">    int connfd = accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength);</span><br><span class="line">    if(connfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;errno is %d\n&quot;,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        dup(connfd);//自动寻找最小的文件描述符</span><br><span class="line">        //dup2(connfd,1);//自己指定文件描述符，若已存在，则返回一个大于指定文件描述符的最小值</span><br><span class="line">        printf(&quot;abcd\n&quot;);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用telnet模拟客户端可以看出，的确本应该输出到标准输出的字符，送到了客户端，而没有打印到终端。实现了重定向功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言：&quot;&gt;¶&lt;/a&gt;前言：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前面笔者详细分析了网络编程中重要的通信技术：&lt;font color=&quot;red&quot;&gt;I/O复用技术&lt;/font&gt;,接下来的几篇文章，我
      
    
    </summary>
    
      <category term="IPC进程通信" scheme="http://zy943453722.ink/categories/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>I/O复用3个模型的比较</title>
    <link href="http://zy943453722.ink/post/bac82e48.html"/>
    <id>http://zy943453722.ink/post/bac82e48.html</id>
    <published>2017-11-16T16:25:40.000Z</published>
    <updated>2019-01-02T01:58:41.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a class="header-anchor" href="#前言：">¶</a>前言：</h3><p><strong><em>前面分析了I/O复用的3种模型，分别是select，poll，epoll，它们各有优缺点，并且应用广泛，今天就来分析一下他们的异同。</em></strong></p><h3 id="开场："><a class="header-anchor" href="#开场：">¶</a>开场：</h3><p><strong>分析之前还是讲一讲I/O复用在网络程序下的适用场合：</strong></p><ol><li>服务器同时监听socket和连接socket。</li><li>服务器端同时处理多个socket。</li><li>客户端程序同时处理用户输入和网络连接。</li><li>服务器同时处理TCP和UDP请求。</li><li>服务器监听多个端口，或者处理多个服务。<br><strong><br>I/O复用函数本身是阻塞的，它们必须顺序处理每个就绪的文件描述符，要想实现并发执行，要用到多线程/多进程编程。<font color="red">但I/O复用的优势也是在此,不必创建大量进程或者线程，也不必去维护它们，大大节约系统资源。</font></strong></li></ol><h3 id="渐进："><a class="header-anchor" href="#渐进：">¶</a>渐进：</h3><p><strong><em><font color="blue" size="4">三者的共同点：</font></em></strong></p><ul><li>这3种模型都能同时监听多个文件描述符，他们等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有时间就绪时返回，返回就绪的数量。</li><li>3者都是同步I/O模型，即在监听事件就绪后也需要自己来负责读写。</li><li>3者都通过某种结构体变量来告知内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</li></ul><h3 id="高潮："><a class="header-anchor" href="#高潮：">¶</a>高潮：</h3><p><strong><em><font color="blue" size="4">三者的区别：</font></em></strong></p><ul><li><p>poll、select是有事件就绪后就轮询所有的结构体数组中的文件描述符，看是否发生了感兴趣的事件。并将其中就绪的文件描述符返回给用户程序<strong>而epoll是有事件就绪后内核事件表将就绪事件放到一个结构体数组中，仅仅轮询这些就绪事件。即epoll_wait采用回调的方式，内核检测到就绪的文件描述符后，就触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。最后在适当时间将内容拷贝到用户空间。</strong></p></li><li><p>select参数类型fd_set 没有将文件描述符和事件进行绑定，它仅仅是一个文件描述符集合。而epoll、poll是将文件描述符和事件放入一个结构体中，实现了绑定。</p></li><li><p>epoll最大的区别是实现了用户注册事件和内核检测就绪事件的分离，搜索就绪事件只搜索返回的就绪事件。epoll是通过内核与用户空间mmap同一块内存实现的。而select、poll需要轮询所有文件描述符或者其一一对应的注册事件。</p></li><li><p>epoll适用于连接数量多，但活跃链接少的情况。select适用于并发量不高，且活跃链接多的情况。</p></li><li><p>另外还有几个小区别，请看下表：<br><br><img src="/post/I-O%E5%A4%8D%E7%94%A83%E4%B8%AA%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83%5C1.png" alt="图1"></p><h2 id="尾声"><a class="header-anchor" href="#尾声">¶</a>尾声</h2><p><strong><em><font color="green" size="4">浅析三者的工作流程：</font></em></strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言：&quot;&gt;¶&lt;/a&gt;前言：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;前面分析了I/O复用的3种模型，分别是select，poll，epoll，它们各有优缺点，并且应用广泛，今天就来分析一下他
      
    
    </summary>
    
      <category term="IPC进程通信" scheme="http://zy943453722.ink/categories/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>I/O复用之poll和epoll</title>
    <link href="http://zy943453722.ink/post/4bad3206.html"/>
    <id>http://zy943453722.ink/post/4bad3206.html</id>
    <published>2017-11-12T21:59:25.000Z</published>
    <updated>2019-01-02T01:58:41.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="poll函数"><a class="header-anchor" href="#poll函数">¶</a>poll函数</h2><p><strong><em>poll函数的定义：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd* fds,nfds_t nfds,int timeout)</span><br><span class="line">typedef unsigned long int nfds_t;</span><br><span class="line">struct pollfd&#123;</span><br><span class="line">   int fd;</span><br><span class="line">   short events;//注册的事件</span><br><span class="line">   short revents;//实际发生的事件，有内核填充</span><br><span class="line">&#125;;</span><br><span class="line">timeout为0时，poll调用后立即返回，不阻塞</span><br><span class="line">       为-1时，poll调用将永远阻塞，直至某个事件发生。</span><br></pre></td></tr></table></figure><p><strong><em>poll函数实现监视的过程：</em></strong></p><ul><li>调用poll函数实现对感兴趣的文件描述符的某个事件的监听。</li><li>而后读取返回值，若返回值大于0，则轮询创建好的pollfd结构体数组，看每一个注册的事件是否发生感兴趣的事件。</li></ul><h2 id="epoll函数"><a class="header-anchor" href="#epoll函数">¶</a>epoll函数</h2><h3 id="epoll函数的定义："><a class="header-anchor" href="#epoll函数的定义：">¶</a>epoll函数的定义：</h3><p><strong><br>epoll函数不同于poll和select，它是由一组函数组成的。</strong><br><strong><em><br>1. epoll创建函数：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size)//参数指定内核事件表的大小,返回一个指向内核事件表的fd：epollfd</span><br></pre></td></tr></table></figure><p><strong><em><br>2. epoll执行注册函数：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*第一个参数为内核事件表的文件描述符，第二个参数为指定的操作类型,</span><br><span class="line">第三个为要操作的文件描述符，第4个为注册的事件*/</span><br><span class="line">//返回0为成功，-1为失败</span><br><span class="line">int epoll_ctl(int epollfd,int op,int fd,struct epoll_event *event)</span><br></pre></td></tr></table></figure><p><strong>对于op操作类型，大体有3种：</strong></p><ul><li>EPOLL_CTL_ADD:往内核事件表注册事件结构体</li><li>EPOLL_CTL_MOD:修改fd上的注册事件</li><li>EPOLL_CTL_DEL:删除fd上的注册事件<br><strong><br>对于epoll_event结构体：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data&#123;</span><br><span class="line">   void *ptr;</span><br><span class="line">   int fd;//注册事件的文件描述符</span><br><span class="line">   uint32_t u32;</span><br><span class="line">   uint64_t u64;</span><br><span class="line">&#125;epoll_data_t;</span><br><span class="line">  struct epoll_event&#123;</span><br><span class="line">   __uint32_t events;//epoll事件</span><br><span class="line">   epoll_data_t data;//用户的数据</span><br><span class="line">&#125;;//一般是将事件和epoll_data_t用户数据绑定</span><br></pre></td></tr></table></figure><p><strong><em><br>3. epoll等待就绪函数：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*第一个参数指定内核事件表，第二个参数指定从内核事件表拷贝的就绪事件数组，</span><br><span class="line">第三个参数指定最多监听的事件个数，最后一个是设置超时时间同epoll*/</span><br><span class="line">//该函数成功时返回就绪事件个数，与文件描述符无关，失败返回-1</span><br><span class="line">int epoll_wait(int epollfd,struct epoll_event* events, int max,int timeout)</span><br></pre></td></tr></table></figure><p><strong><em><br>4.epoll的事件类型</em></strong></p><ul><li>EPOLLIN   ：数据可读（包括一般和优先数据）</li><li>EPOLLOUT  ：数据可写（包括一般和优先数据）</li><li>EPOLLERR ：数据错误</li><li>EPOLLET ：epoll的边沿触发模式事件</li><li>EPOLLONESHOT ：该文件描述符上的可读、可写、错误事件最多触发其中一个且只触发一次<br><strong><br>最后两个是epoll特有的，前三个去掉’E’即为poll的事件类型</strong><br><strong><em><br>5.epoll的模式：</em></strong><br><br>epoll中有两种模式，一种是LT模式，一种是ET模式。</li><li>LT模式：<br><br><font color="red" size="3">所谓LT模式，就是指电平触发，这是epoll默认的工作方式，要想改变可以通过上面的EPOLLET事件。这种模式下的epoll相当于一个效率较高的poll。<br><br>**这个模式下epoll_wait检测到有事件就绪后，应用程序可以不立即处理，那么下次调用epoll_wait仍会通告该事件，直至被处理。意味着每次epoll_wait()返回后，事件处理后，如果之后还有数据，会不断触发，也就是说，一个套接字上一次完整的数据，epoll_wait()可能会返回多次，直到没有数据为止。**这个模式下文件描述符可阻塞可不阻塞。<br>该模式下只要在可读/可写 状态下epoll_wait都能检测到，因此可以不一次处理完。</font></li><li>ET模式  :<br><br><font color="blue" size="3">所谓ET模式，就是指边沿触发，当某个文件描述符注册EPOLLET事件时，eopll将使用ET模式操作该文件描述符。<br>有数据过来后，epoll_wait()会返回一次，**一段时间内，<strong>该套接字就算有数据源源不断地过来，epoll_wait()也不会返回了。（即只会读出其中第一次的内容，再来数据是读不到的，但若是缓冲区不够的话，也会读到结束的）这里注意，是一段时间，不代表这个套接字上有数据就只触发一次。时间过长，还是会返回多次的。</strong><br>该模式与LT的最大区别就是当epoll_wait检测到事件就绪时，必须立即处理，后序再遇到epoll_wait不会在通告该事件，这样大大降低了同一个epoll事件被触发的次数。**该模式下文件描述符必须使用非阻塞。<strong>这种模式下发送多次否则，会因为缓冲区的不足造成发送或接收不到所有的数据。直到errno为EAGAIN时才算读(写)取完毕无数据可读(写）</strong><br>另外，该模式只有当某文件描述符由不可读/不可写 状态变为 可读/可写 状态时才能触发</font><br><font size="5" color="green"><br>因此，ET模式是高速工作模式，LT是缺省工作模式。</font><br><strong><em><br>6.网络事件EAGIN</em></strong><br><br>在一个非阻塞的socket上调用read/write函数, 返回EAGAIN或者EWOULDBLOCK。若遇到能read时，读缓冲区没有数据，或者write时，写缓冲区满了。这种情况下，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。<br><br>因此，对于non-blocking的socket，正确的读写操作为:<br><br>读：忽略掉errno = EAGAIN的错误，下次可继续读<br><br>写：忽略掉errno = EAGAIN的错误，下次可继续写<br><br>因此ET模式使用非阻塞IO模型下需要用EAGAIN这个标志来判断接受的数据是否读完。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;poll函数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#poll函数&quot;&gt;¶&lt;/a&gt;poll函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;poll函数的定义：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="IPC进程通信" scheme="http://zy943453722.ink/categories/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>结构体变量malloc的故事</title>
    <link href="http://zy943453722.ink/post/48d4f714.html"/>
    <id>http://zy943453722.ink/post/48d4f714.html</id>
    <published>2017-10-27T23:01:28.000Z</published>
    <updated>2019-01-02T01:58:41.880Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>这是一个关于结构体通过malloc初始化的悲伤的故事</em></strong></p><h3 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h3><p>因为本身结构体是不需要malloc就可以直接创建其对象，但是，当结构体中出现柔性数组或者是数组指针时，情况就截然不同了。因为这些数组都是要动态分配内存的，因此结构体也需要malloc。</p><h3 id="问题描述："><a class="header-anchor" href="#问题描述：">¶</a>问题描述：</h3><p>但是此时问题就出现了，本身创建结构体对象时会在栈区分配一块地址，但是malloc之后又有另外一块地址指向了此对象，这是该怎么办呢？</p><h3 id="代码实例："><a class="header-anchor" href="#代码实例：">¶</a>代码实例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*这仅仅是个用数组动态创建栈的初始化过程*/</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef struct stack</span><br><span class="line">&#123;</span><br><span class="line">      int top;</span><br><span class="line">      int count;</span><br><span class="line">      int array[];//柔性数组，也可以方括号内定义为0，也可以定义为数组指针</span><br><span class="line">&#125;Stack;</span><br><span class="line">void Init(Stack *s,int n)</span><br><span class="line">&#123;</span><br><span class="line">    s = (Stack*)malloc(sizeof(Stack) + n * sizeof(int));</span><br><span class="line">   s-&gt;top = -1;</span><br><span class="line">   s-&gt;count = n;</span><br><span class="line">&#125;</span><br><span class="line">void Destroy(Stack **s)</span><br><span class="line">&#123;</span><br><span class="line">      free(*s);</span><br><span class="line">      *s = NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   Stack s;</span><br><span class="line">   Stack *q = &amp;s;</span><br><span class="line">   Init(q);</span><br><span class="line">   Destroy(&amp;q);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gdb调试显示结果："><a class="header-anchor" href="#gdb调试显示结果：">¶</a>gdb调试显示结果：</h3><p><img src="/post/3.png" alt="图2"><br><img src="/post/4.png" alt="图3"><br><strong><em>由图中可以看出原本传入Init函数的stack</em>的地址为0x7fffffffde00，但malloc出来的新地址为0x602830,改变malloc出来地址上的内容，函数返回时自然而然没有保存下来。<br>再次打印s的地址，<font color="blue">果然还是原地址，相应数据也没有保存下来</font></strong></p><h3 id="解决方案："><a class="header-anchor" href="#解决方案：">¶</a>解决方案：</h3><p>思路:</p><p>既然一级指针会在init函数中被重新malloc，之后返回后保存不下来，那么可以启用2级指针，之后，让malloc出来的指针和原指针的地址相同(即2级指针也指向malloc出来的指针)这样返回时才能真正将malloc出来的指针保存下来。<br>具体解决方法<br>重写init方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Init(Stack **s,int n)</span><br><span class="line">&#123;</span><br><span class="line">  Stack *p = (Stack *)malloc(sizeof(Stack) + n * sizeof(int));//新malloc出一块地址指向原来的结构体</span><br><span class="line">  *s = p; //将新malloc出来的地址赋值给原地址，让两个变成同一地址</span><br><span class="line">  p-&gt;top = -1;</span><br><span class="line">  p-&gt;count = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图解："><a class="header-anchor" href="#图解：">¶</a>图解：</h3><p><img src="/post/zy.png" alt="图1"></p><p><strong>此时再次调用gdb调试：<br></strong><br><img src="/post/5.png" alt="图4"><br><img src="/post/6.png" alt="图5"><br>可以看出当从init函数返回后q指针已经变为malloc出来的地址，由此数据也被保存了下来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;这是一个关于结构体通过malloc初始化的悲伤的故事&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;¶&lt;/a&gt;背景&lt;/h3&gt;
&lt;p&gt;因为本身结构体是不需要mallo
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++中类的大小</title>
    <link href="http://zy943453722.ink/post/18b3c611.html"/>
    <id>http://zy943453722.ink/post/18b3c611.html</id>
    <published>2017-10-22T16:34:26.000Z</published>
    <updated>2019-01-02T01:58:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>*** 类所占内存的大小是有成员变量（静态变量除外）决定的，成员函数是不计算在内的，他们只是名义上在类里，其实同一个类的多个对象共享函数代码，而我们访问类的成员函数是通过类中的自引用指针实现的，所以我们访问成员函数是间接获得地址的。 ***</p><h3 id="空类"><a class="header-anchor" href="#空类">¶</a>空类</h3><p>空类的大小为1：</p><p>目的标示这个类，c++要求每个实例在内存中都具有独一无二的地址。</p><h3 id="普通类-不继承-不含虚函数"><a class="header-anchor" href="#普通类-不继承-不含虚函数">¶</a>普通类(不继承，不含虚函数）</h3><p>跟struct的原理一致，内存对齐原则，但静态变量不占用内存，原因是编译器将其放在了全局变量区。</p><h3 id="含有虚函数的类"><a class="header-anchor" href="#含有虚函数的类">¶</a>含有虚函数的类</h3><p>c++类中有虚函数的时候有一个指向虚函数的指针(vptr),因此此指针要占用字节空间，<strong>虚函数个数和大小无关。</strong></p><h3 id="继承的类"><a class="header-anchor" href="#继承的类">¶</a>继承的类</h3><p>子类的大小是本身成员变量的大小加上父类的大小，若父类本身就含有虚函数，则子类无论有没有虚函数都不能算上。<br><strong>当继承空类时，不加上空类的大小，而是只算本身子类的大小。</strong></p><h3 id="实例-注：笔者是在64位操作系统下操作得出的结果"><a class="header-anchor" href="#实例-注：笔者是在64位操作系统下操作得出的结果">¶</a>实例（注：笔者是在64位操作系统下操作得出的结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">class cBase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;; //标识存在为1</span><br><span class="line">class cBase1</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char p;</span><br><span class="line">&#125;;//内存对齐，4个字节和1个字节，1字节按4字节算</span><br><span class="line">class cBase2</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">      cBase2();</span><br><span class="line">      virtual ~cBase2();//virtual开辟一块指针，因此为8</span><br><span class="line">  private:</span><br><span class="line">     int a;//4，因内存对齐则为8</span><br><span class="line">    char *p;//8</span><br><span class="line">&#125;;</span><br><span class="line">class c:public cBase</span><br><span class="line">&#123;</span><br><span class="line">   virtual void fun() = 0;//纯虚函数</span><br><span class="line">&#125;;</span><br><span class="line">class b&#123;&#125;;</span><br><span class="line">class d:public b,public c&#123;&#125;;//共享虚函数的指针</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;cBase类的大小:&quot; &lt;&lt; sizeof(cBase) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;cBase1类的大小:&quot; &lt;&lt; sizeof(cBase1) &lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt; &quot;cBase2类的大小:&quot; &lt;&lt; sizeof(cBase2) &lt;&lt; endl; </span><br><span class="line">    cout&lt;&lt; &quot;c类的大小:&quot; &lt;&lt; sizeof(c) &lt;&lt;endl; </span><br><span class="line">    cout &lt;&lt; &quot;d类的大小:&quot; &lt;&lt; sizeof(d) &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><br>cBase类的大小：1<br><br>cBase1类的大小：8<br><br>cBase2类的大小：24<br><br>c类的大小：8<br><br>d类的大小：8<br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;*** 类所占内存的大小是有成员变量（静态变量除外）决定的，成员函数是不计算在内的，他们只是名义上在类里，其实同一个类的多个对象共享函数代码，而我们访问类的成员函数是通过类中的自引用指针实现的，所以我们访问成员函数是间接获得地址的。 ***&lt;/p&gt;
&lt;h3 id=&quot;空类&quot;&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>线程同步机制之互斥锁和条件变量</title>
    <link href="http://zy943453722.ink/post/457105b7.html"/>
    <id>http://zy943453722.ink/post/457105b7.html</id>
    <published>2017-10-12T21:24:15.000Z</published>
    <updated>2019-01-02T01:58:41.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程同步"><a class="header-anchor" href="#线程同步">¶</a>线程同步</h2><p><strong>Pthread是POSIX threads 的简称，是POSIX的线程标准。</strong><br>Pthread线程同步指多个线程协调地，有序地同步使用共享资源。多线程共享进程资源，一个线程访问共享资源需要一段完整的时间才能完成其读写操作，如果在这段时间被其他线程打断，就会产生诸多不可预知的错误。</p><h2 id="互斥锁"><a class="header-anchor" href="#互斥锁">¶</a>互斥锁</h2><h3 id="1-互斥量："><a class="header-anchor" href="#1-互斥量：">¶</a>1.互斥量：</h3><p>互斥量是一种线程同步对象，“互斥”的含义是同一时刻只能有一个线程获得互斥量。一个互斥量对应一个共享资源，互斥量状态：<strong><em>1.解锁状态意味着共享资源可用，2.加锁状态意味着共享资源不可用。</em></strong></p><p>一个线程需要使用共享资源时，使用thread_mutex_lock申请：1.当互斥量为解锁状态，则占用互斥量，并给互斥量加锁，占用资源（互斥量为加锁状态，其他线程不能使用互斥量并等待互斥量变为解锁状态），2.如果互斥量为加锁状态，则线程等待，直到互斥量为解锁状态（其他线程使用完共享资源后会解锁互斥量，释放资源）。</p><h3 id="2-临界区："><a class="header-anchor" href="#2-临界区：">¶</a>2.临界区：</h3><p>临界区指的是一个访问共用资源的程序片断。通常由定义一个互斥量并加锁来保护这段临界区代码。</p><h3 id="3-互斥量的相关函数："><a class="header-anchor" href="#3-互斥量的相关函数：">¶</a>3.互斥量的相关函数：</h3><p><strong><em>首先定义互斥量的结构体pthread_mutex_t。</em></strong></p><p><strong>1). 互斥量初始化函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr)</span><br></pre></td></tr></table></figure><p>第一个参数即互斥量结构体的指针，第二个变量则是互斥量的属性（当为NULL时是默认属性）。成功返回0，失败返回错误码。</p><p><strong>2). 互斥量上锁函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex)</span><br></pre></td></tr></table></figure><p>此函数参数即互斥量结构体，返回成功为0，失败返回错误码。<br>是阻塞的上锁函数。</p><p><strong>3). 互斥量解锁函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex)</span><br></pre></td></tr></table></figure><p>参数和返回值同上锁函数。</p><p><strong>4). 互斥量的另一种上锁函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex)</span><br></pre></td></tr></table></figure><p>这是上锁函数的非阻塞版本。若已经上锁，返回EBUSY。</p><p><strong>5). 互斥量的销毁函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex)</span><br></pre></td></tr></table></figure><p>参数和返回值同上锁函数。</p><h2 id="条件变量"><a class="header-anchor" href="#条件变量">¶</a>条件变量</h2><h3 id="1-概念"><a class="header-anchor" href="#1-概念">¶</a>1.概念</h3><p>条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。</p><h3 id="2-条件变量的相关函数"><a class="header-anchor" href="#2-条件变量的相关函数">¶</a>2.条件变量的相关函数</h3><p><strong><em>首先定义条件变量结构体pthread_cond_t</em></strong></p><p><strong>1). 条件变量初始化函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr)</span><br></pre></td></tr></table></figure><p>第一个参数即条件变量结构体指针，第二个变量即条件变量的属性（如果为NULL，则是默认属性）。成功返回0，失败返回错误码。</p><p><strong>2).条件变量的销毁函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_cond_destroy(pthread_cond_t *cond)</span><br></pre></td></tr></table></figure><p>第一个参数即条件变量结构体指针。返回值同初始化函数。</p><p><strong>3). 条件变量的广播函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_cond_broadcast(pthread_cond_t *cond)</span><br></pre></td></tr></table></figure><p>参数和返回值同销毁函数。<br>此函数以广播的方式唤醒所有等待目标条件变量的线程。</p><p><strong>4). 条件变量的信号函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_cond_signal(pthread_cond_t *cond)</span><br></pre></td></tr></table></figure><p>参数返回值同销毁函数<br>此函数用于唤醒一个等待目标变量的线程。至于哪个线程被唤醒，则取决于线程的优先级和调度策略。</p><p><strong>5). 条件变量的等待函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *cond)</span><br></pre></td></tr></table></figure><p>参数和返回值同销毁函数。<br><strong>在调用此函数之前必须保证互斥量已经加锁。</strong></p><p><font color="blue"> <strong>重点：模拟等待函数（pthread_cond_wait)调用前后的过程</strong></font></p><p>第一个线程首先调用：<br>pthread_mutex_lock(&amp;mymutex);</p><p>然后，它检查了列表。没有找到感兴趣的东西，于是它调用：<br>pthread_cond_wait(&amp;mycond, &amp;mymutex);</p><p>然后，pthread_cond_wait() 调用在返回前执行许多操作：<br>pthread_mutex_unlock(&amp;mymutex);</p><p>它对 mymutex 解锁，然后进入睡眠状态，等待 mycond 以接收 POSIX 线程“信号”。一旦接收到“信号”（加引号是因为我们并不是在讨论传统的 UNIX 信号，而是来自 pthread_cond_signal() 或 pthread_cond_broadcast() 调用的信号），它就会苏醒。但 pthread_cond_wait() 没有立即返回——它还要做一件事：重新锁定 mutex：<br>pthread_mutex_lock(&amp;mymutex);</p><p>pthread_cond_wait() 知道我们在查找 mymutex “背后”的变化，因此它继续操作，为我们锁定互斥对象，然后才返回。</p><h3 id="3-代码示例-互斥锁和条件变量一起用实现线程同步"><a class="header-anchor" href="#3-代码示例-互斥锁和条件变量一起用实现线程同步">¶</a>3.代码示例（互斥锁和条件变量一起用实现线程同步）</h3><ul><li><strong>程序思路：</strong><br>在这里利用多线程技术实现生产者和消费者问题，生产者线程向一缓冲区中写数据，消费<br>者线程从缓冲区中读取数据，由于生产者线程和消费者线程共享同一缓冲区，为了正确读<br>写数据，在使用缓冲队列时必须保持互斥。生产者线程和消费者线程必须满足：生产者写<br>入缓冲区的数目不能超过缓冲区容量，消费者读取的数目不能超过生产者写入的数目。<br>在程序中使用了一个小技巧来判断缓冲区是空还是满。在初始化时读指针和写指针为0;<br>如果读指针等于写指针,则缓冲区是空的;如果(写指针+ 1) % N 等于读指针,则缓冲区是满的,<br>%表示取余数,这时实际上有一个单元空出未用。下面是完整的程序段和注释。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt; </span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#define BUFFER_SIZE 8 </span><br><span class="line">#define OVER (-1)</span><br><span class="line">#if 0</span><br><span class="line"></span><br><span class="line">//互斥量和条件变量综合的结构体</span><br><span class="line">struct prodcons &#123;</span><br><span class="line">    int buffer[BUFFER_SIZE]; </span><br><span class="line">    pthread_mutex_t lock;      //互斥LOCK</span><br><span class="line">    int readpos , writepos;    //定义写和读的位置</span><br><span class="line">    pthread_cond_t notempty;   //缓冲区非空条件判断</span><br><span class="line">    pthread_cond_t notfull;    //缓冲区未满条件判断</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//获取时间的函数</span><br><span class="line">char * get_time(void)&#123;</span><br><span class="line">    time_t rawtime;</span><br><span class="line">    struct tm * timeinfo;</span><br><span class="line">    time(&amp;rawtime);</span><br><span class="line">    return asctime(localtime(&amp;rawtime));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对结构体初始化函数</span><br><span class="line">void init(struct prodcons * b)&#123;</span><br><span class="line">    pthread_mutex_init(&amp;b-&gt;lock,NULL);</span><br><span class="line">    pthread_cond_init(&amp;b-&gt;notempty,NULL);</span><br><span class="line">    pthread_cond_init(&amp;b-&gt;notfull,NULL);</span><br><span class="line"></span><br><span class="line">    b-&gt;readpos=0;</span><br><span class="line">    b-&gt;writepos=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//放数据的函数</span><br><span class="line">void put(struct prodcons* b,int data)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;b-&gt;lock);</span><br><span class="line">    if((b-&gt;writepos + 1) % BUFFER_SIZE == b-&gt;readpos)//这是缓冲区满了的情况，留一个空用于发送-1这个信号</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_wait(&amp;b-&gt;notfull, &amp;b-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">//    pthread_mutex_lock(&amp;b-&gt;lock);</span><br><span class="line">//    大家仔细理解互斥锁的位置，以及pthread_cond_wait函数的内核实现（解锁，休眠让出cpu，条件满足后被内核唤醒，上锁，形成临界区，保护资源）</span><br><span class="line">    b-&gt;buffer[b-&gt;writepos]=data;</span><br><span class="line">    b-&gt;writepos++;</span><br><span class="line">    if(b-&gt;writepos &gt;= BUFFER_SIZE)</span><br><span class="line">        b-&gt;writepos=0;</span><br><span class="line">    printf(&quot;put %d at %s \n&quot;, data, get_time());</span><br><span class="line">    pthread_mutex_unlock(&amp;b-&gt;lock);</span><br><span class="line">    pthread_cond_signal(&amp;b-&gt;notempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取数据的函数</span><br><span class="line">int get(struct prodcons *b)&#123;</span><br><span class="line">    int data;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;b-&gt;lock);</span><br><span class="line">    if(b-&gt;writepos == b-&gt;readpos)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;0 == 0\n&quot;);</span><br><span class="line">        pthread_cond_wait(&amp;b-&gt;notempty, &amp;b-&gt;lock);</span><br><span class="line">        printf(&quot;start read \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    data = b-&gt;buffer[b-&gt;readpos];</span><br><span class="line">    b-&gt;readpos++;</span><br><span class="line">    if(b-&gt;readpos &gt;= BUFFER_SIZE)</span><br><span class="line">        b-&gt;readpos=0;</span><br><span class="line">    printf(&quot;get the data is : %d\n&quot;, data);</span><br><span class="line">    pthread_cond_signal(&amp;b-&gt;notfull);</span><br><span class="line">    pthread_mutex_unlock(&amp;b-&gt;lock);</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义全局结构体对象</span><br><span class="line">struct prodcons buffer;</span><br><span class="line"></span><br><span class="line">//生产者回调函数</span><br><span class="line">void *producer(void *data)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    </span><br><span class="line">    for(n = 0; n &lt; 10; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;before produce %d \n&quot;, n) ;</span><br><span class="line">        put(&amp;buffer, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    put(&amp;buffer, OVER);//发信号说-1已经放进去了，说明没内容写了</span><br><span class="line">    </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//消费者回调函数</span><br><span class="line">void *consumer(void * data)</span><br><span class="line">&#123;</span><br><span class="line">    int d;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        d = get(&amp;buffer);</span><br><span class="line">        if(d == OVER)//说明生产者已经写完</span><br><span class="line">            break;</span><br><span class="line">        printf(&quot;consumerd the num is %d\n&quot;, d);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主函数</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t th_a, th_b;</span><br><span class="line">    pthread_attr_t attr;</span><br><span class="line">    void *retval;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    init(&amp;buffer);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">//    pthread_create(&amp;th_b, &amp;attr, consumer, 0);</span><br><span class="line">    pthread_create(&amp;th_b, NULL, consumer, 0);</span><br><span class="line">    sleep(3);</span><br><span class="line">    pthread_create(&amp;th_a, NULL, producer, 0);</span><br><span class="line">    pthread_join(th_a, &amp;retval);</span><br><span class="line">    pthread_join(th_b, &amp;retval);</span><br><span class="line">    sleep(100);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/post/1.png" alt="图1"><br><img src="/post/2.png" alt="图2"><br>由图中可以看出，当条件变量不空不满足条件时，调用了等待函数使得此线程睡眠，让出cpu，进行其他操作，但是当条件满足时并不是直接回到原线程进行到的地方，而是重新加锁，在读。</p><p>参考资料：</p><p><a href="http://blog.csdn.net/shanshanpt/article/details/" target="_blank" rel="noopener">http://blog.csdn.net/shanshanpt/article/details/</a><br><a href="http://blog.csdn.net/lovecodeless/article/details/24885127" target="_blank" rel="noopener">http://blog.csdn.net/lovecodeless/article/details/24885127</a><br><a href="http://blog.sina.com.cn/s/blog_590be5290100ikh5.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_590be5290100ikh5.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程同步&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线程同步&quot;&gt;¶&lt;/a&gt;线程同步&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Pthread是POSIX threads 的简称，是POSIX的线程标准。&lt;/strong&gt;&lt;br&gt;
Pthread线程同
      
    
    </summary>
    
      <category term="技术" scheme="http://zy943453722.ink/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
      <category term="linux网络编程" scheme="http://zy943453722.ink/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅析多线程并发及写微信红包遇到的问题</title>
    <link href="http://zy943453722.ink/post/966f045a.html"/>
    <id>http://zy943453722.ink/post/966f045a.html</id>
    <published>2017-09-24T22:35:11.000Z</published>
    <updated>2019-01-02T01:58:41.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程并发"><a class="header-anchor" href="#多线程并发">¶</a>多线程并发</h2><p>众所周知，多线程编程很容易遇上诸如丢失更新、脏读、死锁等烦人的线程冲突问题。多线程的问题一旦发生便很难定位和解决，所以要在编程的初始阶段就要注意避免多线程程序常见的错误。</p><p>微信红包程序应用线程基础API，采用多线程并发的方式进行抢红包操作。</p><p>多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。</p><h2 id="微信红包程序"><a class="header-anchor" href="#微信红包程序">¶</a>微信红包程序</h2><p><strong>思路：</strong></p><ol><li>创建抢红包人员的结构体，分别给定名字，所抢金额，以及是否已抢过字段。</li><li>创建生产者线程，用于产生红包，红包金额和红包数目从标注输入读入，并对生产者回调函数进行加锁操作。</li><li>创建多个消费者线程，用于多人抢红包操作，其中消费者回调函数进行红包的随机分配算法，并进行加锁操作。</li></ol><p><strong><em>下面是部分代码示例：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"> /*结构体部分*/</span><br><span class="line">  typedef struct person</span><br><span class="line">  &#123;</span><br><span class="line">      int id;</span><br><span class="line">      char name[20];</span><br><span class="line">      int flag;</span><br><span class="line">       int money;</span><br><span class="line">   &#125;Person;</span><br><span class="line"></span><br><span class="line">/* 生产者回调函数*/</span><br><span class="line">   void *producer(void* value)//生产者只负责产生红包金  额和红包个数</span><br><span class="line">   &#123;</span><br><span class="line">      double n = *(double*)value;</span><br><span class="line">       pthread_mutex_lock(&amp;lock);</span><br><span class="line">       money = n;</span><br><span class="line">       pthread_mutex_unlock(&amp;lock);</span><br><span class="line">       pthread_exit(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/*消费者回调函数*/</span><br><span class="line">  void *consumer(void *n)//消费者用于随机获取红包个数</span><br><span class="line">  &#123;</span><br><span class="line">      int nn = *(int*)n;</span><br><span class="line">      pthread_mutex_lock(&amp;lock);</span><br><span class="line">      printf(&quot;number%d\n&quot;,nn);</span><br><span class="line">      if(money &gt; 0 &amp;&amp; per[nn].flag == 0)//还没抢过</span><br><span class="line">      &#123;</span><br><span class="line">         if(num &gt; 1)</span><br><span class="line">         &#123;</span><br><span class="line">            srand((unsigned)time(NULL));//初始化随机数种子       </span><br><span class="line">            double avg = money / num;//获取平均值</span><br><span class="line">            double t = avg*2;</span><br><span class="line">            double randmoney = (rand()%(int)(t*100) + (int)MIN*100)/100.00 + MIN;//初始化随机数</span><br><span class="line">            money-=randmoney;</span><br><span class="line">            printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,randmoney);</span><br><span class="line">            printf(&quot;剩余%.2lf元\n&quot;,money);</span><br><span class="line">            per[nn].id = nn;</span><br><span class="line">            per[nn].money = randmoney;</span><br><span class="line">            per[nn].flag = 1;</span><br><span class="line">            num--;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,money);</span><br><span class="line">               printf(&quot;剩余0元\n&quot;);</span><br><span class="line">               money = 0;</span><br><span class="line">               per[nn].id = nn;</span><br><span class="line">               per[nn].money = money;</span><br><span class="line">               per[nn].flag = 1;</span><br><span class="line">               num--;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       pthread_mutex_unlock(&amp;lock);</span><br><span class="line">       pthread_cancel(pthread_self());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">/*主函数中主要线程API使用部分*/</span><br><span class="line"></span><br><span class="line">    pthread_t th_a,th_b[Total];</span><br><span class="line">     pthread_mutex_init(&amp;lock,0);</span><br><span class="line">     pthread_create(&amp;th_a,NULL,producer,(void*)&amp;value);</span><br><span class="line">     pthread_join(th_a,NULL);</span><br><span class="line">     int args[Total];</span><br><span class="line">     for(i = 0; i &lt; Total;i++)</span><br><span class="line">     &#123; </span><br><span class="line">         args[i] = i;</span><br><span class="line">         if(per[i].flag == 0)</span><br><span class="line">         &#123;</span><br><span class="line">             pthread_create(&amp;th_b[i],NULL,consumer,(void*)&amp;args[i]);</span><br><span class="line">             // usleep(100);</span><br><span class="line">             printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     for(i = 0; i &lt; Total; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         pthread_join(th_b[i],NULL);</span><br><span class="line">     &#125;</span><br><span class="line">     pthread_mutex_destroy(&amp;lock);</span><br><span class="line"></span><br><span class="line">/* 全局变量声明*/</span><br><span class="line">     #define Total 20//线程个数</span><br><span class="line">     Person per[Total];</span><br><span class="line">     double money = 0.0;//初始金额</span><br><span class="line">     int num = 0;//初始红包个数</span><br><span class="line">     pthread_mutex_t lock;//创建锁</span><br></pre></td></tr></table></figure><p><strong><em>这是笔者在经过对线程的更深入理解后写好的版本。</em></strong></p><p>在最初的版本中，代码的<strong>69行</strong>的最后一个参数传的是(void*)&amp;i,但程序运行后时而成功时而失败，失败时如下图：</p><p><img src="/post/3.png" alt="图1"></p><p><img src="/post/4.png" alt="图2"></p><p><strong><em>由运行结果可以看出20个线程全部都已创建出，但是却出现了红包抢不完的情况，而且观察发现，抢红包的顺序是乱序，且出现了同一个number的线程抢了好几次红包。</em></strong></p><h3 id="因此总结为以下几个问题被给出解答："><a class="header-anchor" href="#因此总结为以下几个问题被给出解答：">¶</a>因此总结为以下几个问题被给出解答：</h3><p>** 1. 为什么创建线程是for循环控制，而抢红包是乱序？**</p><p><strong><em>答：</em></strong><br><font color="red"><br>这是因为存在资源抢占现象，创建线程的顺序是有for循环控制的，但创建好线程之后，谁先调用回调函数顺序是不定的，谁的抢到cpu资源，谁就先进入回调函数，谁就先抢红包。<br></font></p><p>** 2. 为什么看似是同一个线程抢了多次红包？**</p><p><strong><em>答：</em></strong><br><font color="blue"><br>这是因为i++操作是三条指令，分别是找到i将其放入寄存器，而后+1，最后回赋。而在运行结果中出现多次number7的情况却并不是同一个线程抢红包多次。<strong>因为可能有某几个线程在执行回调函数时，i的值还没有进行回赋操作，就被剥夺了cpu，而pthread_create函数最后一个参数原本传的是i的地址，即从地址中取i的值，但此时i还是原来的值。</strong> 因此看似是同一个线程抢了多次红包，实则不同线程执行同一个i的回调函数。<br></font></p><p>** 3. 为什么经过修改用数组存i值可以，但最初版本用i时不可以？**</p><p><strong><em>答：</em></strong><br><font color="green"><br>这是因为pthread_create函数最后一个参数存的是地址。</font></p><p>当存的是i的地址时，即i变一次，地址中的内容变一次，当创建出线程而不是立即调用回调函数，而是被剥夺cpu资源时，i值就随for循环变化而变化，因此当回调函数有了cpu资源后，i的地址中存的就不是当时地址中的内容了。</p><p>当用数组存i值时，数组共有Total个地址，创建线程时，当对应的i存到对应的地址，某个数组下表元素的地址只存其当时的值，因此即使不立即调用回调函数，之后拿到的也是当时参数地址中的值，这个值未发生变化。<br></p><p>** 4. 为什么67行有flag控制，而同一个i还能进去呢？**</p><p><strong><em>答：</em></strong><br><font color="yellow"><br>**这个if判断由外部for循环控制，for循环是满足条件后进入，结束一次循环后i++，因此每次进入if后的i值都不同，至于说number7打印好多次，好像线程也创建了多次是错误的，是回调函数导致此原因，同问题2，在此就不赘述。<br></font></p><p>** 5. 为什么在for循环中加上sleep类的函数就可以正确抢红包，但是是顺序抢？**</p><p><strong><em>答：</em></strong><br><font color="cyan"><br>这是因为usleep函数和sleep函数的作用是挂起当前线程，即挂起当前运行的主线程。在线程创建之后，即挂起主线程，只能进入子线程调用回调函数，回调函数又加了互斥锁，因此直到解锁才能释放cpu资源，即抢红包过程是顺序的。<br></font></p><p><strong>6.为什么在number8后会出现number7？（即为什么8号线程后才出现7号线程？</strong></p><p><strong><em>答：</em></strong><br>这其实还是存在资源抢占问题，7线程创建后，没进入回调函数就被其他线程剥夺了cpu，因此当轮到其执行回调函数时，已经过去了很久。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多线程并发&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#多线程并发&quot;&gt;¶&lt;/a&gt;多线程并发&lt;/h2&gt;
&lt;p&gt;众所周知，多线程编程很容易遇上诸如丢失更新、脏读、死锁等烦人的线程冲突问题。多线程的问题一旦发生便很难定位和解决，所以要在编程的初始阶
      
    
    </summary>
    
      <category term="网络编程" scheme="http://zy943453722.ink/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
      <category term="多线程，linux网络编程" scheme="http://zy943453722.ink/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8Clinux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅析select函数及FD宏</title>
    <link href="http://zy943453722.ink/post/606db69c.html"/>
    <id>http://zy943453722.ink/post/606db69c.html</id>
    <published>2017-09-19T23:13:33.000Z</published>
    <updated>2019-01-02T01:58:41.880Z</updated>
    
    <content type="html"><![CDATA[<h1>select函数</h1><p><strong>这个函数允许进程指示内核等待多个事件中的任一个发生，并仅在一个或者多个事件发生或经过某指定时间后才唤醒进程。</strong></p><h3 id="函数原型："><a class="header-anchor" href="#函数原型：">¶</a>函数原型：###</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/select.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);</span><br><span class="line">     返回：准备好的描述字正数目，0表示超时，-1表示出错</span><br></pre></td></tr></table></figure><h3 id="函数参数解析："><a class="header-anchor" href="#函数参数解析：">¶</a>函数参数解析：</h3><ol><li>参数maxfdp1指定被测试的描述字数目，即经过FD_SET之后，所关心的描述符的个数，（因为从0开始，因此一般这个值是测试描述符集下标最大值+1）并通知内核。</li><li>中间三个参数readset，writeset，exceptset指定我们要让内核测试读、写、异常条件所需的描述字。也就是说，对于readset，<strong>我们关心是否可以从这些文件中读取数据了</strong>，对于writeset，<strong>我们关心是否可以向这些文件中写入数据了</strong>，对于exceptset，<strong>我们关心这些文件是否发生异常</strong>。</li><li>参数timeout，它告诉内核等待一组指定的描述字中的任意一个准备好可花多长时间，结构timeval指定了秒数和微秒数成员：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct timeval</span><br><span class="line">&#123;</span><br><span class="line">long tv-sec;//秒</span><br><span class="line">long tv-usec;//微秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>有三种可能：</em></strong></p><ol><li><p>、永远等待下去：仅在有一个描述符准备好I/O时才返回，要设置timeout为NULL。</p></li><li><p>、等待固定时间：在有一个描述符准备好I/O时返回，但不超过timeout参数指定的秒数和微秒数。</p></li><li><p>、根本不等待：检查描述字后立即返回，这称为轮询(polling),参数timeout要指向某一个timeval结构，且其中的秒数和微秒数要置0。</p></li></ol><p><strong>前两种是阻塞的，最后一种是不阻塞的</strong></p><h2 id="fdset结构体解析"><a class="header-anchor" href="#fdset结构体解析">¶</a>fdset结构体解析:</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;typesizes.h&gt;</span><br><span class="line">#define __FD_SETSIZE 1024</span><br><span class="line"></span><br><span class="line">#include&lt;sys/select.h&gt;</span><br><span class="line">#define FD_SETSIZE __FD_SETSIZE</span><br><span class="line">typedef long int __fd_mask;//64位系统上大小为8</span><br><span class="line">#undef __NFDBITS</span><br><span class="line">#define __NFDBITS (8*(int) sizeof(__fd_mask))  // 8*8 = 64</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">#ifdef __USE_XOPEN</span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];//数组长度为1024/64 = 16</span><br><span class="line"> #define __FDS_BITS(set) ((set)-&gt;fds_bits)</span><br><span class="line"> #else</span><br><span class="line">    __fd_mask __fds_bits[____FD_SETSIZE / __NFDBITS];</span><br><span class="line"> #define __FDS_BITS(set) ((set)-&gt;fds_bits)</span><br><span class="line"> #endif</span><br><span class="line"> &#125;fd_set</span><br></pre></td></tr></table></figure><p><em><em>因此fd_set结构体中仅包含一个整型数组，该数组的每个元素的每一位都会标记一个文件描述符。因此16个long int元素就是 16</em>8</em>8 = 1024位 ，最多容纳1024个文件描述符！！**</p><h1>select中FD相关的4个宏</h1><ol><li>void FD_ZERO(fd_set *fdset);//使fd_set结构体中的整型数组清零</li><li>void  FD_SET(int fd,fd_set *fdset); //设置感兴趣的文件描述符</li><li>void FD_CLR（int fd,fd_set *fdset);//关闭感兴趣的文件描述符</li><li>int FD_ISSET(int fd, fd_set *fdset); //用于判断某个文件描述符是否就绪，且在感兴趣的描述符集合中</li></ol><h1>对于几个宏和select的理解</h1><ul><li>fd_set是创建文件描述符集合</li><li>FD_SET是设置感兴趣的文件描述符放入描述符集合中，将对应位置为1，但是此文件描述符可能准备好了，也可能没有准备好，可以说是一类文件描述符。</li><li>select是监听这几个文件描述符看哪几个就绪了，就返回个数，没就绪的再次置回0，就绪的保留1。</li><li>FD_ISSET是真正查看哪个指定的文件描述符是否就绪，就绪就为1，未就绪就为0。</li></ul><p><strong><em>example：</em></strong></p><p>为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。<br>　　<br>（1）执行fd_set set; FD_ZERO(&amp;set);则set用位表示是0000,0000。</p><p>（2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)</p><p>（3）若再加入fd＝2，fd=1,则set变为0001,0011</p><p>（4）执行select(6,&amp;set,0,0,0)阻塞等待</p><p>（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p><p>（6）此时FD_ISSET(1,&amp;set)返回1，而FD_ISSET(5,&amp;set)返回0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;select函数&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;这个函数允许进程指示内核等待多个事件中的任一个发生，并仅在一个或者多个事件发生或经过某指定时间后才唤醒进程。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数原型：&quot;&gt;&lt;a class=&quot;header-anchor&quot; hre
      
    
    </summary>
    
      <category term="技术" scheme="http://zy943453722.ink/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程，c" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%8Cc/"/>
    
  </entry>
  
  <entry>
    <title>c++重载覆盖隐藏的区别和执行方式</title>
    <link href="http://zy943453722.ink/post/bdc66b1.html"/>
    <id>http://zy943453722.ink/post/bdc66b1.html</id>
    <published>2017-09-14T22:53:03.000Z</published>
    <updated>2019-01-02T01:58:41.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="成员函数被重载-overload-的特征"><a class="header-anchor" href="#成员函数被重载-overload-的特征">¶</a>成员函数被重载（overload）的特征</h2><ul><li>相同的范围（在同一个类中）</li><li>函数名字相同</li><li>参数不同</li><li>virtual关键字可有可无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">  private: </span><br><span class="line">     int a</span><br><span class="line">  public：</span><br><span class="line">      void print();</span><br><span class="line">      void print(int aa);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="覆盖-override-的特征"><a class="header-anchor" href="#覆盖-override-的特征">¶</a>覆盖（override）的特征</h2><ul><li>不同的范围（分别于派生类和基类）</li><li>函数名字相同</li><li>参数相同</li><li>基类函数必须有virtual关键字</li></ul><p><strong><em>覆盖是指派生类函数覆盖基类函数</em></strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual void print();</span><br><span class="line"> &#125;;</span><br><span class="line"> class B:public A</span><br><span class="line"> &#123;</span><br><span class="line">    public:</span><br><span class="line">      void print();</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="隐藏-redefining-的规则"><a class="header-anchor" href="#隐藏-redefining-的规则">¶</a>隐藏（redefining）的规则</h2><ul><li>派生类函数与基类函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数都会被隐藏。</li><li>若派生类函数与基类函数同名且参数相同，但是基类函数没有virtual，基类的函数会被隐藏。</li></ul><p><strong><em>隐藏是指派生类的函数屏蔽了与其同名的基类函数。</em></strong></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">  void print();</span><br><span class="line"> &#125;;</span><br><span class="line"> class B:public A&#123;</span><br><span class="line"> private:</span><br><span class="line">  int a;</span><br><span class="line"> public:</span><br><span class="line">   void print(int aa);</span><br><span class="line">   &#125;;</span><br><span class="line">   -----------------------------------------------------</span><br><span class="line">   class A&#123;</span><br><span class="line">   public:</span><br><span class="line">     void print();</span><br><span class="line">  &#125;;</span><br><span class="line">  class B:public A&#123;</span><br><span class="line">  public:</span><br><span class="line">    void print();</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><pre><code>  ## 3种情况怎么执行  1. 重载：看参数  2. 隐藏：看指针类型  3. 覆盖：看实体对象类型</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;成员函数被重载-overload-的特征&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#成员函数被重载-overload-的特征&quot;&gt;¶&lt;/a&gt;成员函数被重载（overload）的特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;相同的范围（在同一个类中）&lt;/l
      
    
    </summary>
    
      <category term="技术" scheme="http://zy943453722.ink/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
</feed>
