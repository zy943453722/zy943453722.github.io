<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悲伤逆流</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zy943453722.ink/"/>
  <updated>2018-01-30T07:59:07.730Z</updated>
  <id>http://zy943453722.ink/</id>
  
  <author>
    <name>张越</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcp可靠传输和流量控制的4种协议的演变史</title>
    <link href="http://zy943453722.ink/tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%844%E7%A7%8D%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2/"/>
    <id>http://zy943453722.ink/tcp可靠传输和流量控制的4种协议的演变史/</id>
    <published>2018-01-30T09:35:04.000Z</published>
    <updated>2018-01-30T07:59:07.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><em>学习了计算机网络之后，发现很多基础知识其中的奥秘是经过前人一步步探索得来的，故而搜索了很多的资料，在这里用几篇博文进行总结。</em></strong><br><br><strong><font color="blue">首先要说到的就是tcp可靠传输和流量控制的4种协议，这4种协议从无到有，从最初的单工停等协议(停止等待ARQ协议)到连续ARQ协议、选择重传ARQ协议，直到最终的滑动窗口协议，经过了一系列的演变过程。本博文就来浅析一下它们的区别和演变过程。</font></strong></p><h2 id="单工停等协议"><a href="#单工停等协议" class="headerlink" title="单工停等协议"></a>单工停等协议</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><em>即发送方每次发送完一个分组(此处可能是tcp报文也可能是MAC帧)就停止发送，等待接收方的确认，只有在收到确认之后才能够再发送下一个分组。</em></strong></p><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h3><p><strong><em><font size="3">工作原理:</font></em></strong></p><ol><li>发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。(利用超时计时器计时)</li><li>在等待过程中，发送点停止发送新的数据包。</li><li>当数据包没有成功被接收点接收时候，接收点不会发送ACK.这样发送点在等待一定时间后，重新发送数据包。</li><li>反复以上步骤直到收到从接收点发送的ACK.</li></ol><p><strong><em><font size="3">原理图如下:</font><br></em></strong><br><img src="/tcp可靠传输和流量控制的4种协议的演变史/1.png" alt="无差错"><br><br>如图1即在无差错的情况下，A发送，B接收，只有A收到B的确认时才可以发送下一个分组。<br><img src="/tcp可靠传输和流量控制的4种协议的演变史/2.png" alt="有差错"><br>如图2即出现差错时利用的一种机制叫做超时重传机制，B没有收到A的报文，A也没收到来自B的确认报文，经过一个设定时间后，超时计时器到期，那么就要重传。<br><img src="/tcp可靠传输和流量控制的4种协议的演变史/3.png" alt="3"><br><br>如图3即当A的发送分组没有差错和丢弃，但是B的确认分组出现差错，那么A收不到确认也就无法判断是确认出错还是发送分组出错,因此B需要丢弃当前接收的分组，等待超时计时器到期A重新发送，而后接收。<br><img src="/tcp可靠传输和流量控制的4种协议的演变史/4.png" alt="4"><br><br>如图4即B的确认没有出错或者丢失，只是因为信道拥塞导致延时到达，因此A无法收到确认y而是需要重新发送之前的发送分组。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>这个协议的缺点是较长的等待时间导致低的数据传输速度。在低速传输时，对连接频道的利用率比较好，但是在高速传输时，频道的利用率会显著下降。</strong></p><h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong><em>为了克服停止等待协议需要长时间等待的缺点，故而出现了连续ARQ协议，它是指发送方维护着一个窗口,这个窗口中不止一个分组,有好几个分组,窗口的大小是由接收方返回的win值决定的,所以窗口的大小是动态变化的,只要在窗口中的分组都可以被发送,这就使得TCP一次不是只发送一个分组了,从而大大提高了信道的利用率.并且它采用<font color="red">累积确认</font>的方式,对于<font color="red">按序</font>到达的最后一个分组发送确认。</em></strong></p><h3 id="具体描述-1"><a href="#具体描述-1" class="headerlink" title="具体描述"></a>具体描述</h3><p><strong><font size="3">原理：</font></strong><br><br><img src="/tcp可靠传输和流量控制的4种协议的演变史/5.png" alt="3"><br><br><br>如图可知发送方维护一个5分组大小的窗口，只有收到接收方的一个确认后才将窗口向前挪动。<br>但是接收方由于<strong>累计确认</strong>方式,虽然一次性仍然只能接收一个确认分组，但是发送方不必等待接收方确认便可以再次发送。因此，接收方可以在收到几个分组之后，对<strong>按序到达</strong>的最后一个分组发送确认，这就表示到这个分组之前的所有分组都正确收到了。<br><strong><br>重传机制：</strong><br><br>采用回退N机制(Go-back-N)即GBN,表示凡是被发送出去尚未被确认的分组都放在发送方提供的较大的缓冲区内，若得到确认则取出。当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧。其中利用超时计时器，若在规定时间内没有收到对应的应答帧，或者累计的应答帧，那么就说明出错了。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>虽然连续ARQ的链路效率大大提升，但是相应的需要更大的缓冲空间，且接收方窗口大小总是1，浪费很多链路的带宽。</p><h2 id="选择重传ARQ协议"><a href="#选择重传ARQ协议" class="headerlink" title="选择重传ARQ协议"></a>选择重传ARQ协议</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>发送方据一个指定大小的窗口持续发送若干分组，即使发送过程中丢失分组，也会继续发送。和Go-back-N ARQ不一样，接收进程在出错后还是继续接收和确认帧。</p><h3 id="具体描述-2"><a href="#具体描述-2" class="headerlink" title="具体描述"></a>具体描述</h3><p><strong><em>基本原理：<br></em></strong><br>如果一个发送的帧没有到达接收方，发送方继续发送后面的帧，直到它填满发送窗口 。接收方持续用接收的帧填充它的接收窗口，并且每次回复一个带有序列号的ACK帧。一旦发送窗口所有帧都发送了 ，发送方重新发送的帧号与ACK不对应的帧，然后继续。<br><img src="/tcp可靠传输和流量控制的4种协议的演变史/6.png" alt="4"><br><br><br>如图可知在2号分组出错时，继续发送其他的分组，接收方同时也接收其他的分组，但是并不提交给上层，只有等待重传的分组到达之后，再按序提交给高层。</p><p><strong>注意：</strong> 接收方窗口大小与发送方要相同，并且最大的窗口值取最大序列号的一半。</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>通信信道的利用率不高，也就是说，信道还远远没有被数据比特填满。</li><li>是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送数据包来纠正错误的方法也严重的影响了它的传输速度。</li></ol><h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>滑动窗口协议实际是选择重传ARQ的特殊情况。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ol><li>TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收)。</li><li>发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li><li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；</li><li>每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><strong>原理图：<br></strong><br><img src="/tcp可靠传输和流量控制的4种协议的演变史/7.png" alt="7"><br><br><br>分析图中可以看出：</p><ol><li>初始时发送窗口前沿是0，后沿也是0，因为前沿是指下一发送的序号，而后沿是指下一应答序号。</li><li>而初始时接收窗口前沿是1，后沿是0，因为前沿和后沿之间的部分是指下一期望接收的序号。</li><li>发送方前沿是发送完一个分组后就移动，后沿是收到接收确认分组之后才移动。</li><li>接收方的前后沿同时移动，当接收到一个分组之后就向后移动。</li></ol><h2 id="4种协议的比较"><a href="#4种协议的比较" class="headerlink" title="4种协议的比较"></a>4种协议的比较</h2><table><thead><tr><th></th><th style="text-align:center">单工停等</th><th style="text-align:center">连续ARQ</th><th style="text-align:center">选择重传ARQ</th><th style="text-align:center">滑动窗口</th></tr></thead><tbody><tr><td>应答帧是否需要编号</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>分组是否按序</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>发送窗口大小</td><td style="text-align:center">1</td><td style="text-align:center">&gt;1</td><td style="text-align:center">&gt;1,最大值为最大确认序列号的一半</td><td style="text-align:center">同选择重传ARQ</td></tr><tr><td>接收窗口大小</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">&gt;1,同发送窗口</td><td style="text-align:center">同选择重传ARQ</td></tr></tbody></table><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="http://blog.csdn.net/guoweimelon/article/details/50879588" target="_blank" rel="external">http://blog.csdn.net/guoweimelon/article/details/50879588</a><br><a href="http://blog.csdn.net/wbw1985/article/details/4879224" target="_blank" rel="external">http://blog.csdn.net/wbw1985/article/details/4879224</a><br><a href="http://pmghong.blog.51cto.com/3221425/1242470" target="_blank" rel="external">http://pmghong.blog.51cto.com/3221425/1242470</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;学习了计算机网络之后，发现很多基础知识其中的奥秘是经过前人一步步探索得来的，故而搜索了很多的资料，在这里用几篇博文进
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://zy943453722.ink/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://zy943453722.ink/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="tcp" scheme="http://zy943453722.ink/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>php中静态类、抽象类和接口类的区别</title>
    <link href="http://zy943453722.ink/php%E4%B8%AD%E9%9D%99%E6%80%81%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://zy943453722.ink/php中静态类、抽象类和接口类的区别/</id>
    <published>2018-01-11T14:30:20.000Z</published>
    <updated>2018-01-12T02:54:31.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>最近笔者学习了php的基本知识，其基本语法像极了c语言，但是取消了指针等特性，且操作起来更加简便。下面就浅析一下php面向对象中的特性：静态类、抽象类和接口以及很好用的代码复用技术trait。</strong></p><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><h3 id="静态类定义："><a href="#静态类定义：" class="headerlink" title="静态类定义："></a>静态类定义：</h3><p>   <strong><em>类中含有static修饰的方法或者属性的类。</em></strong></p><h3 id="静态类的特性和易错点"><a href="#静态类的特性和易错点" class="headerlink" title="静态类的特性和易错点"></a>静态类的特性和易错点</h3><ol><li>静态类中的成员不用实例化对象访问。用类名：：属性名/方法名 访问。</li><li>实例化的对象只能访问静态方法，不可访问静态属性。</li><li>继承时子类可以继承父类的公有和受保护的方法和属性。</li><li>可以说静态方法和属性不属于这个类，所以不能用自引用指针$this去引用，但却可以通过self或者parent访问。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Foo&#123;</div><div class="line">    public $my = &quot;zy&quot;;</div><div class="line">    public static $my_static = &apos;foo&apos;;//初始化附常量</div><div class="line">    public function staticValue()</div><div class="line">    &#123;</div><div class="line">        echo $this-&gt;my;</div><div class="line">        //echo $this-&gt;my_static;这些属性不属于类</div><div class="line">        return self::$my_static;</div><div class="line">    &#125;</div><div class="line">    public static function handle()</div><div class="line">    &#123;</div><div class="line">        //$this-&gt;$my_static;静态方法中没有$this这个伪变量</div><div class="line">        echo &quot;这是静态变量\n&quot;;</div><div class="line">    &#125;</div><div class="line">    protected static function func()</div><div class="line">    &#123;</div><div class="line">       echo &quot;protected static\n&quot;;   </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Bar extends Foo&#123;</div><div class="line">    public function fooStatic()&#123;</div><div class="line">        return parent::$my_static;       </div><div class="line">    &#125;</div><div class="line">    public function funn()</div><div class="line">    &#123;</div><div class="line">        echo self::func().&quot;\n&quot;;//继承了</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">echo Foo::$my_static.&quot;\n&quot;;</div><div class="line">echo Foo::handle().&quot;\n&quot;;</div><div class="line">$foo = new Foo();</div><div class="line">//echo $foo-&gt;$my_static.&quot;\n&quot;;//不可用对象直接访问静态属性</div><div class="line">echo $foo-&gt;handle().&quot;\n&quot;;//用对象可直接访问静态方法</div><div class="line">echo $foo-&gt;staticValue().&quot;\n&quot;;</div><div class="line">echo Bar::$my_static.&quot;\n&quot;;</div><div class="line">$bar = new Bar();</div><div class="line">echo $bar-&gt;fooStatic().&quot;\n&quot;;</div><div class="line">echo $bar-&gt;handle();</div><div class="line">$bar-&gt;funn();</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="抽象类的定义"><a href="#抽象类的定义" class="headerlink" title="抽象类的定义"></a>抽象类的定义</h3><p><strong><em> 被abstract修饰的类。</em></strong></p><h3 id="抽象类的特性和易错点"><a href="#抽象类的特性和易错点" class="headerlink" title="抽象类的特性和易错点"></a>抽象类的特性和易错点</h3><ol><li>抽象类不可被实例化</li><li>任何一个类，若其中至少有一个抽象方法，那么该类就必须定义为抽象类，类中可以有非抽象的方法或属性。</li><li>抽象方法只声明其调用方式，不定义具体功能。</li><li>继承某个抽象类后，其子类必须实现所有的抽象方法，且不论函数名、参数都不能改变，但是继承访问控制可以一致或更宽松。</li><li>若子类继承的父类抽象方法中参数列表是可选参数，那么也可以与父类参数个数不一致，即子类可以有个默认参数列表。</li></ol><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">abstract class AbstractClass&#123;//此类不可实例化对象</div><div class="line">    abstract protected function getValue();</div><div class="line">    abstract protected function prefixValue($prefix);//只声明，不作具体实现</div><div class="line">    abstract public function pre($han);</div><div class="line">    const i = 12;</div><div class="line">    public $a = 13;</div><div class="line">    public function printOut()</div><div class="line">    &#123;</div><div class="line">        echo $this-&gt;a.&quot;\n&quot;;</div><div class="line">        echo $this-&gt;getValue().&quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line">class ConcreteClass1 extends AbstractClass</div><div class="line">&#123;</div><div class="line">    protected function getValue() &#123;</div><div class="line">        return &quot;ConcreteClass1&quot;;//实现具体实现，必须保持一致</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function prefixValue($prefix) &#123;</div><div class="line">        return &quot;$prefix.ConcreteClass1&quot;;</div><div class="line">    &#125;</div><div class="line">    public function pre($han,$ren = &apos;a&apos;)</div><div class="line">    &#123;</div><div class="line">       echo $han.$ren.&quot;\n&quot;;       </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteClass2 extends AbstractClass</div><div class="line">&#123;</div><div class="line">    public function getValue() &#123;</div><div class="line">        return &quot;ConcreteClass2&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function prefixValue($prefix) &#123;</div><div class="line">        return &quot;&#123;$prefix&#125;ConcreteClass2&quot;;</div><div class="line">    &#125;</div><div class="line">    public function pre($han,$ren = &apos;a&apos;)</div><div class="line">    &#123;</div><div class="line">       echo $han.$ren.&quot;\n&quot;;       </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$class1 = new ConcreteClass1;//继承抽象类的类才可以实例化</div><div class="line">$class1-&gt;printOut();</div><div class="line">echo $class1-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;</div><div class="line">$class1-&gt;pre(&quot;zy&quot;);//可以打印出默认的参数</div><div class="line">$class2 = new ConcreteClass2;</div><div class="line">$class2-&gt;printOut();</div><div class="line">echo $class2-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;</div><div class="line">echo AbstractClass::i;//同样可以输出常量，无法输出变量</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p><strong><em> interface修饰的一个特殊的抽象类，但不是类。</em></strong></p><h3 id="接口特性和易错点"><a href="#接口特性和易错点" class="headerlink" title="接口特性和易错点"></a>接口特性和易错点</h3><ol><li>接口定义的所有方法都是空的</li><li>接口中的所有方法都是公有的，这是接口的特性 </li><li>接口的定义使用interface，但是接口的实现就要用到implements,实现接口的实际是类</li><li>接口实现过程中要实现全部定义的接口 </li><li>接口可以继承，用extends实现，与接口的实现不是一个意思,继承之后用类实现时要全部实现</li><li>接口中可以声明常量但是不可声明变量</li><li>可以说接口是特殊的抽象类，他里面的方法也是不实现功能的抽象类但是为了方便，不写abstract还有定义成interface而非类</li><li>一个类虽然是单继承的，但是一个类可以实现多个接口,多个接口之间用逗号隔开</li></ol><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">interface iTemplate</div><div class="line">  &#123;</div><div class="line">      const name = &quot;ha&quot;;</div><div class="line">      public function setVariable($name,$var);//必须是公有的方法</div><div class="line">      public function getHtml($template);</div><div class="line">  &#125;</div><div class="line">  interface inTel&#123;</div><div class="line">    public function handle();   </div><div class="line">  &#125;</div><div class="line">  //一个接口类可以实现多个定义的接口</div><div class="line">  class Template implements iTemplate,inTel&#123;</div><div class="line">      private $vars = array();</div><div class="line">      public function setVariable($name,$var)</div><div class="line">      &#123;</div><div class="line">          $this-&gt;vars[$name] = $var;</div><div class="line">      &#125;</div><div class="line">      public function getHtml($template)</div><div class="line">      &#123;</div><div class="line">          foreach($this-&gt;vars as $name =&gt; $value)</div><div class="line">          &#123;</div><div class="line">              $template = str_replace($name,$value,$template);//把字符串template中的name字符换成value</div><div class="line">          &#125;</div><div class="line">          return $template;</div><div class="line">      &#125;</div><div class="line">      public function handle()</div><div class="line">      &#123;</div><div class="line">          echo &quot;handle things\n&quot;;</div><div class="line">      &#125;</div><div class="line">  &#125;//用一个类去实现接口  </div><div class="line">    //$te = new iTemplate();因为是一种特殊的抽象类，因此也是不能实例化对象的</div><div class="line">    $tel = new Template();</div><div class="line">    $tel-&gt;setVariable(&apos;zy&apos;,&apos;人才&apos;);</div><div class="line">    echo $tel-&gt;getHtml(&apos;zyzsddw&apos;).&quot;\n&quot;;</div><div class="line">    $tel-&gt;handle();</div><div class="line">    echo iTemplate::name;//输出接口中定义的常量</div><div class="line">  ?&gt;</div></pre></td></tr></table></figure><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><h3 id="trait的定义"><a href="#trait的定义" class="headerlink" title="trait的定义"></a>trait的定义</h3><p><strong><em>Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制</em></strong></p><h3 id="trait的特性和易错点"><a href="#trait的特性和易错点" class="headerlink" title="trait的特性和易错点"></a>trait的特性和易错点</h3><ol><li>trait是一种代码复用技术，相当于一种池技术，把好多功能(方法)写在其中，用的时候调用即可。可代替继承技术</li><li>他的调用优先级高于继承后的同名方法的优先级</li><li>它本身无法进行实例化</li><li>可以同时有多个trait，类中use声明时用逗号隔开</li><li>trait也可以使用多个trait作为成员</li><li>不可以声明静态成员，可在方法中定义静态变量</li></ol><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Base&#123;</div><div class="line">    public function sayHello()&#123;</div><div class="line">        echo &apos;hello&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">trait mysay&#123;</div><div class="line">    public function mysays()</div><div class="line">    &#123;</div><div class="line">        echo &quot;this is my says\n&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">trait SayWorld&#123;//声明方式相当于一个类</div><div class="line">    //static public $c = 1;除非定义在方法中</div><div class="line">    public $name = &quot;zy&quot;;</div><div class="line">    public function sayHello()&#123;</div><div class="line">      parent::sayHello();</div><div class="line">      echo &quot;World\n&quot;;</div><div class="line">   &#125;  </div><div class="line">   public function says()&#123;</div><div class="line">       echo &quot;zwdfw\n&quot;;</div><div class="line">   &#125;</div><div class="line">   public static function func()</div><div class="line">   &#123;</div><div class="line">       static $c = 1;</div><div class="line">       echo &quot;$c.this is static\n&quot;;</div><div class="line">   &#125;</div><div class="line">   protected function sayno()</div><div class="line">   &#123;</div><div class="line">       echo &quot;sayno&quot;.&quot;\n&quot;;</div><div class="line">   &#125; </div><div class="line">   abstract public function getworld();//允许定义抽象方法</div><div class="line">&#125;</div><div class="line">class Myhello extends Base&#123;</div><div class="line">   use SayWorld,mysay;//用这种方式调用trait,相当于把所有的方法都继承到了  </div><div class="line">   public function getworld()</div><div class="line">   &#123;</div><div class="line">       echo &quot;nihao world\n&quot;;//使用了trait就要实现抽象方法</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">$foo = new Myhello();</div><div class="line">$foo-&gt;sayHello();//优先级高于继承来的同名方法</div><div class="line">$foo-&gt;says();//随意调用其中的方法</div><div class="line">//$foo-&gt;sayno();//私有方法和受保护的方法无法从trait中获取</div><div class="line">$foo-&gt;func();</div><div class="line">$foo-&gt;mysays();</div><div class="line">mysay::mysays();//无法实例化trait的对象访问，可以用trait名::方法/变量的形式访问</div><div class="line">echo $foo-&gt;name.&quot;\n&quot;;</div><div class="line">//echo $foo-&gt;c.&quot;\n&quot;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h2 id="这四种php中oo特性的代表的区别"><a href="#这四种php中oo特性的代表的区别" class="headerlink" title="这四种php中oo特性的代表的区别"></a>这四种php中oo特性的代表的区别</h2><table><thead><tr><th></th><th style="text-align:center">静态类</th><th style="text-align:center">抽象类</th><th style="text-align:center">接口</th><th style="text-align:center">trait</th></tr></thead><tbody><tr><td>是否可以实例化对象</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td>类外访问方式</td><td style="text-align:center">1.类名::属性/方法 <br>   2.对象名-&gt;方法</td><td style="text-align:center">子类继承实现，<br>实例化子类，<br>子类对象调用属性/方法</td><td style="text-align:center">子类implements实现，子类实例化对象调用属性/方法</td><td style="text-align:center">类中use实现，类外实例化对象调用属性/方法</td></tr><tr><td>方法是否立即实现</td><td style="text-align:center">类内外都可以</td><td style="text-align:center">子类实现</td><td style="text-align:center">子类实现</td><td style="text-align:center">类内外都可以</td></tr><tr><td>方法的访问控制</td><td style="text-align:center">都可以</td><td style="text-align:center">抽象方法公有或者受保护，普通方法都可以</td><td style="text-align:center">均为公有</td><td style="text-align:center">都可以</td></tr><tr><td>实现方式</td><td style="text-align:center">类内类外都可以</td><td style="text-align:center">子类继承实现</td><td style="text-align:center">子类继承实现</td><td style="text-align:center">内部实现</td></tr><tr><td>是否可以声明常量/变量</td><td style="text-align:center">都可以</td><td style="text-align:center">都可以，但变量无法类外访问</td><td style="text-align:center">常量可以，变量不可以</td><td style="text-align:center">都可以</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;最近笔者学习了php的基本知识，其基本语法像极了c语言，但是取消了指针等特性，且操作起来更加简便。下面就浅析一下php面向对
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="php基本语法" scheme="http://zy943453722.ink/tags/php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>IPC之管道通信的dup和dup2函数</title>
    <link href="http://zy943453722.ink/IPC%E4%B9%8B%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%9A%84dup%E5%92%8Cdup2%E5%87%BD%E6%95%B0/"/>
    <id>http://zy943453722.ink/IPC之管道通信的dup和dup2函数/</id>
    <published>2017-12-06T14:56:51.000Z</published>
    <updated>2018-01-30T01:37:49.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p><strong>前面笔者详细分析了网络编程中重要的通信技术：<font color="red">I/O复用技术</font>,接下来的几篇文章，我将重点来分析一下网络编程中另外一个重要的技术，即：<font color="blue">管道通信技术</font>。</strong></p><h2 id="dup、dup2函数基础"><a href="#dup、dup2函数基础" class="headerlink" title="dup、dup2函数基础"></a>dup、dup2函数基础</h2><p>由于利用管道实现进程间通信，是通过创建2个文件描述符，但是初始化文件描述符都是随机的，或者说是从可用的文件描述符中去除，并与相对应的文件建立映射关系，如果我们想要将管道的两头与其他流相关，或者说重定向一个文件描述符，那么，我们就需要dup和dup2函数。</p><p>可以说，这两个函数的作用就是：<br><br><strong><em>1.重定向文件描述符</em></strong><br><strong><em>2.复制文件描述符</em></strong></p><h3 id="dup函数："><a href="#dup函数：" class="headerlink" title="dup函数："></a>dup函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;unistd.h&gt;</div><div class="line">int dup(int fd);//fd为文件描述符，失败返回-1</div></pre></td></tr></table></figure><p><strong>dup函数创建一个新的文件描述符，该文件描述符和原有文件描述符指向相同的文件、管道或者网络链接，并且此fd总是系统当前可用的最小的文件描述符。</strong></p><h3 id="dup2函数："><a href="#dup2函数：" class="headerlink" title="dup2函数："></a>dup2函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include&lt;unistd.h&gt;</div><div class="line">int dup2(int fd1, int fd2);</div><div class="line">//fd1是指需要重定向的文件描述符，fd2是定向到的文件描述符。失败返回-1</div></pre></td></tr></table></figure><p><strong>dup2函数中fd2不做原本的工作，而改做fd1的工作，若此fd2文件描述符已经存在，则需要关闭他，再执行。</strong></p><p><font size="3" color="green">需要注意的是：这两个函数创建的文件描述符并不继承原有的文件描述符的属性(ex：close_on_exec,non-blocking等)，因为每个文件描述符都有一套文件描述符标志，新描述符执行时关闭(close_on_exec)标志总是由dup和dup2函数执行。只继承他的同一文件状态标志(读、写、添加等)。</font><br><br><br>其实对于文件描述符在内核中的存储有必要提一下：</p><ul><li>每个进程在进程表中都有一个记录项，每个记录项中有一张打开文件描述符表，可将视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<br> <br>(1) 文件描述符标志(close_on_exec,close_on_exec是一个进程所有文件描述符的标记位图，每个比特位代表一个打开的文件描述符，用于确定在系统调用execve()时需要关闭的文件句柄)。<br> <br>(2) 指向一个文件表项的指针。</li><li>内核为所有打开文件维持一张文件表。每个文件表项包含：<br> <br>(a) 文件状态标志(读、写、增写、同步、非阻塞等)。<br> <br>(b) 当前文件位移量。<br> <br>(c) 指向该文件v节点表项的指针。</li><li>节点表项。每个打开的文件都有一个v-node结构，v-node中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，V-node中还包含了文件inode节点信息，这些信息是打开文件时从磁盘上读入内存的，所以文件所有信息都是随时可用的。<br><br> 1. v节点的信息<br><br> 2. 当前文件的长度<br><br> 3. i节点的信息<br> <br><strong>也就是对应下图。<br><br></strong>图解过程：<strong><br></strong>假设执行了dup(1)函数，下一个可用的文件描述符是3。两个文件描述符指向同一文件表项。因此文件状态标志、当前文件位移量、指向文件的v节点表项指针共享。**<br><br><img src="/IPC之管道通信的dup和dup2函数/file.png" alt="图1"></li></ul><h2 id="函数的简单实例："><a href="#函数的简单实例：" class="headerlink" title="函数的简单实例："></a>函数的简单实例：</h2><p>下面的例子便是运用dup函数或者dup2函数，将新建的文件描述符指向之前建立好的网络连接，因为关闭了标准输出，因此文件描述符1空闲下来，可以使用，即相当于将标准输出定向到了网络连接中，实现CGI服务器功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">   if(argc &lt;= 2)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;error\n&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    const char* ip = argv[1];</div><div class="line">    int port = atoi(argv[2]);</div><div class="line"></div><div class="line">    struct sockaddr_in address;</div><div class="line">    bzero(&amp;address,sizeof(address));</div><div class="line">    address.sin_family = AF_INET;</div><div class="line">    inet_pton(AF_INET,ip,&amp;address.sin_addr);</div><div class="line">    address.sin_port = htons(port);</div><div class="line"></div><div class="line">    int sock = socket(PF_INET,SOCK_STREAM,0);</div><div class="line">    assert(sock &gt;= 0);</div><div class="line"></div><div class="line">    int ret = bind(sock,(struct sockaddr*)&amp;address,sizeof(address));</div><div class="line">    assert(ret != -1);</div><div class="line"></div><div class="line">    ret = listen(sock,5);</div><div class="line">    assert(ret != -1);</div><div class="line"></div><div class="line">    struct sockaddr_in client;</div><div class="line">    socklen_t client_addrlength = sizeof(client);</div><div class="line">    int connfd = accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength);</div><div class="line">    if(connfd &lt; 0)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;errno is %d\n&quot;,errno);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        close(STDOUT_FILENO);</div><div class="line">        dup(connfd);//自动寻找最小的文件描述符</div><div class="line">        //dup2(connfd,1);//自己指定文件描述符，若已存在，则返回一个大于指定文件描述符的最小值</div><div class="line">        printf(&quot;abcd\n&quot;);</div><div class="line">        close(connfd);</div><div class="line">    &#125;</div><div class="line">    close(sock);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>利用telnet模拟客户端可以看出，的确本应该输出到标准输出的字符，送到了客户端，而没有打印到终端。实现了重定向功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;前面笔者详细分析了网络编程中重要的通信技术：&lt;font color=&quot;red&quot;&gt;I/O复用技术&lt;/font&gt;,接下来
      
    
    </summary>
    
      <category term="IPC进程通信" scheme="http://zy943453722.ink/categories/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>I/O复用3个模型的比较</title>
    <link href="http://zy943453722.ink/I-O%E5%A4%8D%E7%94%A83%E4%B8%AA%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://zy943453722.ink/I-O复用3个模型的比较/</id>
    <published>2017-11-16T16:25:40.000Z</published>
    <updated>2017-11-25T14:09:08.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><strong><em>前面分析了I/O复用的3种模型，分别是select，poll，epoll，它们各有优缺点，并且应用广泛，今天就来分析一下他们的异同。</em></strong></p><h3 id="开场："><a href="#开场：" class="headerlink" title="开场："></a>开场：</h3><p><strong>分析之前还是讲一讲I/O复用在网络程序下的适用场合：</strong></p><ol><li>服务器同时监听socket和连接socket。</li><li>服务器端同时处理多个socket。</li><li>客户端程序同时处理用户输入和网络连接。</li><li>服务器同时处理TCP和UDP请求。</li><li>服务器监听多个端口，或者处理多个服务。<br><strong><br>I/O复用函数本身是阻塞的，它们必须顺序处理每个就绪的文件描述符，要想实现并发执行，要用到多线程/多进程编程。<font color="red">但I/O复用的优势也是在此,不必创建大量进程或者线程，也不必去维护它们，大大节约系统资源。</font></strong></li></ol><h3 id="渐进："><a href="#渐进：" class="headerlink" title="渐进："></a>渐进：</h3><p><strong><em><font color="blue" size="4">三者的共同点：</font></em></strong></p><ul><li>这3种模型都能同时监听多个文件描述符，他们等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有时间就绪时返回，返回就绪的数量。</li><li>3者都是同步I/O模型，即在监听事件就绪后也需要自己来负责读写。</li><li>3者都通过某种结构体变量来告知内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</li></ul><h3 id="高潮："><a href="#高潮：" class="headerlink" title="高潮："></a>高潮：</h3><p><strong><em><font color="blue" size="4">三者的区别：</font></em></strong></p><ul><li>poll、select是有事件就绪后就轮询所有的结构体数组中的文件描述符，看是否发生了感兴趣的事件。并将其中就绪的文件描述符返回给用户程序<strong>而epoll是有事件就绪后内核事件表将就绪事件放到一个结构体数组中，仅仅轮询这些就绪事件。即epoll_wait采用回调的方式，内核检测到就绪的文件描述符后，就触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。最后在适当时间将内容拷贝到用户空间。</strong></li><li>select参数类型fd_set 没有将文件描述符和事件进行绑定，它仅仅是一个文件描述符集合。而epoll、poll是将文件描述符和事件放入一个结构体中，实现了绑定。</li><li>epoll最大的区别是实现了用户注册事件和内核检测就绪事件的分离，搜索就绪事件只搜索返回的就绪事件。epoll是通过内核与用户空间mmap同一块内存实现的。而select、poll需要轮询所有文件描述符或者其一一对应的注册事件。</li><li>epoll适用于连接数量多，但活跃链接少的情况。select适用于并发量不高，且活跃链接多的情况。</li><li><p>另外还有几个小区别，请看下表：<br><br><img src="/I-O复用3个模型的比较/1.png" alt="图1"></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p><strong><em><font color="green" size="4">浅析三者的工作流程：</font></em></strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;前面分析了I/O复用的3种模型，分别是select，poll，epoll，它们各有优缺点，并且应用广泛，今天
      
    
    </summary>
    
      <category term="IPC进程通信" scheme="http://zy943453722.ink/categories/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>I/O复用之poll和epoll</title>
    <link href="http://zy943453722.ink/I-O%E5%A4%8D%E7%94%A8%E4%B9%8Bpoll%E5%92%8Cepoll/"/>
    <id>http://zy943453722.ink/I-O复用之poll和epoll/</id>
    <published>2017-11-12T21:59:25.000Z</published>
    <updated>2017-11-16T08:08:42.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h2><p><strong><em>poll函数的定义：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include&lt;poll.h&gt;</div><div class="line">int poll(struct pollfd* fds,nfds_t nfds,int timeout)</div><div class="line">typedef unsigned long int nfds_t;</div><div class="line">struct pollfd&#123;</div><div class="line">   int fd;</div><div class="line">   short events;//注册的事件</div><div class="line">   short revents;//实际发生的事件，有内核填充</div><div class="line">&#125;;</div><div class="line">timeout为0时，poll调用后立即返回，不阻塞</div><div class="line">       为-1时，poll调用将永远阻塞，直至某个事件发生。</div></pre></td></tr></table></figure></p><p><strong><em>poll函数实现监视的过程：</em></strong></p><ul><li>调用poll函数实现对感兴趣的文件描述符的某个事件的监听。</li><li>而后读取返回值，若返回值大于0，则轮询创建好的pollfd结构体数组，看每一个注册的事件是否发生感兴趣的事件。</li></ul><h2 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h2><h3 id="epoll函数的定义："><a href="#epoll函数的定义：" class="headerlink" title="epoll函数的定义："></a>epoll函数的定义：</h3><p><strong><br>epoll函数不同于poll和select，它是由一组函数组成的。</strong><br><strong><em><br>1. epoll创建函数：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;sys/epoll.h&gt;</div><div class="line">int epoll_create(int size)//参数指定内核事件表的大小,返回一个指向内核事件表的fd：epollfd</div></pre></td></tr></table></figure></p><p><strong><em><br>2. epoll执行注册函数：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*第一个参数为内核事件表的文件描述符，第二个参数为指定的操作类型,</div><div class="line">第三个为要操作的文件描述符，第4个为注册的事件*/</div><div class="line">//返回0为成功，-1为失败</div><div class="line">int epoll_ctl(int epollfd,int op,int fd,struct epoll_event *event)</div></pre></td></tr></table></figure></p><p><strong>对于op操作类型，大体有3种：</strong></p><ul><li>EPOLL_CTL_ADD:往内核事件表注册事件结构体</li><li>EPOLL_CTL_MOD:修改fd上的注册事件</li><li>EPOLL_CTL_DEL:删除fd上的注册事件<br><strong><br>对于epoll_event结构体：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef union epoll_data&#123;</div><div class="line">   void *ptr;</div><div class="line">   int fd;//注册事件的文件描述符</div><div class="line">   uint32_t u32;</div><div class="line">   uint64_t u64;</div><div class="line">&#125;epoll_data_t;</div><div class="line">  struct epoll_event&#123;</div><div class="line">   __uint32_t events;//epoll事件</div><div class="line">   epoll_data_t data;//用户的数据</div><div class="line">&#125;;//一般是将事件和epoll_data_t用户数据绑定</div></pre></td></tr></table></figure></li></ul><p><strong><em><br>3. epoll等待就绪函数：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*第一个参数指定内核事件表，第二个参数指定从内核事件表拷贝的就绪事件数组，</div><div class="line">第三个参数指定最多监听的事件个数，最后一个是设置超时时间同epoll*/</div><div class="line">//该函数成功时返回就绪事件个数，与文件描述符无关，失败返回-1</div><div class="line">int epoll_wait(int epollfd,struct epoll_event* events, int max,int timeout)</div></pre></td></tr></table></figure></p><p><strong><em><br>4.epoll的事件类型</em></strong></p><ul><li>EPOLLIN   ：数据可读（包括一般和优先数据）</li><li>EPOLLOUT  ：数据可写（包括一般和优先数据）</li><li>EPOLLERR ：数据错误</li><li>EPOLLET ：epoll的边沿触发模式事件</li><li>EPOLLONESHOT ：该文件描述符上的可读、可写、错误事件最多触发其中一个且只触发一次<br><strong><br>最后两个是epoll特有的，前三个去掉’E’即为poll的事件类型</strong><br><strong><em><br>5.epoll的模式：</em></strong><br><br>epoll中有两种模式，一种是LT模式，一种是ET模式。</li><li>LT模式：<br><br><font color="red" size="3">所谓LT模式，就是指电平触发，这是epoll默认的工作方式，要想改变可以通过上面的EPOLLET事件。这种模式下的epoll相当于一个效率较高的poll。<br><br><strong>这个模式下epoll_wait检测到有事件就绪后，应用程序可以不立即处理，那么下次调用epoll_wait仍会通告该事件，直至被处理。意味着每次epoll_wait()返回后，事件处理后，如果之后还有数据，会不断触发，也就是说，一个套接字上一次完整的数据，epoll_wait()可能会返回多次，直到没有数据为止。</strong>这个模式下文件描述符可阻塞可不阻塞。<br>该模式下只要在可读/可写 状态下epoll_wait都能检测到，因此可以不一次处理完。</font></li><li>ET模式  :<br><br><font color="blue" size="3">所谓ET模式，就是指边沿触发，当某个文件描述符注册EPOLLET事件时，eopll将使用ET模式操作该文件描述符。<br>有数据过来后，epoll_wait()会返回一次，<strong>一段时间内，</strong>该套接字就算有数据源源不断地过来，epoll_wait()也不会返回了。（即只会读出其中第一次的内容，再来数据是读不到的，但若是缓冲区不够的话，也会读到结束的）这里注意，是一段时间，不代表这个套接字上有数据就只触发一次。时间过长，还是会返回多次的。<strong><br>该模式与LT的最大区别就是当epoll_wait检测到事件就绪时，必须立即处理，后序再遇到epoll_wait不会在通告该事件，这样大大降低了同一个epoll事件被触发的次数。</strong>该模式下文件描述符必须使用非阻塞。<strong>这种模式下发送多次否则，会因为缓冲区的不足造成发送或接收不到所有的数据。直到errno为EAGAIN时才算读(写)取完毕无数据可读(写）</strong><br>另外，该模式只有当某文件描述符由不可读/不可写 状态变为 可读/可写 状态时才能触发</font><br><font size="5" color="green"><br>因此，ET模式是高速工作模式，LT是缺省工作模式。</font><br><strong><em><br>6.网络事件EAGIN</em></strong><br><br>在一个非阻塞的socket上调用read/write函数, 返回EAGAIN或者EWOULDBLOCK。若遇到能read时，读缓冲区没有数据，或者write时，写缓冲区满了。这种情况下，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。<br><br>因此，对于non-blocking的socket，正确的读写操作为:<br><br>读：忽略掉errno = EAGAIN的错误，下次可继续读<br><br>写：忽略掉errno = EAGAIN的错误，下次可继续写<br><br>因此ET模式使用非阻塞IO模型下需要用EAGAIN这个标志来判断接受的数据是否读完。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;poll函数&quot;&gt;&lt;a href=&quot;#poll函数&quot; class=&quot;headerlink&quot; title=&quot;poll函数&quot;&gt;&lt;/a&gt;poll函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;poll函数的定义：&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
      <category term="IPC进程通信" scheme="http://zy943453722.ink/categories/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>结构体变量malloc的故事</title>
    <link href="http://zy943453722.ink/%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8Fmalloc%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://zy943453722.ink/结构体变量malloc的故事/</id>
    <published>2017-10-27T23:01:28.000Z</published>
    <updated>2017-11-12T14:00:50.939Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>这是一个关于结构体通过malloc初始化的悲伤的故事</em></strong></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>因为本身结构体是不需要malloc就可以直接创建其对象，但是，当结构体中出现柔性数组或者是数组指针时，情况就截然不同了。因为这些数组都是要动态分配内存的，因此结构体也需要malloc。</p><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>但是此时问题就出现了，本身创建结构体对象时会在栈区分配一块地址，但是malloc之后又有另外一块地址指向了此对象，这是该怎么办呢？</p><h3 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/*这仅仅是个用数组动态创建栈的初始化过程*/</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">typedef struct stack</div><div class="line">&#123;</div><div class="line">      int top;</div><div class="line">      int count;</div><div class="line">      int array[];//柔性数组，也可以方括号内定义为0，也可以定义为数组指针</div><div class="line">&#125;Stack;</div><div class="line">void Init(Stack *s,int n)</div><div class="line">&#123;</div><div class="line">    s = (Stack*)malloc(sizeof(Stack) + n * sizeof(int));</div><div class="line">   s-&gt;top = -1;</div><div class="line">   s-&gt;count = n;</div><div class="line">&#125;</div><div class="line">void Destroy(Stack **s)</div><div class="line">&#123;</div><div class="line">      free(*s);</div><div class="line">      *s = NULL;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Stack s;</div><div class="line">   Stack *q = &amp;s;</div><div class="line">   Init(q);</div><div class="line">   Destroy(&amp;q);</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="gdb调试显示结果："><a href="#gdb调试显示结果：" class="headerlink" title="gdb调试显示结果："></a>gdb调试显示结果：</h3><p><img src="/结构体变量malloc的故事/3.png" alt="图2"><br><img src="/结构体变量malloc的故事/4.png" alt="图3"><br><strong><em>由图中可以看出原本传入Init函数的stack</em>的地址为0x7fffffffde00，但malloc出来的新地址为0x602830,改变malloc出来地址上的内容，函数返回时自然而然没有保存下来。<br>再次打印s的地址，<font color="blue">果然还是原地址，相应数据也没有保存下来</font></strong></p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>思路: </p><p>   既然一级指针会在init函数中被重新malloc，之后返回后保存不下来，那么可以启用2级指针，之后，让malloc出来的指针和原指针的地址相同(即2级指针也指向malloc出来的指针)这样返回时才能真正将malloc出来的指针保存下来。<br>具体解决方法<br>重写init方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void Init(Stack **s,int n)</div><div class="line">&#123;</div><div class="line">  Stack *p = (Stack *)malloc(sizeof(Stack) + n * sizeof(int));//新malloc出一块地址指向原来的结构体</div><div class="line">  *s = p; //将新malloc出来的地址赋值给原地址，让两个变成同一地址</div><div class="line">  p-&gt;top = -1;</div><div class="line">  p-&gt;count = n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3><p><img src="/结构体变量malloc的故事/zy.png" alt="图1"></p><p><strong>此时再次调用gdb调试：<br></strong><br><img src="/结构体变量malloc的故事/5.png" alt="图4"><br><img src="/结构体变量malloc的故事/6.png" alt="图5"><br>可以看出当从init函数返回后q指针已经变为malloc出来的地址，由此数据也被保存了下来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;这是一个关于结构体通过malloc初始化的悲伤的故事&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;因为本身结构体是不需
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++中类的大小</title>
    <link href="http://zy943453722.ink/c++%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F/"/>
    <id>http://zy943453722.ink/c++中类的大小/</id>
    <published>2017-10-22T16:34:26.000Z</published>
    <updated>2017-10-22T09:13:54.187Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> 类所占内存的大小是有成员变量（静态变量除外）决定的，成员函数是不计算在内的，他们只是名义上在类里，其实同一个类的多个对象共享函数代码，而我们访问类的成员函数是通过类中的自引用指针实现的，所以我们访问成员函数是间接获得地址的。 </em></strong></p><h3 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h3><p>空类的大小为1：</p><p>目的标示这个类，c++要求每个实例在内存中都具有独一无二的地址。</p><h3 id="普通类-不继承，不含虚函数）"><a href="#普通类-不继承，不含虚函数）" class="headerlink" title="普通类(不继承，不含虚函数）"></a>普通类(不继承，不含虚函数）</h3><p>跟struct的原理一致，内存对齐原则，但静态变量不占用内存，原因是编译器将其放在了全局变量区。</p><h3 id="含有虚函数的类"><a href="#含有虚函数的类" class="headerlink" title="含有虚函数的类"></a>含有虚函数的类</h3><p>c++类中有虚函数的时候有一个指向虚函数的指针(vptr),因此此指针要占用字节空间，<strong>虚函数个数和大小无关。</strong></p><h3 id="继承的类"><a href="#继承的类" class="headerlink" title="继承的类"></a>继承的类</h3><p>子类的大小是本身成员变量的大小加上父类的大小，若父类本身就含有虚函数，则子类无论有没有虚函数都不能算上。<br><strong>当继承空类时，不加上空类的大小，而是只算本身子类的大小。</strong></p><h3 id="实例（注：笔者是在64位操作系统下操作得出的结果"><a href="#实例（注：笔者是在64位操作系统下操作得出的结果" class="headerlink" title="实例（注：笔者是在64位操作系统下操作得出的结果"></a>实例（注：笔者是在64位操作系统下操作得出的结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">class cBase</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;; //标识存在为1</div><div class="line">class cBase1</div><div class="line">&#123;</div><div class="line">    int a;</div><div class="line">    char p;</div><div class="line">&#125;;//内存对齐，4个字节和1个字节，1字节按4字节算</div><div class="line">class cBase2</div><div class="line">&#123;</div><div class="line">  public:</div><div class="line">      cBase2();</div><div class="line">      virtual ~cBase2();//virtual开辟一块指针，因此为8</div><div class="line">  private:</div><div class="line">     int a;//4，因内存对齐则为8</div><div class="line">    char *p;//8</div><div class="line">&#125;;</div><div class="line">class c:public cBase</div><div class="line">&#123;</div><div class="line">   virtual void fun() = 0;//纯虚函数</div><div class="line">&#125;;</div><div class="line">class b&#123;&#125;;</div><div class="line">class d:public b,public c&#123;&#125;;//共享虚函数的指针</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;cBase类的大小:&quot; &lt;&lt; sizeof(cBase) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;cBase1类的大小:&quot; &lt;&lt; sizeof(cBase1) &lt;&lt; endl;</div><div class="line">    cout&lt;&lt; &quot;cBase2类的大小:&quot; &lt;&lt; sizeof(cBase2) &lt;&lt; endl; </div><div class="line">    cout&lt;&lt; &quot;c类的大小:&quot; &lt;&lt; sizeof(c) &lt;&lt;endl; </div><div class="line">    cout &lt;&lt; &quot;d类的大小:&quot; &lt;&lt; sizeof(d) &lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果为：<br><br>cBase类的大小：1<br><br>cBase1类的大小：8<br><br>cBase2类的大小：24<br><br>c类的大小：8<br><br>d类的大小：8<br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt; 类所占内存的大小是有成员变量（静态变量除外）决定的，成员函数是不计算在内的，他们只是名义上在类里，其实同一个类的多个对象共享函数代码，而我们访问类的成员函数是通过类中的自引用指针实现的，所以我们访问成员函数是间接获得地址的。 &lt;/em&gt;&lt;/stro
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>线程同步机制之互斥锁和条件变量</title>
    <link href="http://zy943453722.ink/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    <id>http://zy943453722.ink/线程同步机制之互斥锁和条件变量/</id>
    <published>2017-10-12T21:24:15.000Z</published>
    <updated>2017-10-12T15:00:28.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p><strong>Pthread是POSIX threads 的简称，是POSIX的线程标准。</strong><br> Pthread线程同步指多个线程协调地，有序地同步使用共享资源。多线程共享进程资源，一个线程访问共享资源需要一段完整的时间才能完成其读写操作，如果在这段时间被其他线程打断，就会产生诸多不可预知的错误。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="1-互斥量："><a href="#1-互斥量：" class="headerlink" title="1.互斥量："></a>1.互斥量：</h3><p>  互斥量是一种线程同步对象，“互斥”的含义是同一时刻只能有一个线程获得互斥量。一个互斥量对应一个共享资源，互斥量状态：<strong><em>1.解锁状态意味着共享资源可用，2.加锁状态意味着共享资源不可用。</em></strong></p><p>  一个线程需要使用共享资源时，使用thread_mutex_lock申请：1.当互斥量为解锁状态，则占用互斥量，并给互斥量加锁，占用资源（互斥量为加锁状态，其他线程不能使用互斥量并等待互斥量变为解锁状态），2.如果互斥量为加锁状态，则线程等待，直到互斥量为解锁状态（其他线程使用完共享资源后会解锁互斥量，释放资源）。</p><h3 id="2-临界区："><a href="#2-临界区：" class="headerlink" title="2.临界区："></a>2.临界区：</h3><p>临界区指的是一个访问共用资源的程序片断。通常由定义一个互斥量并加锁来保护这段临界区代码。</p><h3 id="3-互斥量的相关函数："><a href="#3-互斥量的相关函数：" class="headerlink" title="3.互斥量的相关函数："></a>3.互斥量的相关函数：</h3><p><strong><em>首先定义互斥量的结构体pthread_mutex_t。</em></strong></p><p><strong>1). 互斥量初始化函数：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr)</div></pre></td></tr></table></figure></p><p>第一个参数即互斥量结构体的指针，第二个变量则是互斥量的属性（当为NULL时是默认属性）。成功返回0，失败返回错误码。</p><p><strong>2). 互斥量上锁函数：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_mutex_lock(pthread_mutex_t *mutex)</div></pre></td></tr></table></figure></p><p>此函数参数即互斥量结构体，返回成功为0，失败返回错误码。<br>是阻塞的上锁函数。</p><p><strong>3). 互斥量解锁函数：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex)</div></pre></td></tr></table></figure></p><p>参数和返回值同上锁函数。</p><p><strong>4). 互斥量的另一种上锁函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex)</div></pre></td></tr></table></figure></p><p>这是上锁函数的非阻塞版本。若已经上锁，返回EBUSY。</p><p><strong>5). 互斥量的销毁函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex)</div></pre></td></tr></table></figure></p><p>参数和返回值同上锁函数。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。</p><h3 id="2-条件变量的相关函数"><a href="#2-条件变量的相关函数" class="headerlink" title="2.条件变量的相关函数"></a>2.条件变量的相关函数</h3><p><strong><em>首先定义条件变量结构体pthread_cond_t</em></strong></p><p><strong>1). 条件变量初始化函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr)</div></pre></td></tr></table></figure></p><p>第一个参数即条件变量结构体指针，第二个变量即条件变量的属性（如果为NULL，则是默认属性）。成功返回0，失败返回错误码。</p><p><strong>2).条件变量的销毁函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_cond_destroy(pthread_cond_t *cond)</div></pre></td></tr></table></figure></p><p>第一个参数即条件变量结构体指针。返回值同初始化函数。</p><p><strong>3). 条件变量的广播函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_cond_broadcast(pthread_cond_t *cond)</div></pre></td></tr></table></figure></p><p>参数和返回值同销毁函数。<br>此函数以广播的方式唤醒所有等待目标条件变量的线程。</p><p><strong>4). 条件变量的信号函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_cond_signal(pthread_cond_t *cond)</div></pre></td></tr></table></figure></p><p>参数返回值同销毁函数<br>此函数用于唤醒一个等待目标变量的线程。至于哪个线程被唤醒，则取决于线程的优先级和调度策略。</p><p><strong>5). 条件变量的等待函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include&lt;pthread.h&gt;</div><div class="line">int pthread_cond_wait(pthread_cond_t *cond)</div></pre></td></tr></table></figure></p><p>参数和返回值同销毁函数。<br><strong>在调用此函数之前必须保证互斥量已经加锁。</strong></p><font color="blue"> <strong>重点：模拟等待函数（pthread_cond_wait)调用前后的过程</strong></font><p>第一个线程首先调用：<br>    pthread_mutex_lock(&amp;mymutex);</p><p>然后，它检查了列表。没有找到感兴趣的东西，于是它调用：<br>    pthread_cond_wait(&amp;mycond, &amp;mymutex);</p><p>然后，pthread_cond_wait() 调用在返回前执行许多操作：<br>    pthread_mutex_unlock(&amp;mymutex);</p><p>它对 mymutex 解锁，然后进入睡眠状态，等待 mycond 以接收 POSIX 线程“信号”。一旦接收到“信号”（加引号是因为我们并不是在讨论传统的 UNIX 信号，而是来自 pthread_cond_signal() 或 pthread_cond_broadcast() 调用的信号），它就会苏醒。但 pthread_cond_wait() 没有立即返回——它还要做一件事：重新锁定 mutex：<br>    pthread_mutex_lock(&amp;mymutex);</p><p>pthread_cond_wait() 知道我们在查找 mymutex “背后”的变化，因此它继续操作，为我们锁定互斥对象，然后才返回。</p><h3 id="3-代码示例（互斥锁和条件变量一起用实现线程同步）"><a href="#3-代码示例（互斥锁和条件变量一起用实现线程同步）" class="headerlink" title="3.代码示例（互斥锁和条件变量一起用实现线程同步）"></a>3.代码示例（互斥锁和条件变量一起用实现线程同步）</h3><ul><li><strong>程序思路：</strong><br>在这里利用多线程技术实现生产者和消费者问题，生产者线程向一缓冲区中写数据，消费<br>者线程从缓冲区中读取数据，由于生产者线程和消费者线程共享同一缓冲区，为了正确读<br>写数据，在使用缓冲队列时必须保持互斥。生产者线程和消费者线程必须满足：生产者写<br>入缓冲区的数目不能超过缓冲区容量，消费者读取的数目不能超过生产者写入的数目。<br>在程序中使用了一个小技巧来判断缓冲区是空还是满。在初始化时读指针和写指针为0;<br>如果读指针等于写指针,则缓冲区是空的;如果(写指针+ 1) % N 等于读指针,则缓冲区是满的,<br>%表示取余数,这时实际上有一个单元空出未用。下面是完整的程序段和注释。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;pthread.h&gt; </div><div class="line">#include&lt;time.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;pthread.h&gt;</div><div class="line">#include&lt;unistd.h&gt;</div><div class="line">#define BUFFER_SIZE 8 </div><div class="line">#define OVER (-1)</div><div class="line">#if 0</div><div class="line"></div><div class="line">//互斥量和条件变量综合的结构体</div><div class="line">struct prodcons &#123;</div><div class="line">    int buffer[BUFFER_SIZE]; </div><div class="line">    pthread_mutex_t lock;      //互斥LOCK</div><div class="line">    int readpos , writepos;    //定义写和读的位置</div><div class="line">    pthread_cond_t notempty;   //缓冲区非空条件判断</div><div class="line">    pthread_cond_t notfull;    //缓冲区未满条件判断</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//获取时间的函数</div><div class="line">char * get_time(void)&#123;</div><div class="line">    time_t rawtime;</div><div class="line">    struct tm * timeinfo;</div><div class="line">    time(&amp;rawtime);</div><div class="line">    return asctime(localtime(&amp;rawtime));</div><div class="line">&#125;</div><div class="line"></div><div class="line">//对结构体初始化函数</div><div class="line">void init(struct prodcons * b)&#123;</div><div class="line">    pthread_mutex_init(&amp;b-&gt;lock,NULL);</div><div class="line">    pthread_cond_init(&amp;b-&gt;notempty,NULL);</div><div class="line">    pthread_cond_init(&amp;b-&gt;notfull,NULL);</div><div class="line"></div><div class="line">    b-&gt;readpos=0;</div><div class="line">    b-&gt;writepos=0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//放数据的函数</div><div class="line">void put(struct prodcons* b,int data)&#123;</div><div class="line">    pthread_mutex_lock(&amp;b-&gt;lock);</div><div class="line">    if((b-&gt;writepos + 1) % BUFFER_SIZE == b-&gt;readpos)//这是缓冲区满了的情况，留一个空用于发送-1这个信号</div><div class="line">    &#123;</div><div class="line">        pthread_cond_wait(&amp;b-&gt;notfull, &amp;b-&gt;lock);</div><div class="line">    &#125;</div><div class="line">//    pthread_mutex_lock(&amp;b-&gt;lock);</div><div class="line">//    大家仔细理解互斥锁的位置，以及pthread_cond_wait函数的内核实现（解锁，休眠让出cpu，条件满足后被内核唤醒，上锁，形成临界区，保护资源）</div><div class="line">    b-&gt;buffer[b-&gt;writepos]=data;</div><div class="line">    b-&gt;writepos++;</div><div class="line">    if(b-&gt;writepos &gt;= BUFFER_SIZE)</div><div class="line">        b-&gt;writepos=0;</div><div class="line">    printf(&quot;put %d at %s \n&quot;, data, get_time());</div><div class="line">    pthread_mutex_unlock(&amp;b-&gt;lock);</div><div class="line">    pthread_cond_signal(&amp;b-&gt;notempty);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//取数据的函数</div><div class="line">int get(struct prodcons *b)&#123;</div><div class="line">    int data;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;b-&gt;lock);</div><div class="line">    if(b-&gt;writepos == b-&gt;readpos)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;0 == 0\n&quot;);</div><div class="line">        pthread_cond_wait(&amp;b-&gt;notempty, &amp;b-&gt;lock);</div><div class="line">        printf(&quot;start read \n&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    data = b-&gt;buffer[b-&gt;readpos];</div><div class="line">    b-&gt;readpos++;</div><div class="line">    if(b-&gt;readpos &gt;= BUFFER_SIZE)</div><div class="line">        b-&gt;readpos=0;</div><div class="line">    printf(&quot;get the data is : %d\n&quot;, data);</div><div class="line">    pthread_cond_signal(&amp;b-&gt;notfull);</div><div class="line">    pthread_mutex_unlock(&amp;b-&gt;lock);</div><div class="line">    return data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义全局结构体对象</div><div class="line">struct prodcons buffer;</div><div class="line"></div><div class="line">//生产者回调函数</div><div class="line">void *producer(void *data)</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    </div><div class="line">    for(n = 0; n &lt; 10; n++)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;before produce %d \n&quot;, n) ;</div><div class="line">        put(&amp;buffer, n);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    put(&amp;buffer, OVER);//发信号说-1已经放进去了，说明没内容写了</div><div class="line">    </div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//消费者回调函数</div><div class="line">void *consumer(void * data)</div><div class="line">&#123;</div><div class="line">    int d;</div><div class="line">    while(1)</div><div class="line">    &#123;</div><div class="line">        d = get(&amp;buffer);</div><div class="line">        if(d == OVER)//说明生产者已经写完</div><div class="line">            break;</div><div class="line">        printf(&quot;consumerd the num is %d\n&quot;, d);</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//主函数</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    pthread_t th_a, th_b;</div><div class="line">    pthread_attr_t attr;</div><div class="line">    void *retval;</div><div class="line">    pthread_attr_init(&amp;attr);</div><div class="line">    init(&amp;buffer);</div><div class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</div><div class="line">//    pthread_create(&amp;th_b, &amp;attr, consumer, 0);</div><div class="line">    pthread_create(&amp;th_b, NULL, consumer, 0);</div><div class="line">    sleep(3);</div><div class="line">    pthread_create(&amp;th_a, NULL, producer, 0);</div><div class="line">    pthread_join(th_a, &amp;retval);</div><div class="line">    pthread_join(th_b, &amp;retval);</div><div class="line">    sleep(100);</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  <img src="/线程同步机制之互斥锁和条件变量/1.png" alt="图1"><br>  <img src="/线程同步机制之互斥锁和条件变量/2.png" alt="图2"><br>  由图中可以看出，当条件变量不空不满足条件时，调用了等待函数使得此线程睡眠，让出cpu，进行其他操作，但是当条件满足时并不是直接回到原线程进行到的地方，而是重新加锁，在读。</p><p>参考资料：</p><p><a href="http://blog.csdn.net/shanshanpt/article/details/" target="_blank" rel="external">http://blog.csdn.net/shanshanpt/article/details/</a><br><a href="http://blog.csdn.net/lovecodeless/article/details/24885127" target="_blank" rel="external">http://blog.csdn.net/lovecodeless/article/details/24885127</a><br><a href="http://blog.sina.com.cn/s/blog_590be5290100ikh5.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_590be5290100ikh5.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程同步&quot;&gt;&lt;a href=&quot;#线程同步&quot; class=&quot;headerlink&quot; title=&quot;线程同步&quot;&gt;&lt;/a&gt;线程同步&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Pthread是POSIX threads 的简称，是POSIX的线程标准。&lt;/strong&gt;&lt;br&gt; Pt
      
    
    </summary>
    
      <category term="技术" scheme="http://zy943453722.ink/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
      <category term="linux网络编程" scheme="http://zy943453722.ink/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅析多线程并发及写微信红包遇到的问题</title>
    <link href="http://zy943453722.ink/%E6%B5%85%E6%9E%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%8F%8A%E5%86%99%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://zy943453722.ink/浅析多线程并发及写微信红包遇到的问题/</id>
    <published>2017-09-24T22:35:11.000Z</published>
    <updated>2017-09-25T12:59:24.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><p>   众所周知，多线程编程很容易遇上诸如丢失更新、脏读、死锁等烦人的线程冲突问题。多线程的问题一旦发生便很难定位和解决，所以要在编程的初始阶段就要注意避免多线程程序常见的错误。</p><p>   微信红包程序应用线程基础API，采用多线程并发的方式进行抢红包操作。</p><p>   多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。</p><h2 id="微信红包程序"><a href="#微信红包程序" class="headerlink" title="微信红包程序"></a>微信红包程序</h2><p>   <strong>思路：</strong></p><ol><li>创建抢红包人员的结构体，分别给定名字，所抢金额，以及是否已抢过字段。</li><li>创建生产者线程，用于产生红包，红包金额和红包数目从标注输入读入，并对生产者回调函数进行加锁操作。</li><li>创建多个消费者线程，用于多人抢红包操作，其中消费者回调函数进行红包的随机分配算法，并进行加锁操作。</li></ol><p><strong><em>下面是部分代码示例：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"> /*结构体部分*/</div><div class="line">  typedef struct person</div><div class="line">  &#123;</div><div class="line">      int id;</div><div class="line">      char name[20];</div><div class="line">      int flag;</div><div class="line">       int money;</div><div class="line">   &#125;Person;</div><div class="line"></div><div class="line">/* 生产者回调函数*/</div><div class="line">   void *producer(void* value)//生产者只负责产生红包金  额和红包个数</div><div class="line">   &#123;</div><div class="line">      double n = *(double*)value;</div><div class="line">       pthread_mutex_lock(&amp;lock);</div><div class="line">       money = n;</div><div class="line">       pthread_mutex_unlock(&amp;lock);</div><div class="line">       pthread_exit(NULL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">/*消费者回调函数*/</div><div class="line">  void *consumer(void *n)//消费者用于随机获取红包个数</div><div class="line">  &#123;</div><div class="line">      int nn = *(int*)n;</div><div class="line">      pthread_mutex_lock(&amp;lock);</div><div class="line">      printf(&quot;number%d\n&quot;,nn);</div><div class="line">      if(money &gt; 0 &amp;&amp; per[nn].flag == 0)//还没抢过</div><div class="line">      &#123;</div><div class="line">         if(num &gt; 1)</div><div class="line">         &#123;</div><div class="line">            srand((unsigned)time(NULL));//初始化随机数种子       </div><div class="line">            double avg = money / num;//获取平均值</div><div class="line">            double t = avg*2;</div><div class="line">            double randmoney = (rand()%(int)(t*100) + (int)MIN*100)/100.00 + MIN;//初始化随机数</div><div class="line">            money-=randmoney;</div><div class="line">            printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,randmoney);</div><div class="line">            printf(&quot;剩余%.2lf元\n&quot;,money);</div><div class="line">            per[nn].id = nn;</div><div class="line">            per[nn].money = randmoney;</div><div class="line">            per[nn].flag = 1;</div><div class="line">            num--;</div><div class="line">           &#125;</div><div class="line">           else</div><div class="line">           &#123;</div><div class="line">               printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,money);</div><div class="line">               printf(&quot;剩余0元\n&quot;);</div><div class="line">               money = 0;</div><div class="line">               per[nn].id = nn;</div><div class="line">               per[nn].money = money;</div><div class="line">               per[nn].flag = 1;</div><div class="line">               num--;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">       pthread_mutex_unlock(&amp;lock);</div><div class="line">       pthread_cancel(pthread_self());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">/*主函数中主要线程API使用部分*/</div><div class="line"></div><div class="line">    pthread_t th_a,th_b[Total];</div><div class="line">     pthread_mutex_init(&amp;lock,0);</div><div class="line">     pthread_create(&amp;th_a,NULL,producer,(void*)&amp;value);</div><div class="line">     pthread_join(th_a,NULL);</div><div class="line">     int args[Total];</div><div class="line">     for(i = 0; i &lt; Total;i++)</div><div class="line">     &#123; </div><div class="line">         args[i] = i;</div><div class="line">         if(per[i].flag == 0)</div><div class="line">         &#123;</div><div class="line">             pthread_create(&amp;th_b[i],NULL,consumer,(void*)&amp;args[i]);</div><div class="line">             // usleep(100);</div><div class="line">             printf(&quot;i = %d\n&quot;,i);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">     for(i = 0; i &lt; Total; i++)</div><div class="line">     &#123;</div><div class="line">         pthread_join(th_b[i],NULL);</div><div class="line">     &#125;</div><div class="line">     pthread_mutex_destroy(&amp;lock);</div><div class="line"></div><div class="line">/* 全局变量声明*/</div><div class="line">     #define Total 20//线程个数</div><div class="line">     Person per[Total];</div><div class="line">     double money = 0.0;//初始金额</div><div class="line">     int num = 0;//初始红包个数</div><div class="line">     pthread_mutex_t lock;//创建锁</div></pre></td></tr></table></figure><p><strong><em>这是笔者在经过对线程的更深入理解后写好的版本。</em></strong></p><p>在最初的版本中，代码的<strong>69行</strong>的最后一个参数传的是(void*)&amp;i,但程序运行后时而成功时而失败，失败时如下图：</p><p><img src="/浅析多线程并发及写微信红包遇到的问题/3.png" alt="图1"></p><p><img src="/浅析多线程并发及写微信红包遇到的问题/4.png" alt="图2"></p><p><strong><em>由运行结果可以看出20个线程全部都已创建出，但是却出现了红包抢不完的情况，而且观察发现，抢红包的顺序是乱序，且出现了同一个number的线程抢了好几次红包。</em></strong></p><h3 id="因此总结为以下几个问题被给出解答："><a href="#因此总结为以下几个问题被给出解答：" class="headerlink" title="因此总结为以下几个问题被给出解答："></a>因此总结为以下几个问题被给出解答：</h3><p><strong> 1. 为什么创建线程是for循环控制，而抢红包是乱序？</strong></p><p><strong><em>答：</em></strong><br>   <font color="red"><br>   这是因为存在资源抢占现象，创建线程的顺序是有for循环控制的，但创建好线程之后，谁先调用回调函数顺序是不定的，谁的抢到cpu资源，谁就先进入回调函数，谁就先抢红包。<br>   </font></p><p><strong> 2. 为什么看似是同一个线程抢了多次红包？</strong></p><p><strong><em>答：</em></strong></p><font color="blue"><br>这是因为i++操作是三条指令，分别是找到i将其放入寄存器，而后+1，最后回赋。而在运行结果中出现多次number7的情况却并不是同一个线程抢红包多次。<strong>因为可能有某几个线程在执行回调函数时，i的值还没有进行回赋操作，就被剥夺了cpu，而pthread_create函数最后一个参数原本传的是i的地址，即从地址中取i的值，但此时i还是原来的值。</strong> 因此看似是同一个线程抢了多次红包，实则不同线程执行同一个i的回调函数。<br></font><p><strong> 3. 为什么经过修改用数组存i值可以，但最初版本用i时不可以？</strong></p><p><strong><em>答：</em></strong></p><font color="green"><br>这是因为pthread_create函数最后一个参数存的是地址。<br><br>当存的是i的地址时，即i变一次，地址中的内容变一次，当创建出线程而不是立即调用回调函数，而是被剥夺cpu资源时，i值就随for循环变化而变化，因此当回调函数有了cpu资源后，i的地址中存的就不是当时地址中的内容了。<br><br>当用数组存i值时，数组共有Total个地址，创建线程时，当对应的i存到对应的地址，某个数组下表元素的地址只存其当时的值，因此即使不立即调用回调函数，之后拿到的也是当时参数地址中的值，这个值未发生变化。<br></font><p><strong> 4. 为什么67行有flag控制，而同一个i还能进去呢？</strong></p><p><strong><em>答：</em></strong></p><font color="yellow"><br>**这个if判断由外部for循环控制，for循环是满足条件后进入，结束一次循环后i++，因此每次进入if后的i值都不同，至于说number7打印好多次，好像线程也创建了多次是错误的，是回调函数导致此原因，同问题2，在此就不赘述。<br></font><p><strong> 5. 为什么在for循环中加上sleep类的函数就可以正确抢红包，但是是顺序抢？</strong></p><p><strong><em>答：</em></strong></p><font color="cyan"><br>这是因为usleep函数和sleep函数的作用是挂起当前线程，即挂起当前运行的主线程。在线程创建之后，即挂起主线程，只能进入子线程调用回调函数，回调函数又加了互斥锁，因此直到解锁才能释放cpu资源，即抢红包过程是顺序的。<br></font><p><strong>6.为什么在number8后会出现number7？（即为什么8号线程后才出现7号线程？</strong></p><p><strong><em>答：</em></strong><br>这其实还是存在资源抢占问题，7线程创建后，没进入回调函数就被其他线程剥夺了cpu，因此当轮到其执行回调函数时，已经过去了很久。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多线程并发&quot;&gt;&lt;a href=&quot;#多线程并发&quot; class=&quot;headerlink&quot; title=&quot;多线程并发&quot;&gt;&lt;/a&gt;多线程并发&lt;/h2&gt;&lt;p&gt;   众所周知，多线程编程很容易遇上诸如丢失更新、脏读、死锁等烦人的线程冲突问题。多线程的问题一旦发生便很难定位和解
      
    
    </summary>
    
      <category term="网络编程" scheme="http://zy943453722.ink/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
      <category term="多线程，linux网络编程" scheme="http://zy943453722.ink/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8Clinux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅析select函数及FD宏</title>
    <link href="http://zy943453722.ink/%E6%B5%85%E6%9E%90select%E5%87%BD%E6%95%B0%E5%8F%8AFD%E5%AE%8F/"/>
    <id>http://zy943453722.ink/浅析select函数及FD宏/</id>
    <published>2017-09-19T23:13:33.000Z</published>
    <updated>2017-09-22T13:06:12.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h1><p><strong>这个函数允许进程指示内核等待多个事件中的任一个发生，并仅在一个或者多个事件发生或经过某指定时间后才唤醒进程。</strong></p><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include&lt;sys/select.h&gt;</div><div class="line">#include&lt;sys/time.h&gt;</div><div class="line"></div><div class="line">int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);</div><div class="line">     返回：准备好的描述字正数目，0表示超时，-1表示出错</div></pre></td></tr></table></figure><h3 id="函数参数解析："><a href="#函数参数解析：" class="headerlink" title="函数参数解析："></a>函数参数解析：</h3><ol><li>参数maxfdp1指定被测试的描述字数目，即经过FD_SET之后，所关心的描述符的个数，（因为从0开始，因此一般这个值是测试描述符集下标最大值+1）并通知内核。</li><li>中间三个参数readset，writeset，exceptset指定我们要让内核测试读、写、异常条件所需的描述字。也就是说，对于readset，<strong>我们关心是否可以从这些文件中读取数据了</strong>，对于writeset，<strong>我们关心是否可以向这些文件中写入数据了</strong>，对于exceptset，<strong>我们关心这些文件是否发生异常</strong>。</li><li>参数timeout，它告诉内核等待一组指定的描述字中的任意一个准备好可花多长时间，结构timeval指定了秒数和微秒数成员：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct timeval</div><div class="line">&#123;</div><div class="line">long tv-sec;//秒</div><div class="line">long tv-usec;//微秒</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p><strong><em>有三种可能：</em></strong></p><p> 1) 、永远等待下去：仅在有一个描述符准备好I/O时才返回，要设置timeout为NULL。</p><p> 2) 、等待固定时间：在有一个描述符准备好I/O时返回，但不超过timeout参数指定的秒数和微秒数。</p><p> 3) 、根本不等待：检查描述字后立即返回，这称为轮询(polling),参数timeout要指向某一个timeval结构，且其中的秒数和微秒数要置0。</p><p> <strong>前两种是阻塞的，最后一种是不阻塞的</strong></p><h2 id="fdset结构体解析"><a href="#fdset结构体解析" class="headerlink" title="fdset结构体解析:"></a>fdset结构体解析:</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include&lt;typesizes.h&gt;</div><div class="line">#define __FD_SETSIZE 1024</div><div class="line"></div><div class="line">#include&lt;sys/select.h&gt;</div><div class="line">#define FD_SETSIZE __FD_SETSIZE</div><div class="line">typedef long int __fd_mask;//64位系统上大小为8</div><div class="line">#undef __NFDBITS</div><div class="line">#define __NFDBITS (8*(int) sizeof(__fd_mask))  // 8*8 = 64</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">#ifdef __USE_XOPEN</div><div class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];//数组长度为1024/64 = 16</div><div class="line"> #define __FDS_BITS(set) ((set)-&gt;fds_bits)</div><div class="line"> #else</div><div class="line">    __fd_mask __fds_bits[____FD_SETSIZE / __NFDBITS];</div><div class="line"> #define __FDS_BITS(set) ((set)-&gt;fds_bits)</div><div class="line"> #endif</div><div class="line"> &#125;fd_set</div></pre></td></tr></table></figure><p> <strong>因此fd_set结构体中仅包含一个整型数组，该数组的每个元素的每一位都会标记一个文件描述符。因此16个long int元素就是 16<em>8</em>8 = 1024位 ，最多容纳1024个文件描述符！！</strong></p><h1 id="select中FD相关的4个宏"><a href="#select中FD相关的4个宏" class="headerlink" title="select中FD相关的4个宏"></a>select中FD相关的4个宏</h1><ol><li>void FD_ZERO(fd_set *fdset);//使fd_set结构体中的整型数组清零</li><li>void  FD_SET(int fd,fd_set *fdset); //设置感兴趣的文件描述符</li><li>void FD_CLR（int fd,fd_set *fdset);//关闭感兴趣的文件描述符</li><li>int FD_ISSET(int fd, fd_set *fdset); //用于判断某个文件描述符是否就绪，且在感兴趣的描述符集合中</li></ol><h1 id="对于几个宏和select的理解"><a href="#对于几个宏和select的理解" class="headerlink" title="对于几个宏和select的理解"></a>对于几个宏和select的理解</h1><ul><li>fd_set是创建文件描述符集合</li><li>FD_SET是设置感兴趣的文件描述符放入描述符集合中，将对应位置为1，但是此文件描述符可能准备好了，也可能没有准备好，可以说是一类文件描述符。</li><li>select是监听这几个文件描述符看哪几个就绪了，就返回个数，没就绪的再次置回0，就绪的保留1。</li><li>FD_ISSET是真正查看哪个指定的文件描述符是否就绪，就绪就为1，未就绪就为0。</li></ul><p><strong><em>example：</em></strong></p><p>   为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。<br>　　<br>  （1）执行fd_set set; FD_ZERO(&amp;set);则set用位表示是0000,0000。　　</p><p> （2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)　</p><p> （3）若再加入fd＝2，fd=1,则set变为0001,0011</p><p>（4）执行select(6,&amp;set,0,0,0)阻塞等待</p><p>（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p><p>（6）此时FD_ISSET(1,&amp;set)返回1，而FD_ISSET(5,&amp;set)返回0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;select函数&quot;&gt;&lt;a href=&quot;#select函数&quot; class=&quot;headerlink&quot; title=&quot;select函数&quot;&gt;&lt;/a&gt;select函数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;这个函数允许进程指示内核等待多个事件中的任一个发生，并仅在一个或者多个事件发
      
    
    </summary>
    
      <category term="技术" scheme="http://zy943453722.ink/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
      <category term="网络编程，c" scheme="http://zy943453722.ink/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%8Cc/"/>
    
  </entry>
  
  <entry>
    <title>c++重载覆盖隐藏的区别和执行方式</title>
    <link href="http://zy943453722.ink/c-%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/"/>
    <id>http://zy943453722.ink/c-重载覆盖隐藏的区别和执行方式/</id>
    <published>2017-09-14T22:53:03.000Z</published>
    <updated>2017-09-22T14:11:58.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="成员函数被重载（overload）的特征"><a href="#成员函数被重载（overload）的特征" class="headerlink" title="成员函数被重载（overload）的特征"></a>成员函数被重载（overload）的特征</h2><ul><li>相同的范围（在同一个类中）</li><li>函数名字相同</li><li>参数不同</li><li><p>virtual关键字可有可无</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">  private: </div><div class="line">     int a</div><div class="line">  public：</div><div class="line">      void print();</div><div class="line">      void print(int aa);</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><h2 id="覆盖（override）的特征"><a href="#覆盖（override）的特征" class="headerlink" title="覆盖（override）的特征"></a>覆盖（override）的特征</h2><ul><li>不同的范围（分别于派生类和基类）</li><li>函数名字相同</li><li>参数相同</li><li>基类函数必须有virtual关键字</li></ul><p><strong><em>覆盖是指派生类函数覆盖基类函数</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">  public:</div><div class="line">    virtual void print();</div><div class="line"> &#125;;</div><div class="line"> class B:public A</div><div class="line"> &#123;</div><div class="line">    public:</div><div class="line">      void print();</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><h2 id="隐藏（redefining）的规则"><a href="#隐藏（redefining）的规则" class="headerlink" title="隐藏（redefining）的规则"></a>隐藏（redefining）的规则</h2><ul><li>派生类函数与基类函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数都会被隐藏。</li><li><p>若派生类函数与基类函数同名且参数相同，但是基类函数没有virtual，基类的函数会被隐藏。</p><p><strong><em>隐藏是指派生类的函数屏蔽了与其同名的基类函数。</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">public:</div><div class="line">  void print();</div><div class="line"> &#125;;</div><div class="line"> class B:public A&#123;</div><div class="line"> private:</div><div class="line">  int a;</div><div class="line"> public:</div><div class="line">   void print(int aa);</div><div class="line">   &#125;;</div><div class="line">   -----------------------------------------------------</div><div class="line">   class A&#123;</div><div class="line">   public:</div><div class="line">     void print();</div><div class="line">  &#125;;</div><div class="line">  class B:public A&#123;</div><div class="line">  public:</div><div class="line">    void print();</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><h2 id="3种情况怎么执行"><a href="#3种情况怎么执行" class="headerlink" title="3种情况怎么执行"></a>3种情况怎么执行</h2><ol><li>重载：看参数</li><li>隐藏：看指针类型</li><li>覆盖：看实体对象类型</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;成员函数被重载（overload）的特征&quot;&gt;&lt;a href=&quot;#成员函数被重载（overload）的特征&quot; class=&quot;headerlink&quot; title=&quot;成员函数被重载（overload）的特征&quot;&gt;&lt;/a&gt;成员函数被重载（overload）的特征&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://zy943453722.ink/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>using关键字在c#中的使用</title>
    <link href="http://zy943453722.ink/using%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8c#%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://zy943453722.ink/using关键字在c#中的使用/</id>
    <published>2017-06-06T22:50:36.000Z</published>
    <updated>2017-09-25T15:03:44.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="using关键字在C-中的3种用法"><a href="#using关键字在C-中的3种用法" class="headerlink" title="using关键字在C#中的3种用法"></a>using关键字在C#中的3种用法</h1><p><strong>using 关键字有两个主要用途：</strong></p><p>  (一).作为指令，用于为命名空间创建别名或导入其他命名空间中定义的类型。</p><p>  (二).作为语句，用于定义一个范围，在此范围的末尾将释放对象。</p><h2 id="一-作为指令"><a href="#一-作为指令" class="headerlink" title="(一).作为指令"></a>(一).作为指令</h2><p>1、用在命名空间里    </p><p>using + 命名空间名字，这样可以在程序中直接用命令空间中的类型，而不必指定类型的详细命名空间，类似于Java的import，这个功能也是最常用的，几乎每个cs的程序都会用到。<br>例如：using System; 一般都会出现在*.cs中。</p><p>2、为命名空间或类型创建别名，using + 别名 = 包括详细命名空间信息的具体的类型。</p><p>这种做法有个好处就是当同一个cs引用了两个不同的命名空间，但两个命名空间都包括了一个相同名字的类型的时候。当需要用到这个类型的时候，就每个地方都要用详细命名空间的办法来区分这些相同名字的类型。而用别名的方法会更简洁，用到哪个类就给哪个类做别名声明就可以了。注意：并不是说两个名字重复，给其中一个用了别名，另外一个就不需要用别名了，如果两个都要使用，则两个都需要用using来定义别名的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">using System; </div><div class="line">using aClass = NameSpace1.MyClass; </div><div class="line">using bClass = NameSpace2.MyClass; </div><div class="line">namespace NameSpace1 &#123; </div><div class="line">         public class MyClass &#123; </div><div class="line">                  public override string ToString() &#123; </div><div class="line">                         return &quot;You are in NameSpace1.MyClass&quot;; </div><div class="line">                         &#125; </div><div class="line">                     &#125; </div><div class="line">                 &#125; </div><div class="line">namespace NameSpace2 &#123; </div><div class="line">     class MyClass &#123; </div><div class="line">           public override string ToString() &#123; </div><div class="line">                  return &quot;You are in NameSpace2.MyClass&quot;; </div><div class="line">                  &#125; </div><div class="line">           &#125; </div><div class="line">     &#125; </div><div class="line"> namespace testUsing &#123; </div><div class="line">       using NameSpace1; </div><div class="line">       using NameSpace2; </div><div class="line">       class Class1 &#123; </div><div class="line">             [STAThread] static void Main(string[] args)              &#123; </div><div class="line">                 aClass my1 = new aClass();</div><div class="line">                 Console.WriteLine(my1); bClass my2 = new bClass(); </div><div class="line">                 Console.WriteLine(my2); Console.WriteLine(&quot;Press any key&quot;); Console.Read();</div><div class="line">                 &#125;</div><div class="line">             &#125; </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>(二).作为语句</p><ul><li>using 语句允许程序员指定使用资源的对象应当何时释放资源。</li><li><p>using 语句中使用的对象必须实现 IDisposable 接口。此接口提供了 Dispose 方法，该方法将释放此对象的资源。</p><p>  ①可以在 using 语句之前声明对象。<br>　　    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    Font font2 = new Font(“Arial”, 10.0f);</div><div class="line">    using (font2)</div><div class="line">    &#123;</div><div class="line">    // use font2;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">②可以在 using 语句之中声明对象。</div></pre></td></tr></table></figure></p><pre><code>using (Font font2 = new Font(“Arial”, 10.0f)){// use font2;}</code></pre><p>  ③可以有多个对象与 using 语句一起使用，但是必须在 using 语句内部声明这些对象。</p><pre><code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">       using (Font font3=new Font(“Arial”,10.0f), font4=new Font(“Arial”,10.0f))&#123;</div><div class="line">       // Use font3 and font4. </div><div class="line">       &#125;</div><div class="line"></div><div class="line">***使用规则:***</div><div class="line"></div><div class="line">①using只能用于实现了IDisposable接口的类型，禁止为不支持IDisposable接口的类型使用using语句，否则会出现编译错误；</div><div class="line"></div><div class="line">②using语句适用于清理单个非托管资源的情况，而多个非托管对象的清理最好以try-finnaly来实现，因为嵌套的using语句可能存在隐藏的Bug。内层using块引发异常时，将不能释放外层using块的对象资源；</div><div class="line"></div><div class="line">③using语句支持初始化多个变量，但前提是这些变量的类型必须相同，例如：</div></pre></td></tr></table></figure>  using(Pen p1 = new Pen(Brushes.Black), p2 = new Pen(Brushes.Blue)){  //   }<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">④针对初始化多个不同类型的变量时，可以都声明为IDisposable类型，例如：</div></pre></td></tr></table></figure>  using (IDisposable font = new Font(“Verdana”, 12), pen = new Pen(Brushes.Black))</code></pre><p>　　    {<br>　　        float size = (font as Font).Size;<br>　　        Brush brush = (pen as Pen).Brush;<br>　　    }</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">using实质</div><div class="line">    在程序编译阶段，编译器会自动将using语句生成为try-finally语句，并在finally块中调用对象的Dispose方法，来清理资源。所以，using语句等效于try-finally语句，例如：</div></pre></td></tr></table></figure></code></pre></li></ul><p>using (Font f2 = new Font(“Arial”, 10, FontStyle.Bold)）<br>{<br>     font2.F();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">被编译器翻译为：</div></pre></td></tr></table></figure></p><pre><code>Font f2 = new Font(“Arial”, 10, FontStyle.Bold);　try{     font2.F();　}finally　{    if (f2 != null) ((IDisposable)f2).Dispose();   }</code></pre><p>```</p><p>转载自<br><a href="http://www.cnblogs.com/xiaobiexi/p/6179127.html" target="_blank" rel="external">http://www.cnblogs.com/xiaobiexi/p/6179127.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;using关键字在C-中的3种用法&quot;&gt;&lt;a href=&quot;#using关键字在C-中的3种用法&quot; class=&quot;headerlink&quot; title=&quot;using关键字在C#中的3种用法&quot;&gt;&lt;/a&gt;using关键字在C#中的3种用法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;us
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="http://zy943453722.ink/tags/c/"/>
    
      <category term="函数" scheme="http://zy943453722.ink/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ADO.NET与外部数据库连接及查询等基本操作</title>
    <link href="http://zy943453722.ink/ADO-NET%E4%B8%8E%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%8F%8A%E6%9F%A5%E8%AF%A2%E7%AD%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://zy943453722.ink/ADO-NET与外部数据库连接及查询等基本操作/</id>
    <published>2017-05-21T15:37:04.000Z</published>
    <updated>2017-09-17T13:56:47.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立与数据库连接"><a href="#建立与数据库连接" class="headerlink" title="建立与数据库连接:"></a>建立与数据库连接:</h2><p><strong>需要连接字符串，用到System.Data.SqlClient类库。</strong></p><p>方法：</p><ul><li>使用一个类构建SQL Server 连接字符串<pre><code>-  创建SqlconnectionStringBuider实例- 根据需要设置其属性- 访问该对象的ConnectionString属性</code></pre></li><li><p>与SQL Server数据库建立连接</p><pre><code>- 生成一个指向该数据库的连接字符串- 创建SqlConnection实例，向构造函数传递连接字符串- 调用Sqlconnection实例的open方法</code></pre><h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><pre><code>   /*建立连接字符串生成器*/SqlConnectionStringBuilder connection = new SqlConnectionStringBuilder(); /*能连上本地服务器，以windows身份登录*/if (LocalServer.Checked == true)          connection.DataSource = &quot;(local)&quot;;         /*以sql身份登录*/ else           connection.DataSource = ServerName.Text;    /*若sql server是express版本*/ if (IsExpressEdition.Checked == true)           connection.DataSource += @&quot;\SQLEXPRESS&quot;;    /*基于当前windows登陆的集成安全验证*/ if(AuthenticateWindows.Checked == true) {      connection.IntegratedSecurity = true; }                        else {     connection.IntegratedSecurity = false;//基于SQL用户的安全验证     connection.UserID = UserName.Text;     connection.Password = UserPassword.Text; }     SqlConnection linkToDB = new SqlConnection(connection.ConnectionString);//新建连接对象     linkToDB.Open();//打开数据库连接         linkToDB.close();//关闭数据库，或用dispose方法，或者用using语句就会自动关闭</code></pre><h2 id="对数据库进行查询、修改、更新、删除等操作："><a href="#对数据库进行查询、修改、更新、删除等操作：" class="headerlink" title="对数据库进行查询、修改、更新、删除等操作："></a>对数据库进行查询、修改、更新、删除等操作：</h2><p><strong>需要用到System.Data.SqlClient类库中的sqlcommand类</strong></p></li></ul><p>方法：</p><ul><li><p>通过一个ADO.NET连接运行SQL查询</p><pre><code>-  创建Sqlcommandr实例- 将其CommandText属性设置为SQL语句- 将其Connection属性设置为一个有效的Sqlconnection实例- 调用这个命令对象的ExecuteNonQuery方法</code></pre></li><li><p>调用一个返回静态结果的SQL Server存储过程</p><pre><code>-  创建Sqlcommandr实例- 将其CommandText属性设置为这个存储过程的名字- 将其Connection属性设置为一个有效的Sqlconnection实例- 调用这个命令对象的ExecuteScalar方法，捕获返回值</code></pre></li></ul><h2 id="代码实例：-1"><a href="#代码实例：-1" class="headerlink" title="代码实例："></a>代码实例：</h2><pre><code>     /*对于对数据库采取操作但不返回存储数据的服务*/   string sqlText = @&quot;UPDATE WorkTable SET ProcessedOn = GETDATE() WHERE ProcessedOn IS NULL&quot;;  SqlCommand dataAction = new SqlCommand(sqlText, linkToDB);  dataAction.ExecuteNonQuery();      /*对于返回单个值的查询*/string sqlText1 = &quot;select count(*) from WorkTable&quot;;SqlCommand dataAction1 = new SqlCommand(sqlText1, linkToDB);int total = (int)dataAction1.ExecuteScalar();//返回单个值      /*对于返回数据行的操作*/      string sqlText2 = &quot;select ID,FullName,ZipCode from Customer&quot;;   SqlCommand dataAction2 = new SqlCommand(sqlText2, linkToDB);   SqlDataReader scanCustomer = dataAction2.ExecuteReader();//一次返回一个数据行   if (scanCustomer.HasRows)       while (scanCustomer.Read());     /*对于访问字段的值，用访问器*/     result = scanCustomer[0];//从起始位置查找      result = scanCustomer[“ID”];//按列名称查找  scanCustomer.NextResult();//若有多个列的返回时     /*查询中存在参数时，用@标识符替代*/     string test = @&quot;update Employee set Salary = @NewSalary where ID = @EmployeeID&quot;；  SqlCommand salaryUpadate = new SqlCommand(test, linkToDB);   paramValue.Value = 50000m;//设置参数的值   salaryUpadate.Parameters.Add(paramValue);//获取参数的值到原来的字符串中    salaryUpadate.Parameters.AddWithValue(&quot;@NewSalary&quot;, 50000m);//另外一种实例化方式，用于简单的参数时    salaryUpadate.ExecuteNonQuery();  /*对于存储过程的查询时*/  string test1 = &quot;dbo.AddLocation&quot;;//创建存储过程的字符串   SqlCommand locationCommand = new SqlCommand(test1, linkToDB);   locationCommand.CommandType = CommandType.StoredProcedure;//把数据库命令的类型设置成存储过程</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;建立与数据库连接&quot;&gt;&lt;a href=&quot;#建立与数据库连接&quot; class=&quot;headerlink&quot; title=&quot;建立与数据库连接:&quot;&gt;&lt;/a&gt;建立与数据库连接:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;需要连接字符串，用到System.Data.SqlClient类库。&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://zy943453722.ink/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term=".net" scheme="http://zy943453722.ink/tags/net/"/>
    
      <category term="c#" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>SQL中的function自定义函数</title>
    <link href="http://zy943453722.ink/SQL%E4%B8%AD%E7%9A%84function%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/"/>
    <id>http://zy943453722.ink/SQL中的function自定义函数/</id>
    <published>2017-05-20T10:06:48.000Z</published>
    <updated>2017-09-17T14:19:37.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL自定义函数"><a href="#SQL自定义函数" class="headerlink" title="SQL自定义函数"></a>SQL自定义函数</h1><ul><li>产生背景（已经有了存储过程，为什么还要使用自定义函数）</li><li>发展历史</li><li>构成</li><li>使用方法</li><li>适用范围</li><li>注意事项</li><li>疑问</li></ul><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="产生背景（已经有了存储过程，为什么还要使用自定义函数）"><a href="#产生背景（已经有了存储过程，为什么还要使用自定义函数）" class="headerlink" title="产生背景（已经有了存储过程，为什么还要使用自定义函数）"></a>产生背景（已经有了存储过程，为什么还要使用自定义函数）</h3><p><strong>与存储过程的区别（存在的意义）：</strong></p><ol><li>能够在select等SQL语句中直接使用自定义函数，存储过程不行。</li><li>自定义函数可以调用其他函数，也可以调用自己（递归）</li><li>可以在表列和 CHECK 约束中使用自定义函数来实现特殊列或约束</li><li>自定义函数不能有任何副作用。函数副作用是指对具有函数外作用域（例如数据库表的修改）的资源状态的任何永久性更改。函数中的语句唯一能做的更改是对函数上的局部对象（如局部游标或局部变量）的更改。不能在函数中执行的操作包括：对数据库表的修改，对不在函数上的局部游标进行操作，发送电子邮件，尝试修改 目录，以及生成返回至用户的结果集。存储过程没有此限制</li><li>函数只能返回一个变量。而存储过程可以返回多个</li></ol><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p><strong>SqlServer 2000之后都支持用户自定义函数</strong></p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>在SQL Server 2000 中根据函数返回值形式的不同将用户自定义函数分为三种类型：标量函数（Scalar Function）、内嵌表值函数（Inline Function）、多声明表值函数（Multi-Statement Function）</p><p>标量函数：标量函数是对单一值操作，返回单一值。能够使用表达式的地方，就可以使用标量函数。像我们经常使用的left、getdate等，都属于标量函数。系统函数中的标量函数包括：数学函数、日期和时间函数、字符串函数、数据类型转换函数等</p><p>内嵌表值函数：内嵌表值函数的功能相当于一个参数化的视图。它返回的是一个表，内联表值型函数没有由BEGIN-END 语句括起来的函数体。其返回的表由一个位于RETURN 子句中的SELECT 命令段从数据库中筛选出来。</p><p><strong><em>作用</em></strong></p><p>多声明表值函数：可以看作标量型和内嵌表值型函数的结合体。它的返回值是一个表，但它和标量型函数一样有一个用BEGIN-END 语句括起来的函数体，返回值的表中的数据是由函数体中的语句插入的。由此可见，它可以进行多次查询，对数据进行多次筛选与合并，弥补了内联表值型函数的不足。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>SQL Server 为三种类型的用户自定义函数 提供了不同的命令创建格式。</p><p>（1） 创建标量型用户自定义函数（Scalar functions） 其语法如下：</p><p>　　各参数说明如下：</p><p>　　owner_name ：指定用户自定义函数的所有者。 </p><p>　　function_name：指定用户自定义函数的名称。database_name.owner_name.function_name 应是惟一的。 </p><p>　　@parameter_name：定义一个或多个参数的名称。一个函数最多可以定义1024 个参数每个参数前用“@”符号标明。参数的作用范围是整个函数。参数只能替代常量，不能替代表 名、列名或其它数据库对象的名称。用户自定义函数不支持输出参数。  </p><p>　　scalar_parameter_data_type：指定标量型参数的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。  </p><p>　　scalar_return_data_type：指定标量型返回值的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。  </p><p>　　scalar_expression：指定标量型用户自定义函数返回的标量值表达式。 </p><p>　　function_body：指定一系列的Transact-SQL 语句，它们决定了函数的返回值。  </p><p>　　ENCRYPTION：加密选项。让SQL Server 对系统表中有关CREATE FUNCTION 的声明加密，以防止用户自定义函数作为SQL Server 复制的一部分被发布（Publish） 。 </p><p> 　　SCHEMABINDING：计划绑定选项将用户自定义函数绑定到它所引用的数据库对象如果指定 了此选项，则函数所涉及的数据库对象从此将不能被删除或修改，除非函数被删除或去掉此选项。应注意的是，要绑定的数据库对象必须与函数在同一数据库中。　　<br>   2）创建内联表值型用户自定义函 数（Inline Table-valued Functions）</p><p>其语法如下：</p><p>　　各参数说明如下：</p><p>　　TABLE：指定返回值为一个表。</p><p>　　select-stmt：单个SELECT 语句，确定返回的表的数据。</p><p>　　其余参数与标量型用户自定义函数相同。</p><p>（3） 创建多声明表值型用户自定义函数</p><p>　　其语法如下：</p><p>　　各参数说明如下：</p><p>　　@return_variable ：一个TABLE 类型的变量，用于存储和累积返回的表中的数据行。 其余参数与标量型用户自定义函数相同。</p><p>　　在多声明表值型用户自定义函数的函数体中允许使用下列Transact-SQL 语句。 赋值语句（Assignment statements）； 流程控制语句（Control-of-Flow statements）； 定义作用范围在函数内的变量和 游标的DECLARE 语句； SELECT 语句； 编辑函数中定义的表变量的INSERT、 UPDATE 和DELETE 语句； 在函数中允许涉及诸如声明游 标、打开游标、关闭游标、释放游标这样的游标操作，对于读取游标而言，除非在FETCH 语句中使用INTO 从句来对某一变量赋值，否则不允许在函数中使用FETCH 语句来向客户端返回数据。此 外不确定性函数（Non-deterministic functions） 不能在用户自定义函数中使 用。所谓不确定性函数是指那些使用相同的调用参数在不同时刻调用得到的返回值不同的函数。</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><h4 id="用户自定义函数不能用于执行一系列改变数据库状态的操作在编写自定义函数时需要注意的："><a href="#用户自定义函数不能用于执行一系列改变数据库状态的操作在编写自定义函数时需要注意的：" class="headerlink" title="用户自定义函数不能用于执行一系列改变数据库状态的操作在编写自定义函数时需要注意的："></a>用户自定义函数不能用于执行一系列改变数据库状态的操作在编写自定义函数时需要注意的：</h4><p><strong><em>对于标量函数：</em></strong></p><ol><li>所有的入参前都必须加@</li><li>create后的返回，单词是returns，而不是return</li><li>returns后面的跟的不是变量，而是返回值的类型，如：int，char等。</li><li>在begin/end语句块中，是return。</li></ol><p><strong><em>内嵌表值函数：</em></strong></p><ol><li>只能返回table，所以returns后面一定是TABLE</li><li>AS后没有begin/end，只有一个return语句来返回特定的记录。<br><strong><em>多语句表值函数：</em></strong></li><li>returns后面直接定义返回的表类型，首先是定义表名，表明前面要加@，然后是关键字TABLE，最后是表的结构。</li><li>在begin/end语句块中，直接将需要返回的结果insert到returns定义的表中就可以了，在最后return时，会将结果返回。</li><li>最后只需要return，return后面不跟任何变量。</li></ol><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>自定义函数不能修改数据库，但它可以调用存储过程，那么在自定义函数中调用一个有修改数据库的操作的存储过程，这个自定义函数能不能执行？</p><p><strong>答：</strong><br>自定义函数只能调用扩展存储过程，但是SQL Server 2008的后续版本将删除该功能，不再支持扩展存储过程，所以应避免在开发中使用扩展存储过程。因此，可以得出结论是：实际开发中，函数不会去调用存储过程，也就无法对数据库进行修改操作了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL自定义函数&quot;&gt;&lt;a href=&quot;#SQL自定义函数&quot; class=&quot;headerlink&quot; title=&quot;SQL自定义函数&quot;&gt;&lt;/a&gt;SQL自定义函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;产生背景（已经有了存储过程，为什么还要使用自定义函数）&lt;/li&gt;
&lt;li&gt;发展历
      
    
    </summary>
    
      <category term="数据库" scheme="http://zy943453722.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL server" scheme="http://zy943453722.ink/tags/SQL-server/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下安装命令的区别</title>
    <link href="http://zy943453722.ink/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://zy943453722.ink/ubuntu下安装命令的区别/</id>
    <published>2017-05-17T09:10:11.000Z</published>
    <updated>2017-09-17T14:05:55.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu下安装命令的区别（dpkg、apt-get、aptitude）"><a href="#ubuntu下安装命令的区别（dpkg、apt-get、aptitude）" class="headerlink" title="ubuntu下安装命令的区别（dpkg、apt-get、aptitude）"></a>ubuntu下安装命令的区别（dpkg、apt-get、aptitude）</h1><p>dpkg绕过apt包管理数据库对软件包进行操作，所以你用dpkg安装过的软件包用apt可以再安装一遍，系统不知道之前安装过了，将会覆盖之前dpkg的安装。</p><p>dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件</p><p>apt会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具</p><p>aptitude与 apt-get 一样，是 Debian 及其衍生系统<em>*</em>能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dpkg          -i                package_name.deb #安装本地软件包，不解决依赖关系</div><div class="line">apt-get     install      package #在线安装软件包</div><div class="line">aptitude   install      pattern #同上</div><div class="line"></div><div class="line">apt-get       install    package   –reinstall   #重新安装软件包</div><div class="line">apitude     reinstall    package      #同上</div></pre></td></tr></table></figure><h2 id="移除软件包"><a href="#移除软件包" class="headerlink" title="移除软件包"></a>移除软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dpkg          -r         package #删除软件包</div><div class="line">apt-get      remove       package #同上</div><div class="line">aptitude     remove    package #同上</div><div class="line"></div><div class="line">dpkg         -P             #删除软件包及配置文件</div><div class="line">apt-get     remove       package –purge      #删除软件包及配置文件</div><div class="line">apitude     purge         pattern #同上</div></pre></td></tr></table></figure><h2 id="自动移除软件包"><a href="#自动移除软件包" class="headerlink" title="自动移除软件包"></a>自动移除软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get autoremove #删除不再需要的软件包</div><div class="line">注：aptitude 没有，它会自动解决这件事</div></pre></td></tr></table></figure><h2 id="清除下载的软件包"><a href="#清除下载的软件包" class="headerlink" title="清除下载的软件包"></a>清除下载的软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">apt-get         clean #清除 /var/cache/apt/archives 目录</div><div class="line">aptitude       clean #同上</div><div class="line"></div><div class="line">apt-get       autoclean #清除 /var/cache/apt/archives 目录，不过只清理过时的包</div><div class="line">aptitude        autoclean #同上</div></pre></td></tr></table></figure><h2 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apt-get source package #获取源码</div><div class="line"></div><div class="line">apt-get          build-dep   package #解决编译源码 package 的依赖关系</div><div class="line">aptitude        build-dep    pattern #解决编译源码 pattern 的依赖关系</div></pre></td></tr></table></figure><h2 id="平台相关"><a href="#平台相关" class="headerlink" title="平台相关"></a>平台相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">apt-cross –arch ARCH –show package 显示属于 ARCH 构架的 package 软件包信息</div><div class="line">apt-cross –arch ARCH –get package #下载属于 ARCH 构架的 package 软件包</div><div class="line">apt-cross –arch ARCH –install package #安装属于 ARCH 构架的 package 软件包</div><div class="line">apt-cross –arch ARCH –remove package #移除属于 ARCH 构架的 package 软件包</div><div class="line">apt-cross –arch ARCH –purge package #移除属于 ARCH 构架的 package 软件包</div><div class="line">apt-cross –arch ARCH –update #升级属于 ARCH 构架的 package 软件包</div></pre></td></tr></table></figure><p><strong><em>注：慎重考虑要不要用这种方法来安装不同构架的软件包，这样会破坏系统。对于 amd64 的用户可能需要强制安装某些 i386 的包，千万不要把原来 amd64 本身的文件给 replace 了。最好只是安装一些 lib 到 /usr/lib32 目录下。同样地，可以用 apt-file 看某个其它构架的软件包包含哪些文件，或者是文件属于哪个包，不过记得最先要用 apt-file –architecture ARCH update 来升级 apt-file 的数据库，在 search 或 show 时也要指定 ARCH。</em></strong></p><h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get       update #更新源</div><div class="line">aptitude     update #同上</div></pre></td></tr></table></figure><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apt-get             upgrade #更新已经安装的软件包</div><div class="line">aptitude           safe-upgrade #同上</div><div class="line">apt-get            dist-upgrade #升级系统</div><div class="line">aptitude          full-upgrade #同</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu下安装命令的区别（dpkg、apt-get、aptitude）&quot;&gt;&lt;a href=&quot;#ubuntu下安装命令的区别（dpkg、apt-get、aptitude）&quot; class=&quot;headerlink&quot; title=&quot;ubuntu下安装命令的区别（dpk
      
    
    </summary>
    
      <category term="操作系统" scheme="http://zy943453722.ink/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="http://zy943453722.ink/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>c语言中struct大小计算</title>
    <link href="http://zy943453722.ink/c%E8%AF%AD%E8%A8%80%E4%B8%ADstruct%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97/"/>
    <id>http://zy943453722.ink/c语言中struct大小计算/</id>
    <published>2017-05-15T21:12:29.000Z</published>
    <updated>2017-09-17T13:57:15.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struct-大小计算"><a href="#struct-大小计算" class="headerlink" title="struct 大小计算"></a>struct 大小计算</h1><p>结构体是一种复合数据类型，通常编译器会自动的进行其成员变量的对齐，已提高数据存取的效率。在默认情况下，编译器为结构体的成员按照自然对齐（natural alignment）条方式分配存储空间，各个成员按照其声明顺序在存储器中顺序存储。自然对齐是指按照结构体中成员size最大的对齐。</p><h2 id="默认对齐方式："><a href="#默认对齐方式：" class="headerlink" title="默认对齐方式："></a>默认对齐方式：</h2><p><strong>在默认对齐方式下，结构体成员的内存分配满足下面三个条件：</strong></p><ol><li>结构体第一个成员的地址和结构体的首地址相同</li><li>结构体每个成员地址相对于结构体首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节（internal adding）。</li><li>结构体总的大小要是其成员中最大size的整数倍，如果不是编译器会在其末尾添加填充字节（trailing padding）。</li></ol><p><strong>下面是一个示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct s1&#123;</div><div class="line">    char ch;</div><div class="line">    int a;</div><div class="line">    double b;</div><div class="line">    char c1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct s2&#123;</div><div class="line">    char ch;</div><div class="line">    int a;</div><div class="line">    double b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;s1的大小： &quot; &lt;&lt; sizeof(struct s1) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;ch的地址偏移是   &quot; &lt;&lt; offsetof(s1, ch) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;a 的地址偏移是   &quot; &lt;&lt; offsetof(s1, a) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;b 的地址偏移是   &quot; &lt;&lt; offsetof(s1, b) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;c1的地址偏移是   &quot; &lt;&lt; offsetof(s1, c1) &lt;&lt; endl;</div><div class="line"></div><div class="line">    cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;s2的大小: &quot; &lt;&lt; sizeof(struct s2) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;ch的地址偏移是   &quot; &lt;&lt; offsetof(s2, ch) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;a 的地址偏移是   &quot; &lt;&lt; offsetof(s2, a) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;b 的地址偏移是   &quot; &lt;&lt; offsetof(s2, b) &lt;&lt; endl;</div><div class="line">    getchar();</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码中 offsetof函数可以得到结构体成员相对于该结构体首地址的偏移量。<br>其运行结果如下图：<br><img src="http://img.blog.csdn.net/20151003143703690" alt="这里写图片描述"></p><p><strong>对于结构体s1来说：</strong></p><ol><li>ch是其第一个成员故其地址和结构体的地址是相同的也就是说偏移量为0；</li><li>a是int型其大小为4个字节，按照条件（2） 结构体每个成员地址相对于结构首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节，所以其地址偏移应该是4，也就说编译器在第一个成员ch后面填充了3个字节。</li><li>b是double型占8个字节，其地址偏移应该是8的整数倍，由于a的地址偏移是4其大小为4个字节，正好b的偏移地址是8，不需要填充字节。</li><li>c1是char型占1个字节，偏移地址是16（b的偏移地址是8大小也是8，中间也没有填充字节）。</li><li>这时成员ch占1个字节后面有3个字节的填充，a占4个字节后面无填充，b占8个字节后面无填充，c1占1个字节，s1总的大小是1+3+4+8+1=17” role=”presentation”&gt;1+3+4+8+1=171+3+4+8+1=17。按照条件（3）结构体总的大小需是其最大成员所占空间的整数倍，其最大的成员b占有8字节，17显然是不符合条件的，所以需要在结构体的末尾填充7个字节，最后结构体总的大小是24字节。<br>结构体s2和s1的成员是非常相似的，唯一的区别是其末尾没有最后7个字节的填充，所以其大小是16个字节，这里用于和s1做对比说明s1末尾的填充字节。</li></ol><h2 id="指定对齐方式"><a href="#指定对齐方式" class="headerlink" title="指定对齐方式"></a>指定对齐方式</h2><p><strong>可以使用#pragma pack(N)来指定结构体成员的对齐方式<br>对于指定的对齐方式，其成员的地址偏移以及结构的总的大小也有下面三个约束条件：</strong></p><ol><li>结构体第一个成员的地址和结构体的首地址相同</li><li>结构体每个成员的地址偏移需要满足：N大于等于该成员的大小，那么该成员的地址偏移需满足默认对齐方式（地址偏移是其成员大小的整数倍）；Ｎ小于该成员的大小，那么该成员的地址偏移是N的整数倍。</li><li>结构体总的大小需要时N的整数倍，如果不是需要在结构体的末尾进行填充。</li><li>如果N大于结构体成员中最大成员的大小，则N不起作用，仍然按照默认方式对齐。</li></ol><p><strong>还是用上述示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#pragma pack(4) //设定按照4字节对齐</div></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="http://img.blog.csdn.net/20151003150901035" alt="这里写图片描述"></p><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ol><li>在使用#pragma pack设定对齐方式一定要是2的整数幂，也就是（1，2，4，8，16，…），不然不起作用的，仍然按照默认方式对齐。</li><li>当结构体中有其他的结构体作为成员时，计算最大成员是不能把结构体成员作为一个整体来计算，要看其每个成员的大小。</li></ol><p>转载自：</p><p>   <a href="http://www.cnblogs.com/wangguchangqing/p/4853438.html" target="_blank" rel="external">http://www.cnblogs.com/wangguchangqing/p/4853438.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;struct-大小计算&quot;&gt;&lt;a href=&quot;#struct-大小计算&quot; class=&quot;headerlink&quot; title=&quot;struct 大小计算&quot;&gt;&lt;/a&gt;struct 大小计算&lt;/h1&gt;&lt;p&gt;结构体是一种复合数据类型，通常编译器会自动的进行其成员变量的对齐，已
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
      <category term="c++" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>const只读变量的内存分配</title>
    <link href="http://zy943453722.ink/const%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://zy943453722.ink/const只读变量的内存分配/</id>
    <published>2017-05-15T17:51:50.000Z</published>
    <updated>2017-09-17T13:56:58.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const只读变量与-define宏定义的常量的内存分配的区别"><a href="#const只读变量与-define宏定义的常量的内存分配的区别" class="headerlink" title="const只读变量与#define宏定义的常量的内存分配的区别"></a>const只读变量与#define宏定义的常量的内存分配的区别</h1><p>编译器通常不为普通 const 只读变量分配存储空间,而是将它们保存在符号表中,这使<br>得它成为一个编译期间的值,没有了存储与读内存的操作,使得它的效率也很高。</p><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define M 3//宏常量</div><div class="line">const int N=5;//此时并未将 N 放入内存中</div><div class="line">......</div><div class="line">int i=N;//此时为 N 分配内存,以后不再分配</div><div class="line">int I=M;//预编译期间进行宏替换,分配内存</div><div class="line">int j=N;//没有内存分配</div><div class="line">int J=M;//再进行宏替换,又一次分配内存</div></pre></td></tr></table></figure><p>const 定义的只读变量从汇编的角度来看,只是给出了对应的内存地址,而不是象#define<br>一样给出的是立即数,所以,const 定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量,存放在静态区),而#define 定义的宏常量在内存中有若干个拷贝。</p><p>#define 宏是在预编译阶段进行替换,而 const 修饰的只读变量是在编译的时候确定其值。</p><p>#define 宏没有类型,而 const 修饰的只读变量具有特定的类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;const只读变量与-define宏定义的常量的内存分配的区别&quot;&gt;&lt;a href=&quot;#const只读变量与-define宏定义的常量的内存分配的区别&quot; class=&quot;headerlink&quot; title=&quot;const只读变量与#define宏定义的常量的内存分配的区
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zy943453722.ink/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c" scheme="http://zy943453722.ink/tags/c/"/>
    
      <category term="c++" scheme="http://zy943453722.ink/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>git与github基本操作</title>
    <link href="http://zy943453722.ink/git%E4%B8%8Egithub%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://zy943453722.ink/git与github基本操作/</id>
    <published>2017-05-10T20:03:31.000Z</published>
    <updated>2017-09-17T13:57:34.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git与github的基本操作"><a href="#git与github的基本操作" class="headerlink" title="git与github的基本操作"></a>git与github的基本操作</h1><h2 id="一、准备："><a href="#一、准备：" class="headerlink" title="一、准备："></a>一、准备：</h2><p>1、git config –global user.name “Firstname Lastname”</p><p>2、git config –global user.email”your_email@example.com”</p><p>3、ssh-keygen -t rsa -C “your_email@example.com”添加ssh，一路回车略过</p><p>4、id_rsa.pub寻找公开公钥复制到github</p><p>5、ssh -T git@github.com 测试ssh是否生效</p><h2 id="二、向远程仓库提交本地文件："><a href="#二、向远程仓库提交本地文件：" class="headerlink" title="二、向远程仓库提交本地文件："></a>二、向远程仓库提交本地文件：</h2><p><strong>方法一：</strong></p><p>1、git clone git@github.com:username/example.git</p><p>2、cd example</p><p>3、git add filename//将文件发到缓存区</p><p>4、git diff HEAD//查看本次提交与之前提交的区别（可省略）</p><p>5、git commit -m “contribtion”//提交文件</p><p>6、git status//查看当前工作树情况（可省略）</p><p>7、git log -p//查看提交日志，并可查看修改的情况（可省<br>略）</p><p>8、git push//直接提交到远程仓库</p><p><strong>方法二：</strong></p><p>1.git init</p><p>2.git add filename//将文件发到缓存区</p><p>3.git diff HEAD//查看本次提交与之前提交的区别（可省略）</p><p>4.git commit -m “contribtion”//提交文件</p><p>5.git status//查看当前工作树情况（可省略）</p><p>6.git log -p//查看提交日志，并可查看修改的情况（可省略）</p><p>7.git remote add origin</p><p>8.git@github.com:usrname/example.git//创建远程仓库</p><p>9.git push -u origin master//把本地当前分支上的内容推送到远程origin库的master分支</p><p><strong>-u参数可以在推送的同时,将 origin 仓库的 master 分<br>支设置为本地仓库当前分支的 upstream(上游)。添加了这个参数,将来<br>运行 git pull命令从远程仓库获取内容时,本地仓库的这个分支就可<br>以直接从 origin 的 master 分支获取内容,省去了另外添加参数的麻烦。</strong></p><p><strong>工作树（当前文件夹） —-&gt; 暂存区 —–&gt;本地仓库 —–&gt;远程仓库</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git与github的基本操作&quot;&gt;&lt;a href=&quot;#git与github的基本操作&quot; class=&quot;headerlink&quot; title=&quot;git与github的基本操作&quot;&gt;&lt;/a&gt;git与github的基本操作&lt;/h1&gt;&lt;h2 id=&quot;一、准备：&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="研发管理" scheme="http://zy943453722.ink/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://zy943453722.ink/tags/git/"/>
    
      <category term="github" scheme="http://zy943453722.ink/tags/github/"/>
    
  </entry>
  
</feed>
