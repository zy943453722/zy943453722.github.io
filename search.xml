<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[彻底弄懂MySQL锁机制]]></title>
    <url>%2Fpost%2F4a00a237.html</url>
    <content type="text"><![CDATA[伟大的人物都走过了荒沙大漠，才登上光荣的高峰。 巴尔扎克 ¶前言 之前对MySQL的锁机制基本是敬而远之，因为设计的太过于复杂，而且现实中还没有遇到并发量很大的情况，故而锁也很少遇到。但随着并发量的增大，我决定要啃一下这块硬骨头！！ ¶锁的分类 按概念分: 悲观锁: 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。 乐观锁: 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。 按粒度分： 行锁：给某个数据记录加锁,实际是对索引加锁 表锁：给某个表加锁 页锁：给某个页加锁 乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。 悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 行锁：锁开销大，粒度小，发生冲突概率低，但并发度高，可能出现死锁。 表锁: 锁开销小，加锁快，不会出现死锁，锁粒度大，但并发度低，发生冲突概率高 页锁：基于行锁和表锁之间 ¶概念前提 MyISAM中读和共享一个意思，写和独占一个意思，这是因为读时就隐式加了共享，写时就隐式加了独占。 而InnoDB中不同，写和排他一个意思，读和共享不一个意思，即读也可以加排他锁，因为select不存在隐式加锁。 MyISAM采取的是读写均隐式加锁。 InnoDB采取的是基于多版本的并发控制协议----MVCC：即读不加锁，读写不冲突。（后面会提到MVCC的概念） ¶MyISAM中的锁 MyISAM中的锁为表锁，其只有两种模式：表共享读锁+表独占写锁。MyISAM不会死锁的原因：Mysql一次获取了sql语句需要的所有的锁，不存在去等待他人释放的问题。 默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。 这样就不适合有大量更新操作和查询操作的情景，会出现&quot;饿死&quot;现象。 可以设置改变读锁和写锁的优先级： 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。 给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。 对于MyISAM的加锁情况与其他用户行为关系，请看下图： ¶隐式加锁 MyISAM在执行读写之前都会自动加锁,隐式加锁的作用如下： 注：因为隐式加锁只涉及一条sql语句所以不存在对加锁方的影响 表共享读锁：不会阻塞其他用户读，但会阻塞其他用户写（也可以说不会阻塞其他用户加共享锁，但会阻塞其他用户加排他锁） 表独占写锁：既会阻塞其他用户读，也会阻塞其他用户写（也可以说既会阻塞其他用户加共享锁，也会阻塞其他用户加排他锁） ¶显式加锁 利用lock table(s) xxxx read/write [local]命令加锁，相当于多条SQL语句形成个整体或者是会话，然后加锁。有点像InnoDB中的事务。显式加锁的作用： 对加锁方而言： 表读锁：当前会话只能执行加锁的表上的select，既不能对加锁的表进行update、insert、delete,也不能执行其他未加锁表上的任何操作 表写锁：当前会话仍不能访问其他未加锁表的任何操作，但可以对加锁表执行select、update、insert、delete操作 对其他并发用户而言： 表读锁：能顺利select，执行update/delete会阻塞，如果开了并发插入功能，且无空隙那么能顺利insert，否则阻塞 表写锁：做任何操作都会阻塞。 ¶并发插入 特别需要提一下的是并发插入，对于MyISAM表存在这个原理。 如果你使用LOCK TABLES显式获取表锁，则可以请求READ LOCAL锁而不是READ锁，以便在锁定表时，其他会话可以使用并发插入。 当concurrent_insert设置为0时，不允许并发插入。 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。 ¶InnoDB中的锁 众所周知，InnoDB中的锁分为行锁和表锁，那下面就分开来谈谈行锁和表锁~~ 对于InnoDB的行加锁情况与其他用户行为关系，请看下图： ¶InnoDB的行锁 InnoDB 实现了以下两种类型的行锁： 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁： 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。 ¶隐式加锁 意向锁(IS/IX)是引擎自己加，不需要用户干预 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X) 对于普通 SELECT 语句，InnoDB 不会加任何锁 注：InnoDB在事务执行过程中，使用两阶段锁协议： 随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁； 锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。 ¶显式加锁 select … lock in share mode //共享锁 select … for update //排他锁 由上图可以看出： 加了共享锁，其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 而加了排他锁，其他 session仍 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁 ¶行锁实现及MVCC 实现方式: InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！ 但是，如果索引是个非主键非唯一索引，那么可能存在两行数据其中的索引列数据一致，这时候加锁就会出现锁冲突！！ MVCC解释： 多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。 （更多MVCC内容请参见MVCC） ¶InnoDB的表锁 值得一提的是，InnoDB的表锁实际是由MySQL Server管理的，而非InnoDB引擎，仅当autocommit=0、innodb_table_locks=1(默认设置)，InnoDB层才知道MySQL加的表锁，因此做表锁时，记得set autocommit = 0 参考资料： https://zhuanlan.zhihu.com/p/29150809 https://segmentfault.com/a/1190000012650596]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP进阶基础知识剖析(五)之通信神器socket]]></title>
    <url>%2Fpost%2Fba6dd70.html</url>
    <content type="text"><![CDATA[人若志趣不远，心不在焉，虽学不成。 张载 ¶前言 上一篇我们讲解了php网络通信中的传输利器cURL，同样的，作为在网络中不可或缺的一部分，socket也是必须要了解的。下面，让我们一同探寻PHP与socket的故事~~~ ¶Socket介绍 Socket通常称之为套接字，用于描述ip和端口，是一个通信链的句柄。应用程序中可以通过其向网络发送请求或应答网络请求。socket不是一个程序，也不是一种协议，而是操作系统提供的传输层与应用层之间的一组抽象API。 ¶PHP与Socket 而在PHP中，由于PHP自身是由c语言开发而成，因此，无法涉及到底层API和系统调用。仅仅是将API进行封装之后的调用。 另外，由于历史的缘故，PHP中的socket不像c/java中那般智能，其作为服务器的效率较低，因此一般不用其作为服务器编程的利器，同时PHP的socket中对I/O复用的封装仅仅实现了select，而现阶段大多数服务器采用的epoll模型并未涉及。如果想要用PHP实现网络的高效通信，可以添加swoole扩展，具体介绍请移步：swoole ¶PHP中Socket原型 原型定义如下： 12345678SOCKET socket(int af, int type, int protocol);该函数共有三个参数：af: 指定应用程序的通信协议族，对于TCP/IP协议族该置为AF_INETtype: 是指创建socket的类型： 包括基于TCP协议的流套接字类型：SOCK_STREAM 基于UDP协议的数据报套接字类型：SOCK_DGRAM 原始套接字类型：SOCK_RAWprotocol:指定使用的通信协议 ¶几种使用socket的方法 使用原始方式创建一个套接字： socket_create(int $domain,int $type,int $protocol) 使用fsockopen方式: fsockopen($host, $port, &amp;errno, &amp;errstr, $timeout) 使用pfsockopen方式： 跟fsockopen定义一致，只不过fsockopen是长连接 使用stream_socket_server/stream_socket_client方式： 以流方式执行socket ¶其他方法 其实其他方法和原始c语言中的socket API大同小异，只不过是做了一层封装而已。 123456789101112131415161718192021socket_bind ( resource $socket , string $address [, int $port = 0 ] ) : bool//绑定函数socket_listen ( resource $socket [, int $backlog = 0 ] ) : bool//监听函数socket_read ( resource $socket , int $length [, int $type = PHP_BINARY_READ ] ) : string//读数据函数socket_recv ( resource $socket , string &amp;$buf , int $len , int $flags ) : int//接收数据函数socket_select ( array &amp;$read , array &amp;$write , array &amp;$except , int $tv_sec [, int $tv_usec = 0 ] ) : int//I/O复用的select函数socket_send ( resource $socket , string $buf , int $len , int $flags ) : int//发送函数socket_set_block ( resource $socket ) : bool//设置阻塞模式socket_write ( resource $socket , string $buffer [, int $length = 0 ] ) : int//写数据函数socket_accept ( resource $socket ) : resource//服务端接受请求函数socket_connect ( resource $socket , string $address [, int $port = 0 ] ) : bool//客户端连接服务器函数socket_close ( resource $socket ) : void//关闭套接口资源函数 ¶代码示例 请移步我的github查看示例代码实现c/s聊天室和smtp客户端]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP进阶基础知识剖析(四)之传输利器curl]]></title>
    <url>%2Fpost%2Fd44b0051.html</url>
    <content type="text"><![CDATA[让自己的内心藏着一条巨龙，既是一种苦刑，也是一种乐趣 雨果 ¶前言 本期来讲述一下web服务中很重要的传输利器cURL，同时讲述它与PHP不得不说的秘密~~~ ¶cURL简介 cURL是使用URL语法传输数据的命令行工具，及客户端向服务器请求的工具，可支持多种协议。可用于编写 网页爬虫、获取web services服务、下载/上传文件等 ¶cURL用法 cURL的用法很多，在此仅仅简单的列出几种比较常用的！ cURL www.baidu.com //不带任何参数，用以获取此网页源码 cURL -o [fileName] www.baidu.com //将网页保存起来，相当于下载 cURL -i www.baidu.com //不仅获取网页源码还获取响应头信息 cURL -L www.baidu.com //使自动跳转的网页跳转到新网址 cURL -v www.baidu.com //显示通信整个过程包括请求头、响应头和资源 cURL -X GET/POST/DELETE/PUT www.baidu.com //通过加-X参数指定获取资源的方法 cURL实例： POST提交表单数据：curl -X POST --data “data=xxx” www.example.com 请求时添加http头：curl --xxx www.example.com(此xxx即为请求头) 登陆认证时：curl --user name:password www.example.com ¶PHP与cURL 讲完了cURL的基础之后，重点讲解一下PHP中的用法。其实作为PHP的扩展之一，cURL的支持还是比较完善的。 相关的方法如下： curl作为http客户端发送http请求： curl_init初始化curl会话 curl_escape对url进行编码 curl_unescape对url进行解码 curl_setopt和curl_setopt_array分别是对curl句柄进行会话设置 curl_exec执行curl会话 curl_close关闭curl会话 curl_getinfo获取一个cURL连接资源句柄的信息 接口并发处理： curl_multi_init 返回一个新的curl批处理句柄 curl_multi_setopt 为curl并行处理设置一个选项 curl_multi_add_handle 往curl批处理中增加一个句柄 curl_multi_remove_handle 移除一个 curl_multi_exec 运行当前批处理中每一个句柄 curl_multi_select 阻塞直到cURL批处理连接中有活动连接(轮询等待) curl_multi_close 关闭批处理 重点是setopt方法中的option参数，常见的如下所示： post方法获取资源相关： CURLOPT_POST: 设置使用post方法 CURLOPT_POSTFIELDS： 设置post方法上传的资源 CURLOPT_HTTPHEADER： 设置提交的http头 cookie相关： CURLOPT_COOKIESESSION：将开启新的一次 cookie 会话 CURLOPT_COOKIEFILE：包含cookie数据的文件 CURLOPT_COOKIEJAR：连接结束后，比如，调用 curl_close 后，保存 cookie 信息的文件 CURLOPT_COOKIE：设置具体cookie 文件传输相关： CURLOPT_URL：设置请求URL CURLOPT_RETURNTRANSFER：设置执行后不直接输出而是以文件流形式返回 CURLOPT_HEADER：是否打印头部信息 CURLOPT_FOLLOWLOCATION：是否支持页面跳转 ¶代码示例 12345678910111213141516171819202122$data = &apos;username=xxxxx&amp;password=xxx&amp;remember=1&apos;;$curl = curl_init();//初始化curl对象//设置urlcurl_setopt($curl, CURLOPT_URL, &quot;http://www.imooc.com/usr/login&quot;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);//设置执行后不直接打印date_default_timezone_set(&apos;PRC&apos;);//设置时区curl_setopt($curl, CURLOPT_COOKIESESSION, 1);//设置cookie和sessioncurl_setopt($curl, CURLOPT_COOKIEFILE, &quot;cookfile&quot;);//cookie保存的文件curl_setopt($curl, CURLOPT_COOKIEJAR, &quot;cookfile&quot;);//cookie读取//cookie是什么curl_setopt($curl, CURLOPT_COOKIE, session_name().&apos;=&apos;.session_id());curl_setopt($curl, CURLOPT_HEADER, 0);//不打印头部信息curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);//支持页面跳转curl_setopt($curl, CURLOPT_POST, 1);//使用post方法curl_setopt($curl, CURLOPT_POSTFIELDS, $data);curl_setopt($curl, CURLOPT_HTTPHEADER, array(&quot;application/x-www-form-urlencoded; charset=utf-8&quot;, &quot;Content_length:&quot;.strlen($data)));curl_exec($curl);curl_close($curl);]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP进阶基础知识剖析(三)之自动加载]]></title>
    <url>%2Fpost%2Fec09671a.html</url>
    <content type="text"><![CDATA[雄心壮志是茫茫黑夜中的北斗星 罗·勃朗宁 ¶前言 这次我们来介绍又一种很有趣的技术，叫做自动加载，也是实现动态引入文件的技术。好吧，话不多说，让我们进入它的世界！ 那么本期要讲述的是关于自动加载的知识 ¶介绍 来源：在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。 自动加载，顾名思义，不是静态的靠include/require引入，而是自动的将需要的类引入进来，这就需要依赖一个神奇的函数： spl_autoload_register ¶spl_autoload_register 该函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 请看下方函数定义！ 123456789101112bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )autoload_function欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。throw此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。prepend如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。void __autoload ( string $class )//这个函数来启动自动加载，但用这个注册的话只能注册一个函数就是它本身，而spl_register_autoload则可以注册任意个自定义的autoload 实际上此函数是注册用户自定义的函数作为__autoload去使用，而此函数相当于建立了一个__autoload类型的队列，而__autoload函数底层就是加载未定义的类 ¶代码示例 下面的示例代码就是很典型的框架中为了引入外部的类而作的自动加载 1234567891011121314151617181920212223242526272829303132public static function autoload($className)&#123; $className = str_replace(&apos;\\&apos;,&apos;/&apos;,ltrim($className,&apos;\\&apos;)); $lastPos = strrpos($className,&apos;/&apos;); $classDir = substr($className,0,$lastPos);//从0开始，长度为$lastPos $classPublic = $classDir.&apos;/public/&apos;.substr($className,$lastPos+1); $classPrivate = $classDir.&apos;/private/&apos;.substr($className,$lastPos+1); if (isset(self::$classMap[$className])) &#123; return true; &#125; else &#123; if (is_file(PROJECT_PATH.&quot;/&quot;.$className.&quot;.php&quot;)) &#123; require_once PROJECT_PATH.&quot;/&quot;.$className.&quot;.php&quot;; self::$classMap[$className] = $className; return true; &#125; if (is_file(PROJECT_PATH.&quot;/&quot;.$classPrivate.&quot;.php&quot;)) &#123; require_once PROJECT_PATH.&quot;/&quot;.$classPrivate.&quot;.php&quot;; self::$classMap[$className] = $className; return true; &#125; if (is_file(PROJECT_PATH.&quot;/&quot;.$classPublic.&quot;.php&quot;)) &#123; require_once PROJECT_PATH.&quot;/&quot;.$classPublic.&quot;.php&quot;; self::$classMap[$className] = $className; return true; &#125; else &#123; $str = &quot;没找到对应的文件\n&quot;; self::exceptionHandle($str); return false; &#125; &#125;&#125;spl_autoload_register(&apos;self::autoload&apos;); ¶其他 SPL Autoload 具体有几个函数： spl_autoload_register：注册 _autoload() 函数 spl_autoload_unregister：注销已注册的函数 spl_autoload_functions：返回所有已注册的函数 spl_autoload_call：尝试所有已注册的函数来加载类 spl_autoload ：_autoload() 的默认实现 spl_autoload_extionsions： 注册并返回 spl_autoload 函数使用的默认文件扩展名。 详细的信息请查看php.net!!]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP进阶基础知识剖析(二)之反射API]]></title>
    <url>%2Fpost%2F561dc37c.html</url>
    <content type="text"><![CDATA[烈火试真金，逆境试强者。 塞内加 ¶前言 既写了魔术方法之后，接下来再来剖析另外一个很有趣的东西--------反射API，这个语法在很多OOPL中都存在，PHP中自然也少不了。接下来我们就进入他的世界！！ 那么本期要讲述的是关于反射API的知识 ¶介绍 反射，顾名思义，直观理解就是根据到达地找到出发地和来源。通俗点说，就是给你一个光秃秃的对象，我们可以通过它知道他所属的类、以及属性、方法、参数甚至注释等一切。。。。。 这是一种动态获取信息以及动态调用对象方法的功能 ¶主要作用 用于自动生成类的定义文档 当需要去实例化一个类，但是这个类完全就是封闭或者说是未知的，你可以创建反射来与映射这个类，通过一系列的探测来最终实例化这个类，尤其还在动态运行中的。 可以做动态代理和做hook实现插件功能 可用于调试和单元测试 ¶详解具体API 首先，反射API的实现是从一个接口实现开始，这个接口叫做Reflector，接口定义如下： 12345interface Reflector &#123;/* 方法 */public static string export ( void )public string __toString ( void )&#125; 其他的基础反射类都是基于此接口实现。请看下图列出了几种常见的反射类： 我们以ReflectionClass类来说明，对于这个类其中提供了很多的方法，下面展示的是官方给出的其中的方法。 ReflectionClass::__construct — 初始化 ReflectionClass 类 ReflectionClass::export — 导出一个类 ReflectionClass::getConstant — 获取定义过的一个常量 ReflectionClass::getConstants — 获取一组常量 ReflectionClass::getConstructor — 获取类的构造函数 ReflectionClass::getDefaultProperties — 获取默认属性 ReflectionClass::getDocComment — 获取文档注释 ReflectionClass::getEndLine — 获取最后一行的行数 ReflectionClass::getExtension — 根据已定义的类获取所在扩展的 ReflectionExtension 对象 ReflectionClass::getExtensionName — 获取定义的类所在的扩展的名称 ReflectionClass::getFileName — 获取定义类的文件名 ReflectionClass::getInterfaceNames — 获取接口（interface）名称 ReflectionClass::getInterfaces — 获取接口 ReflectionClass::getMethod — 获取一个类方法的 ReflectionMethod。 ReflectionClass::getMethods — 获取方法的数组 ReflectionClass::getModifiers — 获取类的修饰符 ReflectionClass::getName — 获取类名 ReflectionClass::getNamespaceName — 获取命名空间的名称 ReflectionClass::getParentClass — 获取父类 ReflectionClass::getProperties — 获取一组属性 ReflectionClass::getProperty — 获取类的一个属性的 ReflectionProperty ReflectionClass::getReflectionConstant — Gets a ReflectionClassConstant for a class’s constant ReflectionClass::getReflectionConstants — Gets class constants ReflectionClass::getShortName — 获取短名 ReflectionClass::getStartLine — 获取起始行号 ReflectionClass::getStaticProperties — 获取静态（static）属性 ReflectionClass::getStaticPropertyValue — 获取静态（static）属性的值 ReflectionClass::getTraitAliases — 返回 trait 别名的一个数组 ReflectionClass::getTraitNames — 返回这个类所使用 traits 的名称的数组 ReflectionClass::getTraits — 返回这个类所使用的 traits 数组 ReflectionClass::hasConstant — 检查常量是否已经定义 ReflectionClass::hasMethod — 检查方法是否已定义 ReflectionClass::hasProperty — 检查属性是否已定义 ReflectionClass::implementsInterface — 接口的实现 ReflectionClass::inNamespace — 检查是否位于命名空间中 ReflectionClass::isAbstract — 检查类是否是抽象类（abstract） ReflectionClass::isAnonymous — 检查类是否是匿名类 ReflectionClass::isCloneable — 返回了一个类是否可复制 ReflectionClass::isFinal — 检查类是否声明为 final ReflectionClass::isInstance — 检查类的实例 ReflectionClass::isInstantiable — 检查类是否可实例化 ReflectionClass::isInterface — 检查类是否是一个接口（interface） ReflectionClass::isInternal — 检查类是否由扩展或核心在内部定义 ReflectionClass::isIterateable — 检查是否可迭代（iterateable） ReflectionClass::isSubclassOf — 检查是否为一个子类 ReflectionClass::isTrait — 返回了是否为一个 trait ReflectionClass::isUserDefined — 检查是否由用户定义的 ReflectionClass::newInstance — 从指定的参数创建一个新的类实例 ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。 ReflectionClass::newInstanceWithoutConstructor — 创建一个新的类实例而不调用它的构造函数 ReflectionClass::setStaticPropertyValue — 设置静态属性的值 ReflectionClass::__toString — 返回 ReflectionClass 对象字符串的表示形式。 那么方法众多，我们也无法一一讲解，大体分为几类：构造函数、打印类信息(export)、获取类信息(getxxx方法)、检查类、创建新类等 对于获取类信息的方法，PHP本身内置了许多诸如get_class_methods、get_class、get_called_class等方法用来快速获取类及方法、属性等信息，但完全没有反射API强大 ¶示例 接下来，我来展示一个反射API使用示例，很多框架中也是如此实现Ioc容器的，可以说反射还是很好用的。 123456789101112131415161718192021222324252627282930313233class Container&#123; protected static $classMap = array(); protected static $container; /** * @return Container * 单例模式获取全局唯一的容器对象 */ public static function getSingleton() &#123; if (self::$container === null) &#123; self::$container = new self(); &#125; return self::$container; &#125; /** * @param $componentName * @param array $params * @return mixed * @throws \ReflectionException * 经典的Ioc容器获取对应类 */ public static function getClass($componentName,$params = []) &#123; if (!isset(self::$classMap[$componentName])) &#123; $ref = new \ReflectionClass($componentName); self::$classMap[$componentName] = $ref-&gt;newInstanceArgs($params);//给构造函数以数组形式传参 &#125; return self::$classMap[$componentName]; &#125;&#125; 分析: 很多经典的框架结构动态实现都是运用了反射API，他们在不用知道具体类如何实现的前提下，根据需要的服务类名，通过反射机制，生成对应的服务对象加入服务容器中，供框架使用。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP进阶基础知识剖析(一)之魔术方法]]></title>
    <url>%2Fpost%2Fedd048d1.html</url>
    <content type="text"><![CDATA[成功的唯一秘诀——坚持到最后一分钟。 柏拉图 ¶前言 笔者近期开始一个专栏----PHP进阶基础知识剖析，专门对于那些比较生僻但很重要的语法内容，核心用法，进阶函数等等进行整理和总结，欢迎大家阅读！ 那么本期要讲述的是关于魔术方法的知识 ¶介绍 魔术方法是PHP中一类很特殊的系统内置方法，将所有以 __（两个下划线）开头的类方法保留为魔术方法。可以看作PHP的“语法糖”。 ¶分类 魔术方法种类繁多，今天也不过多赘述，就简单讲解几种重要的 __set和__get方法 __construct、__destruct、__clone方法 __call和__callStatic方法 __sleep和__wakeup方法 __toString和__debugInfo方法 __invoke方法 __isset和__unset方法 ¶__set和__get方法 作用:用于给对象属性赋值或者取值时，即使这个属性不存在或者这个属性有访问限制，也会能够正确执行。(请看如下示例) 12345678910111213141516class Account&#123; private $user; public function __set($name, $value) &#123; //注：此处name是外来变量不属于成员变量，因此$this-&gt;$name,否则$this-&gt;name $this-&gt;$name = $value; &#125; public function __get($name) &#123; if (!isset($this-&gt;$name)) &#123; $this-&gt;$name = &quot;默认值&quot;; &#125; return $this-&gt;$name; &#125;&#125; 分析： 正如代码所示，有了这两个函数之后，不用向其他语言一样需要创建set方法和get方法获取访问限制的变量，其实本身这两个函数都是public的，只不过这样操作更加简单，属于PHP属性重载的一类。 ¶__construct、__destruct、__clone方法 作用：分别是PHP的构造函数、析构函数和对象复制函数 注意点： 析构函数的执行时间： 1、对象的所有引用都被删除时 2、对象被显式销毁时(可以使用unset，或者赋值NULL，或者改变对象的值) 3、页面加载完成时(此时内存已经被GC机制自动释放，所有实例化的类自然也被销毁，最后实例化的类先销毁，最先实例化的类最后被销毁) 析构函数作用场景： 一个需要循环执行的脚本，这其中可能会涉及到频繁的创建某个对象，它可以将对象打开的一些资源及时的释放，以防止内存溢出或单个进程占用过多内存。 __clone函数： 其是对对象实例进行的浅复制,当调用clone方法是会自动调用此__clone方法，对象内的基本数值类型进行的是传值复制，而对象内的对象型成员变量,如果不重写__clone方法,显式的clone这个对象成员变量的话,这个成员变量就是传引用复制,而不是生成一个新的对象。所有的引用属性仍然会是一个指向原来的变量的引用。 当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 其实，clone方法克隆出来的对象是一个新的对象，除了其中引用属性的成员变量外，其他的与原对象都无关，因此一般解决断开引用属性的成员变量和原对象关系的方法就是在__clone函数中再调用clone方法（如示例） 12345678910111213141516171819202122232425262728293031323334353637383940class SubObject&#123; static $instances = 0; public $instance; public function __construct() &#123; $this-&gt;instance = ++self::$instances; &#125; public function __clone() &#123; $this-&gt;instance = ++self::$instances; &#125;&#125;class MyCloneable&#123; public $object1; public $object2; function __clone() &#123; // 强制复制一份this-&gt;object， 否则仍然指向同一个对象 $this-&gt;object1 = clone $this-&gt;object1; &#125;&#125;$obj = new MyCloneable();$obj-&gt;object1 = new SubObject();$obj-&gt;object2 = new SubObject();$obj2 = clone $obj;print(&quot;Original Object:\n&quot;);print_r($obj);print(&quot;Cloned Object:\n&quot;);print_r($obj2); ¶__call和__callStatic方法 作用：当访问对象一个不可访问的方法或未定义的方法时，__call会被调用。在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。属于方法重载 其实，设置这两个方法的本意是让动态创建变成可能（即根据参数的不同后期创建不同的方法），另外__callStatic还可以实现延迟绑定。（请看下方示例） 1234567891011121314151617181920212223242526class MethodTest &#123; public function __call($name, $arguments) &#123; echo &quot;Calling object method &apos;$name&apos; &quot; . implode(&apos;, &apos;, $arguments). &quot;\n&quot;; &#125; public static function __callStatic($name, $arguments) &#123; //根据参数实现不同的方法后期动态创建 $method = preg_replace(&apos;/^run(\w*)$/&apos;,&apos;$&#123;1&#125;&apos;,$name); return self::$method(); &#125; private static function Test() &#123; echo &quot;test\n&quot;; &#125; private static function date() &#123; echo &quot;date\n&quot;; &#125;&#125;$obj = new MethodTest;$obj-&gt;runTest(&apos;in object context&apos;);MethodTest::runTest(&apos;in static context&apos;); ¶__sleep和__wakeup方法 作用：用于序列化的时候调用，即serialize方法时会自动检测类中是否包含__sleep方法，__sleep方法会先被调用，然后才执行序列化操作，同理，__wakeup方法如果存在类中，会先于unserialize执行 注意： __sleep() 方法常用于提交未提交的数据，或类似的清理操作。但必须返回所有应被序列化的变量名称的数组。 __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。(请看下方示例！) 12345678910111213141516171819202122232425262728293031323334class Connection &#123; protected $link; private $server, $username, $password, $db; public function __construct($server, $username, $password, $db) &#123; $this-&gt;server = $server; $this-&gt;username = $username; $this-&gt;password = $password; $this-&gt;db = $db; $this-&gt;connect(); &#125; private function connect() &#123; $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password); mysql_select_db($this-&gt;db, $this-&gt;link); &#125; public function __sleep() &#123; //返回数组 return array(&apos;server&apos;, &apos;username&apos;, &apos;password&apos;, &apos;db&apos;); &#125; //重新创建连接 public function __wakeup() &#123; $this-&gt;connect(); &#125;&#125;$conn = new Connection();$arr = serialize($conn);$e = unseralize($arr); ¶__toString和__debugInfo方法 作用： 格式化echo输出某个对象时（因为本身对象无法用echo输出），而__debugInfo是在格式化var_dump和print_r输出。 用了这两个方法，可以更好的格式化输出（请看下方代码示例） 123456789101112131415161718192021222324class TestClass&#123; public $foo; public $a; public function __construct($foo) &#123; $this-&gt;foo = $foo; &#125; public function __toString() &#123; return &quot;这个对象的属性是$this-&gt;foo&quot;; &#125; public function __debugInfo() &#123; return [ &apos;foo&apos; =&gt; $this-&gt;foo, &apos;a&apos;=&gt; $this-&gt;a ]; &#125;&#125;$class = new TestClass(&apos;Hello&apos;);echo $class;print_r($class); ¶__invoke方法 作用： 当尝试用函数的方式调用一个对象是触发此方法。（请看下方代码示例！） 123456789class CallableClass &#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5); // int(5)var_dump(is_callable($obj)) // 检测变量内容是否可当作函数调用bool(true) ¶__isset和__unset方法 作用：也属于属性重载的一类，与__set、__get类似 用法：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用,是属于检查属性的用法 当对不可访问属性调用 unset() 时，__unset() 会被调用，是属于删除属性的用法。（请看下方代码示例！） 123456789101112131415161718192021222324252627282930class Person &#123; private $name; private $sex; private $age; public function __get($property_name) &#123; if(isset($this-&gt;$property_name)) &#123; return ($this-&gt;$property_name); &#125; else &#123; return (NULL); &#125; &#125; public function __set($property_name, $value) &#123; $this-&gt;$property_name = $value; &#125; public function __isset($param) &#123; echo &quot;isset()函数测定私有成员时，自动调用&lt;br&gt;&quot;; return isset($this-&gt;$param); &#125; public function __unset($param) &#123; echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; unset($this-&gt;$param); &#125; &#125; $p = new Person(); $p-&gt;name = &quot;LinDD&quot;; echo var_dump(isset($p-&gt;name)).&quot;&lt;br&gt;&quot;; echo $p-&gt;name.&quot;&lt;br&gt;&quot;; unset($p-&gt;name); echo $p-&gt;name;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http历史及请求报文和响应报文]]></title>
    <url>%2Fpost%2Fcc12a58f.html</url>
    <content type="text"><![CDATA[书籍是人类进步的阶梯 高尔基 ¶前言 笔者最近看了&lt;&lt;图解HTTP&gt;&gt;这本书，了解了web开发人员需要了解的http协议的基础知识，并且在此整理一下重点的知识。 ¶http的历史 http在1990年面世，但最开始并没有作为正式的标准建立。这时候的http，更多的被称为HTTP/0.9版本。 之后在1996年的5月，http被正式作为标准公布，称为HTTP/1.0。 之后在1997年的1月，公布了HTTP/1.1是目前主流的HTTP协议版本。 目前HTTP/2.0正在制定中，但是仍然没有成为主流的版本。 ##http请求和响应 ¶http请求 请求报文 = 请求方法 + 请求URI + 请求协议版本 + 可选择的首部字段 + 内容实体 = 报文首部 + 空行(CR+LF) + 报文主体 请求行 = 请求方法 + 请求URI + 请求协议版本 可选择的首部字段 = 请求首部 + 通用首部 + 实体首部 + 其他 如图： ex: 123456789101112GET / HTTP/1.1 请求行Host: hackr.jp User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0.8Accept-Language: ja,en-us;q=0.7,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: keep-aliveIf-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMTIf-None-Match: &quot;45bae1-16a-46d776ac&quot;Cache-Control: max-age=0//空行(CR+LF) ¶http响应 响应报文 = 协议版本 + 状态码 + 原因原语 + 可选择的首部字段 + 内容实体 = 报文首部 + 空行(CR+LF) + 报文主体 状态行 = 协议版本 + 状态码 + 原因原语 可选择的首部字段 = 响应首部字段 + 通用首部字段 + 实体首部字段 + 其他 如图: ex: 1234567HTTP/1.1 200 OK 响应行Date: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html//空行&lt;html&gt; 内容实体...... ¶首部字段 首部字段包括通用首部字段、请求首部字段、响应首部字段、实体首部字段和其他。 通用首部字段：General Header Fields ​ 请求报文和响应报文两方都会使用的首部。 请求首部字段：Request Header Fields ​ 客户端发送请求报文给服务器时使用，补充了请求的附加内容，客户端信息，响应内容相关的优先级等信息 响应首部字段：Response Header Fields ​ 服务器向客户端返回响应报文时使用的首部，补充响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段：Entity header Fields ​ 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。 ¶http可使用的方法 GET方法： 用来请求访问被URI识别的资源。指定的资源经服务器解析处理后返回响应内容。 POST方法: 用来传输实体的主体，但其主要目的并不是获取响应的主体内容。 PUT方法： 用来传输文件，但HTTP/1.1的PUT方法本身不带验证机制，存在安全性问题，因此一般不使用。 HEAD方法： 用来查看URI指定的资源的有效性，仅返回响应头部，不返回实体主体。 DELETE方法： 用来删除请求URI指定的资源，与PUT方法相反，因此也一般不使用。 OPTIONS方法： 用来询问针对请求URI指定的资源支持的方法。 TRACE方法： 用来追踪路径，将客户端请求怎么发往服务器经过的路径反馈回去。 CONNECT方法： 此方法主要是与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议将通信内容加密后传输到隧道。 ¶http状态码 状态码的类别： 具体例子如下: 200 OK 表示从客户端发来的请求在服务器端被正常处理了。 204 No Content 表示服务器接收成功受理，但是返回的响应报文中不含实体的主体部分。 206 Partial Content 表示客户端请求一定的范围内容，然后获取成功返回状态 301 Moved Permanently 表示永久性重定向，所请求的资源已经分配到了新的URI，以后资源都指向这个URI 302 Found 表示临时性重定向，希望用户本次使用新的URI，实际运用中允许POST方法改成GET方法。 303 See Other 也表示临时性重定向，但指定客户端采用GET方法。 304 Not Modified 该状态码表示发送附带条件时,不满足条件，则返回这个。 307 Temporary Redirect也表示临时的重定向，且不会从POST变为GET. 400 Bad Request 表示请求报文出错 401 Unauthorized 表示发送的请求需要有通过HTTP认证信息。 403 Forbidden 该状态码表示对请求资源的访问被服务器拒绝了。 404 Not Found 服务器上无法找到请求的资源。 500 Internal Server Error 表示服务器端在执行请求时发生了错误。 503 Service Unavailable 表示服务器暂时处于超负载或正在停机维护，现在无法处理请求。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[划分子网与构造超网]]></title>
    <url>%2Fpost%2F40d97749.html</url>
    <content type="text"><![CDATA[¶前言 笔者上一篇分享了tcp层可靠传输和流量控制的4种协议，这次来分享一下ip层的重要知识，也就是划分子网和构造超网。 ¶前提 在讲述划分子网和构造超网之前，让我们先来回忆一下ip地址的划分。 1ip地址::=&#123;&lt;网络号&gt;,&lt;主机号&gt;&#125; ip地址的划分以下几个特点： ip地址划分为A类、B类、C类、D类、E类5种 A、B、C类地址都是常用的单播地址，而D类是多播地址，E类地址保留为以后用 ip地址都是32位的二进制代码，为提高可读性，IP地址每8位插入一个点，叫做点分十进制表示法 一般的，A类地址第一位二进制是0，B类地址前两位是10，C类地址前三位是110，D类地址前4位是1110，E类地址前4位地址是1111 A类地址前8位为网络号，7位可用，但7位全0（0.x.x.x)是个保留地址，表示本网络，7位全1(127.x.x.x)也是个保留地址，作为本地回环测试。因此可以指派2^7-2地址最为网络地址。 A类地址的主机号24位，但是全0(x.0.0.0)为网络地址即网关(网段)地址，全1(x.255.255.255)为该网段内的所有的主机 B类地址前16位为网络号，14为可用，但是14位中全1(128.0.0.0)不指派,因此B类地址可以指派网络数为2^14-1 B类地址主机号16位，全0，全1不指派，因此主机数为2^16-2 c类地址前24位为网络号，21位可用，但是21位全0(192.0.0.x)不指派，因此C类地址可以指派网络数为2^21-1 C类地址主机号8位，全0，全1不指派，因此主机数为2^8-2 特殊的不使用的ip地址 ¶划分子网 ¶背景 由于ip地址空间利用率低，ip地址不够用等原因，急需要一种措施解决，因此出现了划分子网。 ¶概念 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网，因此这个子网地址并不是真是网络通信中用到的外部地址，而是一个内部地址，因此这个单位对外仍表现为一个地址，即网关地址。 12ip地址 ::= &#123;&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;&#125;即从主机号拿出一部分作为子网号。 ¶实现 要想在路由转发时找到相应的子网，需要用到子网掩码。子网掩码是一个网络或一个子网的重要属性。 ![图2](划分子网与构造超网/1.png 子网划分举例： ¶求网络地址 网络地址: 即网关地址，一个单位千千万万台主机对外的地址 求法: ip地址 和 子网掩码 相与。 ex:已知ip地址为141.14.72.24，子网掩码为255.255.192.0，求网络地址(即子网地址)？ 解答： 将十进制转化成二进制，逐位相与。 ip十进制：141 . 14 . 72 . 24 ip二进制：10001101. 00001110 . 01001000. 00011000 子网掩码：11111111. 11111111 . 00000000 因此相与可得 网络地址二进制：10001101. 00001110. 01000000. 00000000 网络地址十进制：141.14.64.0 求主机号： 首先观察子网掩码与默认子网掩码的区别，比如此题，这是B类的ip，子网掩码默认应为255.255.0.0，而实际为255.255.192.0，即拿出了一部分主机号作为子网号。 从子网掩码二进制可以看出第三节前2位与默认子网掩码不同，那么也就是拿出了2位主机号作为子网号，子网号2位，主机号14位。 由ip地址可以看出主机号为001000.00011000，再化成10进制。 ¶子网规划 例题 ¶构造超网(无分类编址CIDR) ¶背景 划分子网缓解了一定的困难，但是ipv4地址眼看就要耗尽，人们研究出了无分类域间路由选择CIDR。 ¶概念 CIDR使ip地址从三级编址再次变为二级编址，但是无分类的二级编址，不分A.B.C类。记法为： 12IP地址 ::=&#123;&lt;网络前缀&gt;，&lt;主机号&gt;&#125;a.b.c.d/x x为地址中网络部分的位数，32-x为主机位数。 此外，CIDR还采用斜线/记法,然后写上网络前缀所占的位数。 ¶应用 由CIDR的某个IP地址可以看出子网掩码。 ex:128.14.35.7/20 隐含的指出子网掩码中有20个1，由观察可知此地址是B类地址，默认子网掩码为255.255.0.0，32-20=12位主机号，则4位主机号，因此子网掩码为255.255.240.0 使用CIDR地址块后，网络路由器中的路由表项可以表示很多个传统IP地址的路由信息，相当于把若干个网络合并为一个超网来进行路由，这种地址的聚合称为路由聚合，也称为构造超网.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp可靠传输和流量控制的4种协议的演变史]]></title>
    <url>%2Fpost%2Fed84d9d4.html</url>
    <content type="text"><![CDATA[¶前言 学习了计算机网络之后，发现很多基础知识其中的奥秘是经过前人一步步探索得来的，故而搜索了很多的资料，在这里用几篇博文进行总结。 首先要说到的就是tcp可靠传输和流量控制的4种协议，这4种协议从无到有，从最初的单工停等协议(停止等待ARQ协议)到连续ARQ协议、选择重传ARQ协议，直到最终的滑动窗口协议，经过了一系列的演变过程。本博文就来浅析一下它们的区别和演变过程。 ¶单工停等协议 ¶定义 即发送方每次发送完一个分组(此处可能是tcp报文也可能是MAC帧)就停止发送，等待接收方的确认，只有在收到确认之后才能够再发送下一个分组。 ¶具体描述 工作原理: 发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。(利用超时计时器计时) 在等待过程中，发送点停止发送新的数据包。 当数据包没有成功被接收点接收时候，接收点不会发送ACK.这样发送点在等待一定时间后，重新发送数据包。 反复以上步骤直到收到从接收点发送的ACK. 原理图如下: 如图1即在无差错的情况下，A发送，B接收，只有A收到B的确认时才可以发送下一个分组。如图2即出现差错时利用的一种机制叫做超时重传机制，B没有收到A的报文，A也没收到来自B的确认报文，经过一个设定时间后，超时计时器到期，那么就要重传。 如图3即当A的发送分组没有差错和丢弃，但是B的确认分组出现差错，那么A收不到确认也就无法判断是确认出错还是发送分组出错,因此B需要丢弃当前接收的分组，等待超时计时器到期A重新发送，而后接收。 如图4即B的确认没有出错或者丢失，只是因为信道拥塞导致延时到达，因此A无法收到确认y而是需要重新发送之前的发送分组。 ¶缺点 这个协议的缺点是较长的等待时间导致低的数据传输速度。在低速传输时，对连接频道的利用率比较好，但是在高速传输时，频道的利用率会显著下降。 ¶连续ARQ协议 ¶定义 为了克服停止等待协议需要长时间等待的缺点，故而出现了连续ARQ协议，它是指发送方维护着一个窗口,这个窗口中不止一个分组,有好几个分组,窗口的大小是由接收方返回的win值决定的,所以窗口的大小是动态变化的,只要在窗口中的分组都可以被发送,这就使得TCP一次不是只发送一个分组了,从而大大提高了信道的利用率.并且它采用累积确认的方式,对于按序到达的最后一个分组发送确认。 ¶具体描述 原理： 如图可知发送方维护一个5分组大小的窗口，只有收到接收方的一个确认后才将窗口向前挪动。 但是接收方由于累计确认方式,虽然一次性仍然只能接收一个确认分组，但是发送方不必等待接收方确认便可以再次发送。因此，接收方可以在收到几个分组之后，对按序到达的最后一个分组发送确认，这就表示到这个分组之前的所有分组都正确收到了。 重传机制： 采用回退N机制(Go-back-N)即GBN,表示凡是被发送出去尚未被确认的分组都放在发送方提供的较大的缓冲区内，若得到确认则取出。当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧。其中利用超时计时器，若在规定时间内没有收到对应的应答帧，或者累计的应答帧，那么就说明出错了。 ¶缺点 虽然连续ARQ的链路效率大大提升，但是相应的需要更大的缓冲空间，且接收方窗口大小总是1，浪费很多链路的带宽。 ¶选择重传ARQ协议 ¶定义 发送方据一个指定大小的窗口持续发送若干分组，即使发送过程中丢失分组，也会继续发送。和Go-back-N ARQ不一样，接收进程在出错后还是继续接收和确认帧。 ¶具体描述 基本原理： 如果一个发送的帧没有到达接收方，发送方继续发送后面的帧，直到它填满发送窗口 。接收方持续用接收的帧填充它的接收窗口，并且每次回复一个带有序列号的ACK帧。一旦发送窗口所有帧都发送了 ，发送方重新发送的帧号与ACK不对应的帧，然后继续。 如图可知在2号分组出错时，继续发送其他的分组，接收方同时也接收其他的分组，但是并不提交给上层，只有等待重传的分组到达之后，再按序提交给高层。 注意： 接收方窗口大小与发送方要相同，并且最大的窗口值取最大序列号的一半。 ¶缺点 通信信道的利用率不高，也就是说，信道还远远没有被数据比特填满。 是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送数据包来纠正错误的方法也严重的影响了它的传输速度。 ¶滑动窗口协议 ¶定义 滑动窗口协议实际是选择重传ARQ的特殊情况。 ¶前提 TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收)。 发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区； 发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据； 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送； ¶具体实现 原理图： 分析图中可以看出： 初始时发送窗口前沿是0，后沿也是0，因为前沿是指下一发送的序号，而后沿是指下一应答序号。 而初始时接收窗口前沿是1，后沿是0，因为前沿和后沿之间的部分是指下一期望接收的序号。 发送方前沿是发送完一个分组后就移动，后沿是收到接收确认分组之后才移动。 接收方的前后沿同时移动，当接收到一个分组之后就向后移动。 ¶4种协议的比较 单工停等 连续ARQ 选择重传ARQ 滑动窗口 应答帧是否需要编号 否 是 是 是 分组是否按序 是 是 是 是 发送窗口大小 1 &gt;1 &gt;1,最大值为最大确认序列号的一半 同选择重传ARQ 接收窗口大小 1 1 &gt;1,同发送窗口 同选择重传ARQ ¶参考资料： http://blog.csdn.net/guoweimelon/article/details/50879588 http://blog.csdn.net/wbw1985/article/details/4879224 http://pmghong.blog.51cto.com/3221425/1242470]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中静态类、抽象类和接口类的区别]]></title>
    <url>%2Fpost%2Fa888efb7.html</url>
    <content type="text"><![CDATA[¶前言 最近笔者学习了php的基本知识，其基本语法像极了c语言，但是取消了指针等特性，且操作起来更加简便。下面就浅析一下php面向对象中的特性：静态类、抽象类和接口以及很好用的代码复用技术trait。 ¶静态类 ¶静态类定义： 类中含有static修饰的方法或者属性的类。 ¶静态类的特性和易错点 静态类中的成员不用实例化对象访问。用类名：：属性名/方法名 访问。 实例化的对象只能访问静态方法，不可访问静态属性。 继承时子类可以继承父类的公有和受保护的方法和属性。 可以说静态方法和属性不属于这个类，所以不能用自引用指针$this去引用，但却可以通过self或者parent访问。 ¶实例 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Foo&#123; public $my = &quot;zy&quot;; public static $my_static = &apos;foo&apos;;//初始化附常量 public function staticValue() &#123; echo $this-&gt;my; //echo $this-&gt;my_static;这些属性不属于类 return self::$my_static; &#125; public static function handle() &#123; //$this-&gt;$my_static;静态方法中没有$this这个伪变量 echo &quot;这是静态变量\n&quot;; &#125; protected static function func() &#123; echo &quot;protected static\n&quot;; &#125;&#125;class Bar extends Foo&#123; public function fooStatic()&#123; return parent::$my_static; &#125; public function funn() &#123; echo self::func().&quot;\n&quot;;//继承了 &#125;&#125;echo Foo::$my_static.&quot;\n&quot;;echo Foo::handle().&quot;\n&quot;;$foo = new Foo();//echo $foo-&gt;$my_static.&quot;\n&quot;;//不可用对象直接访问静态属性echo $foo-&gt;handle().&quot;\n&quot;;//用对象可直接访问静态方法echo $foo-&gt;staticValue().&quot;\n&quot;;echo Bar::$my_static.&quot;\n&quot;;$bar = new Bar();echo $bar-&gt;fooStatic().&quot;\n&quot;;echo $bar-&gt;handle();$bar-&gt;funn();?&gt; ¶抽象类 ¶抽象类的定义 *** 被abstract修饰的类。*** ¶抽象类的特性和易错点 抽象类不可被实例化 任何一个类，若其中至少有一个抽象方法，那么该类就必须定义为抽象类，类中可以有非抽象的方法或属性。 抽象方法只声明其调用方式，不定义具体功能。 继承某个抽象类后，其子类必须实现所有的抽象方法，且不论函数名、参数都不能改变，但是继承访问控制可以一致或更宽松。 若子类继承的父类抽象方法中参数列表是可选参数，那么也可以与父类参数个数不一致，即子类可以有个默认参数列表。 ¶实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpabstract class AbstractClass&#123;//此类不可实例化对象 abstract protected function getValue(); abstract protected function prefixValue($prefix);//只声明，不作具体实现 abstract public function pre($han); const i = 12; public $a = 13; public function printOut() &#123; echo $this-&gt;a.&quot;\n&quot;; echo $this-&gt;getValue().&quot;\n&quot;; &#125;&#125; class ConcreteClass1 extends AbstractClass&#123; protected function getValue() &#123; return &quot;ConcreteClass1&quot;;//实现具体实现，必须保持一致 &#125; public function prefixValue($prefix) &#123; return &quot;$prefix.ConcreteClass1&quot;; &#125; public function pre($han,$ren = &apos;a&apos;) &#123; echo $han.$ren.&quot;\n&quot;; &#125;&#125;class ConcreteClass2 extends AbstractClass&#123; public function getValue() &#123; return &quot;ConcreteClass2&quot;; &#125; public function prefixValue($prefix) &#123; return &quot;&#123;$prefix&#125;ConcreteClass2&quot;; &#125; public function pre($han,$ren = &apos;a&apos;) &#123; echo $han.$ren.&quot;\n&quot;; &#125;&#125;$class1 = new ConcreteClass1;//继承抽象类的类才可以实例化$class1-&gt;printOut();echo $class1-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;$class1-&gt;pre(&quot;zy&quot;);//可以打印出默认的参数$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;echo AbstractClass::i;//同样可以输出常量，无法输出变量?&gt; ¶接口 ¶接口的定义 *** interface修饰的一个特殊的抽象类，但不是类。*** ¶接口特性和易错点 接口定义的所有方法都是空的 接口中的所有方法都是公有的，这是接口的特性 接口的定义使用interface，但是接口的实现就要用到implements,实现接口的实际是类 接口实现过程中要实现全部定义的接口 接口可以继承，用extends实现，与接口的实现不是一个意思,继承之后用类实现时要全部实现 接口中可以声明常量但是不可声明变量 可以说接口是特殊的抽象类，他里面的方法也是不实现功能的抽象类但是为了方便，不写abstract还有定义成interface而非类 一个类虽然是单继承的，但是一个类可以实现多个接口,多个接口之间用逗号隔开 ¶实例 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpinterface iTemplate &#123; const name = &quot;ha&quot;; public function setVariable($name,$var);//必须是公有的方法 public function getHtml($template); &#125; interface inTel&#123; public function handle(); &#125; //一个接口类可以实现多个定义的接口 class Template implements iTemplate,inTel&#123; private $vars = array(); public function setVariable($name,$var) &#123; $this-&gt;vars[$name] = $var; &#125; public function getHtml($template) &#123; foreach($this-&gt;vars as $name =&gt; $value) &#123; $template = str_replace($name,$value,$template);//把字符串template中的name字符换成value &#125; return $template; &#125; public function handle() &#123; echo &quot;handle things\n&quot;; &#125; &#125;//用一个类去实现接口 //$te = new iTemplate();因为是一种特殊的抽象类，因此也是不能实例化对象的 $tel = new Template(); $tel-&gt;setVariable(&apos;zy&apos;,&apos;人才&apos;); echo $tel-&gt;getHtml(&apos;zyzsddw&apos;).&quot;\n&quot;; $tel-&gt;handle(); echo iTemplate::name;//输出接口中定义的常量 ?&gt; ¶trait ¶trait的定义 Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制 ¶trait的特性和易错点 trait是一种代码复用技术，相当于一种池技术，把好多功能(方法)写在其中，用的时候调用即可。可代替继承技术 他的调用优先级高于继承后的同名方法的优先级 它本身无法进行实例化 可以同时有多个trait，类中use声明时用逗号隔开 trait也可以使用多个trait作为成员 不可以声明静态成员，可在方法中定义静态变量 ¶实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass Base&#123; public function sayHello()&#123; echo &apos;hello&apos;; &#125;&#125;trait mysay&#123; public function mysays() &#123; echo &quot;this is my says\n&quot;; &#125;&#125;trait SayWorld&#123;//声明方式相当于一个类 //static public $c = 1;除非定义在方法中 public $name = &quot;zy&quot;; public function sayHello()&#123; parent::sayHello(); echo &quot;World\n&quot;; &#125; public function says()&#123; echo &quot;zwdfw\n&quot;; &#125; public static function func() &#123; static $c = 1; echo &quot;$c.this is static\n&quot;; &#125; protected function sayno() &#123; echo &quot;sayno&quot;.&quot;\n&quot;; &#125; abstract public function getworld();//允许定义抽象方法&#125;class Myhello extends Base&#123; use SayWorld,mysay;//用这种方式调用trait,相当于把所有的方法都继承到了 public function getworld() &#123; echo &quot;nihao world\n&quot;;//使用了trait就要实现抽象方法 &#125;&#125;$foo = new Myhello();$foo-&gt;sayHello();//优先级高于继承来的同名方法$foo-&gt;says();//随意调用其中的方法//$foo-&gt;sayno();//私有方法和受保护的方法无法从trait中获取$foo-&gt;func();$foo-&gt;mysays();mysay::mysays();//无法实例化trait的对象访问，可以用trait名::方法/变量的形式访问echo $foo-&gt;name.&quot;\n&quot;;//echo $foo-&gt;c.&quot;\n&quot;;?&gt; ¶这四种php中oo特性的代表的区别 静态类 抽象类 接口 trait 是否可以实例化对象 是 否 否 否 类外访问方式 1.类名::属性/方法 2.对象名-&gt;方法 子类继承实现，实例化子类，子类对象调用属性/方法 子类implements实现，子类实例化对象调用属性/方法 类中use实现，类外实例化对象调用属性/方法 方法是否立即实现 类内外都可以 子类实现 子类实现 类内外都可以 方法的访问控制 都可以 抽象方法公有或者受保护，普通方法都可以 均为公有 都可以 实现方式 类内类外都可以 子类继承实现 子类继承实现 内部实现 是否可以声明常量/变量 都可以 都可以，但变量无法类外访问 常量可以，变量不可以 都可以]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探寻psr标准]]></title>
    <url>%2Fpost%2Fb09a0ec3.html</url>
    <content type="text"><![CDATA[¶前言 笔者学习symfony框架，看源码之时，发现好多函数带有psr的后缀，心想这是个什么东东。。。于是乎google了一番，发现这正是“心仪已久”的PHP开发的标准规范啊！！！ 但是好多东西在对应的官方文档PSR标准规范文档都有，因此笔者在此只做代码的示范，用代码来表示规范。 ¶简介 PSR 是 PHP Standard Recommendations 的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。 目前已表决通过了 6 套标准，已经得到大部分 PHP 框架的支持和认可。 标准目录如下： ¶详解 ¶基本代码规范和编程风格规范 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php /** * psr标准中的大部分语言规范 * * @author zy *///php代码文件必须以这个标签或者&lt;?= 开始//每行的字符数控制在80~120之间namespace Vender\Package;//命名空间块后都有一个空行，命名空间和子命名空间必须和相应的文件基目录(文件绝对路径)匹配。namespace Symfony\Component\Routing;//完整的类名必须有个顶级命名空间和一个或多个子命名空间，末尾的类名与对应的.php文件同名use Symfony\Component\Routing\Route;use FooInterface;//use语句后面也要有一行空行,use务必声明在namespace之后//类名必须遵循StudlyCaps大写驼峰命名法即多个单词组成名字每个单词首字母大写class FooFunction extends Bars implements FooInterface, \ArrayAccess, \Countable&#123;//多实现可以多行显示，但是要有缩进，且每个接口自成一行 //类的前后花括号均自成一行 public $superStar;//每个属性都要添加访问修饰符 public $commonPeople;//类的普通属性用哪种命名方式均可，但要统一 protected $files = null;//null,true,false这些关键字都小写 const MAX_COUNT = 120;//const定义的变量必须大写且单词间用下划线分隔 //方法名遵循camelCase式的小写驼峰命名法即多个单词组成名字时首单词小写，之后的每个单词首字母大写 public function sampleFunction($a, $b = null) &#123;//方法的前后花括号也均自成一行 //缩进时不能使用tab要用4个空格进行缩进 if ($a === $b) &#123; //控制结构诸如if-else，switch-case，while，for，foreach等等书写时这些关键字后要有一个空格 //前括号之前也要有一个空格，且前括号在关键字同一行，后括号自成一行 bar(); &#125; elseif ($a &gt; $b) &#123;//变量与运算符之间要有空格 $foo-&gt;bar($arg1); &#125; else &#123; BazClass::bar($arg2, $arg3);//方法的参数每个逗号后必须要有一个空格，有默认值的放到参数列表末尾 &#125; &#125; //参数列表可以单独一行,结束括号必须和方法前花括号自成一行,final、abstract必须在访问修饰符前面，static在访问修饰符之后 final public static function aVeryLongMethod( ClassTypeHint $arg1, &amp;$arg2, array $arg3 = [] )&#123; switch ($expr) &#123;//case相对switch要有缩进 case 0: echo &apos;xxxxxxx&apos;;//执行语句相对case也要缩进 break; case 1://遇到这种case没有break的直穿语句，要有no break的注明 echo &apos;second&apos;; //no break case 2: case 3: echo &apos;third&apos;; break; default: echo &quot;default case&quot;; break; &#125; &#125; public function simpleFunction() &#123; while ($exp) &#123;//同样的诸如do-while，try-catch控制结构需要相同的结构 echo &apos;zzz&apos;; &#125; $clouseWith = function ($arg1, $arg2) use ($var1, $var2) &#123; /*对于闭包函数也就是匿名函数，function后要有一个空格，use的前后都要有一个空格，并且前括号要和关键字在同一行， 但后括号单独成行*/ &#125;; &#125;&#125;/*诸如此类产生副作用的操作，ex： 生成输出 直接的 require 或 include 连接外部服务 修改 ini 配置 抛出错误或异常 修改全局或静态变量 读或写文件等的操作不能和声明类、函数等在同一个php文件下include &quot;file.php&quot;;echo &quot;&lt;html&gt;\n&quot;;ini_set(&apos;error_reporting&apos;,E_ALL);*///纯php代码文件最后必须省略“?&gt;”标签//同时php文件最后必须要有一行空行作为结束 ¶其他规范 其他规范都是在框架或者项目中需要用的诸如日志、自动加载、缓存规范。因此就不在此赘述，贴出官方的规范：https://psr.phphub.org/]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC之管道通信的dup和dup2函数]]></title>
    <url>%2Fpost%2Fc37ff4aa.html</url>
    <content type="text"><![CDATA[¶前言： 前面笔者详细分析了网络编程中重要的通信技术：I/O复用技术,接下来的几篇文章，我将重点来分析一下网络编程中另外一个重要的技术，即：管道通信技术。 ¶dup、dup2函数基础 由于利用管道实现进程间通信，是通过创建2个文件描述符，但是初始化文件描述符都是随机的，或者说是从可用的文件描述符中去除，并与相对应的文件建立映射关系，如果我们想要将管道的两头与其他流相关，或者说重定向一个文件描述符，那么，我们就需要dup和dup2函数。 可以说，这两个函数的作用就是： 1.重定向文件描述符 2.复制文件描述符 ¶dup函数： 12#include&lt;unistd.h&gt;int dup(int fd);//fd为文件描述符，失败返回-1 dup函数创建一个新的文件描述符，该文件描述符和原有文件描述符指向相同的文件、管道或者网络链接，并且此fd总是系统当前可用的最小的文件描述符。 ¶dup2函数： 123#include&lt;unistd.h&gt;int dup2(int fd1, int fd2);//fd1是指需要重定向的文件描述符，fd2是定向到的文件描述符。失败返回-1 dup2函数中fd2不做原本的工作，而改做fd1的工作，若此fd2文件描述符已经存在，则需要关闭他，再执行。 需要注意的是：这两个函数创建的文件描述符并不继承原有的文件描述符的属性(ex：close_on_exec,non-blocking等)，因为每个文件描述符都有一套文件描述符标志，新描述符执行时关闭(close_on_exec)标志总是由dup和dup2函数执行。只继承他的同一文件状态标志(读、写、添加等)。 其实对于文件描述符在内核中的存储有必要提一下： 每个进程在进程表中都有一个记录项，每个记录项中有一张打开文件描述符表，可将视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是： (1) 文件描述符标志(close_on_exec,close_on_exec是一个进程所有文件描述符的标记位图，每个比特位代表一个打开的文件描述符，用于确定在系统调用execve()时需要关闭的文件句柄)。 (2) 指向一个文件表项的指针。 内核为所有打开文件维持一张文件表。每个文件表项包含： (a) 文件状态标志(读、写、增写、同步、非阻塞等)。 (b) 当前文件位移量。 © 指向该文件v节点表项的指针。 节点表项。每个打开的文件都有一个v-node结构，v-node中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，V-node中还包含了文件inode节点信息，这些信息是打开文件时从磁盘上读入内存的，所以文件所有信息都是随时可用的。 1. v节点的信息 2. 当前文件的长度 3. i节点的信息 **也就是对应下图。 图解过程： 假设执行了dup(1)函数，下一个可用的文件描述符是3。两个文件描述符指向同一文件表项。因此文件状态标志、当前文件位移量、指向文件的v节点表项指针共享。 ¶函数的简单实例： 下面的例子便是运用dup函数或者dup2函数，将新建的文件描述符指向之前建立好的网络连接，因为关闭了标准输出，因此文件描述符1空闲下来，可以使用，即相当于将标准输出定向到了网络连接中，实现CGI服务器功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243int main(int argc, char* argv[])&#123; if(argc &lt;= 2) &#123; printf(&quot;error\n&quot;); return 1; &#125; const char* ip = argv[1]; int port = atoi(argv[2]); struct sockaddr_in address; bzero(&amp;address,sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET,ip,&amp;address.sin_addr); address.sin_port = htons(port); int sock = socket(PF_INET,SOCK_STREAM,0); assert(sock &gt;= 0); int ret = bind(sock,(struct sockaddr*)&amp;address,sizeof(address)); assert(ret != -1); ret = listen(sock,5); assert(ret != -1); struct sockaddr_in client; socklen_t client_addrlength = sizeof(client); int connfd = accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength); if(connfd &lt; 0) &#123; printf(&quot;errno is %d\n&quot;,errno); &#125; else &#123; close(STDOUT_FILENO); dup(connfd);//自动寻找最小的文件描述符 //dup2(connfd,1);//自己指定文件描述符，若已存在，则返回一个大于指定文件描述符的最小值 printf(&quot;abcd\n&quot;); close(connfd); &#125; close(sock); return 0;&#125; 利用telnet模拟客户端可以看出，的确本应该输出到标准输出的字符，送到了客户端，而没有打印到终端。实现了重定向功能。]]></content>
      <categories>
        <category>IPC进程通信</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O复用3个模型的比较]]></title>
    <url>%2Fpost%2Fbac82e48.html</url>
    <content type="text"><![CDATA[¶前言： 前面分析了I/O复用的3种模型，分别是select，poll，epoll，它们各有优缺点，并且应用广泛，今天就来分析一下他们的异同。 ¶开场： 分析之前还是讲一讲I/O复用在网络程序下的适用场合： 服务器同时监听socket和连接socket。 服务器端同时处理多个socket。 客户端程序同时处理用户输入和网络连接。 服务器同时处理TCP和UDP请求。 服务器监听多个端口，或者处理多个服务。 I/O复用函数本身是阻塞的，它们必须顺序处理每个就绪的文件描述符，要想实现并发执行，要用到多线程/多进程编程。但I/O复用的优势也是在此,不必创建大量进程或者线程，也不必去维护它们，大大节约系统资源。 ¶渐进： 三者的共同点： 这3种模型都能同时监听多个文件描述符，他们等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有时间就绪时返回，返回就绪的数量。 3者都是同步I/O模型，即在监听事件就绪后也需要自己来负责读写。 3者都通过某种结构体变量来告知内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。 ¶高潮： 三者的区别： poll、select是有事件就绪后就轮询所有的结构体数组中的文件描述符，看是否发生了感兴趣的事件。并将其中就绪的文件描述符返回给用户程序而epoll是有事件就绪后内核事件表将就绪事件放到一个结构体数组中，仅仅轮询这些就绪事件。即epoll_wait采用回调的方式，内核检测到就绪的文件描述符后，就触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。最后在适当时间将内容拷贝到用户空间。 select参数类型fd_set 没有将文件描述符和事件进行绑定，它仅仅是一个文件描述符集合。而epoll、poll是将文件描述符和事件放入一个结构体中，实现了绑定。 epoll最大的区别是实现了用户注册事件和内核检测就绪事件的分离，搜索就绪事件只搜索返回的就绪事件。epoll是通过内核与用户空间mmap同一块内存实现的。而select、poll需要轮询所有文件描述符或者其一一对应的注册事件。 epoll适用于连接数量多，但活跃链接少的情况。select适用于并发量不高，且活跃链接多的情况。 另外还有几个小区别，请看下表： ¶尾声 浅析三者的工作流程：]]></content>
      <categories>
        <category>IPC进程通信</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O复用之poll和epoll]]></title>
    <url>%2Fpost%2F4bad3206.html</url>
    <content type="text"><![CDATA[¶poll函数 poll函数的定义： 12345678910#include&lt;poll.h&gt;int poll(struct pollfd* fds,nfds_t nfds,int timeout)typedef unsigned long int nfds_t;struct pollfd&#123; int fd; short events;//注册的事件 short revents;//实际发生的事件，有内核填充&#125;;timeout为0时，poll调用后立即返回，不阻塞 为-1时，poll调用将永远阻塞，直至某个事件发生。 poll函数实现监视的过程： 调用poll函数实现对感兴趣的文件描述符的某个事件的监听。 而后读取返回值，若返回值大于0，则轮询创建好的pollfd结构体数组，看每一个注册的事件是否发生感兴趣的事件。 ¶epoll函数 ¶epoll函数的定义： epoll函数不同于poll和select，它是由一组函数组成的。 1. epoll创建函数： 12#include&lt;sys/epoll.h&gt;int epoll_create(int size)//参数指定内核事件表的大小,返回一个指向内核事件表的fd：epollfd 2. epoll执行注册函数： 1234/*第一个参数为内核事件表的文件描述符，第二个参数为指定的操作类型,第三个为要操作的文件描述符，第4个为注册的事件*///返回0为成功，-1为失败int epoll_ctl(int epollfd,int op,int fd,struct epoll_event *event) 对于op操作类型，大体有3种： EPOLL_CTL_ADD:往内核事件表注册事件结构体 EPOLL_CTL_MOD:修改fd上的注册事件 EPOLL_CTL_DEL:删除fd上的注册事件 对于epoll_event结构体： 12345678910typedef union epoll_data&#123; void *ptr; int fd;//注册事件的文件描述符 uint32_t u32; uint64_t u64;&#125;epoll_data_t; struct epoll_event&#123; __uint32_t events;//epoll事件 epoll_data_t data;//用户的数据&#125;;//一般是将事件和epoll_data_t用户数据绑定 3. epoll等待就绪函数： 1234/*第一个参数指定内核事件表，第二个参数指定从内核事件表拷贝的就绪事件数组，第三个参数指定最多监听的事件个数，最后一个是设置超时时间同epoll*///该函数成功时返回就绪事件个数，与文件描述符无关，失败返回-1int epoll_wait(int epollfd,struct epoll_event* events, int max,int timeout) 4.epoll的事件类型 EPOLLIN ：数据可读（包括一般和优先数据） EPOLLOUT ：数据可写（包括一般和优先数据） EPOLLERR ：数据错误 EPOLLET ：epoll的边沿触发模式事件 EPOLLONESHOT ：该文件描述符上的可读、可写、错误事件最多触发其中一个且只触发一次 最后两个是epoll特有的，前三个去掉’E’即为poll的事件类型 5.epoll的模式： epoll中有两种模式，一种是LT模式，一种是ET模式。 LT模式： 所谓LT模式，就是指电平触发，这是epoll默认的工作方式，要想改变可以通过上面的EPOLLET事件。这种模式下的epoll相当于一个效率较高的poll。**这个模式下epoll_wait检测到有事件就绪后，应用程序可以不立即处理，那么下次调用epoll_wait仍会通告该事件，直至被处理。意味着每次epoll_wait()返回后，事件处理后，如果之后还有数据，会不断触发，也就是说，一个套接字上一次完整的数据，epoll_wait()可能会返回多次，直到没有数据为止。**这个模式下文件描述符可阻塞可不阻塞。该模式下只要在可读/可写 状态下epoll_wait都能检测到，因此可以不一次处理完。 ET模式 : 所谓ET模式，就是指边沿触发，当某个文件描述符注册EPOLLET事件时，eopll将使用ET模式操作该文件描述符。有数据过来后，epoll_wait()会返回一次，**一段时间内，该套接字就算有数据源源不断地过来，epoll_wait()也不会返回了。（即只会读出其中第一次的内容，再来数据是读不到的，但若是缓冲区不够的话，也会读到结束的）这里注意，是一段时间，不代表这个套接字上有数据就只触发一次。时间过长，还是会返回多次的。该模式与LT的最大区别就是当epoll_wait检测到事件就绪时，必须立即处理，后序再遇到epoll_wait不会在通告该事件，这样大大降低了同一个epoll事件被触发的次数。**该模式下文件描述符必须使用非阻塞。这种模式下发送多次否则，会因为缓冲区的不足造成发送或接收不到所有的数据。直到errno为EAGAIN时才算读(写)取完毕无数据可读(写）另外，该模式只有当某文件描述符由不可读/不可写 状态变为 可读/可写 状态时才能触发 因此，ET模式是高速工作模式，LT是缺省工作模式。 6.网络事件EAGIN 在一个非阻塞的socket上调用read/write函数, 返回EAGAIN或者EWOULDBLOCK。若遇到能read时，读缓冲区没有数据，或者write时，写缓冲区满了。这种情况下，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。 因此，对于non-blocking的socket，正确的读写操作为: 读：忽略掉errno = EAGAIN的错误，下次可继续读 写：忽略掉errno = EAGAIN的错误，下次可继续写 因此ET模式使用非阻塞IO模型下需要用EAGAIN这个标志来判断接受的数据是否读完。]]></content>
      <categories>
        <category>IPC进程通信</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体变量malloc的故事]]></title>
    <url>%2Fpost%2F48d4f714.html</url>
    <content type="text"><![CDATA[这是一个关于结构体通过malloc初始化的悲伤的故事 ¶背景 因为本身结构体是不需要malloc就可以直接创建其对象，但是，当结构体中出现柔性数组或者是数组指针时，情况就截然不同了。因为这些数组都是要动态分配内存的，因此结构体也需要malloc。 ¶问题描述： 但是此时问题就出现了，本身创建结构体对象时会在栈区分配一块地址，但是malloc之后又有另外一块地址指向了此对象，这是该怎么办呢？ ¶代码实例： 12345678910111213141516171819202122232425262728/*这仅仅是个用数组动态创建栈的初始化过程*/#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;typedef struct stack&#123; int top; int count; int array[];//柔性数组，也可以方括号内定义为0，也可以定义为数组指针&#125;Stack;void Init(Stack *s,int n)&#123; s = (Stack*)malloc(sizeof(Stack) + n * sizeof(int)); s-&gt;top = -1; s-&gt;count = n;&#125;void Destroy(Stack **s)&#123; free(*s); *s = NULL;&#125;int main()&#123; Stack s; Stack *q = &amp;s; Init(q); Destroy(&amp;q); return 0;&#125; ¶gdb调试显示结果： 由图中可以看出原本传入Init函数的stack的地址为0x7fffffffde00，但malloc出来的新地址为0x602830,改变malloc出来地址上的内容，函数返回时自然而然没有保存下来。 再次打印s的地址，果然还是原地址，相应数据也没有保存下来 ¶解决方案： 思路: 既然一级指针会在init函数中被重新malloc，之后返回后保存不下来，那么可以启用2级指针，之后，让malloc出来的指针和原指针的地址相同(即2级指针也指向malloc出来的指针)这样返回时才能真正将malloc出来的指针保存下来。 具体解决方法 重写init方法: 1234567void Init(Stack **s,int n)&#123; Stack *p = (Stack *)malloc(sizeof(Stack) + n * sizeof(int));//新malloc出一块地址指向原来的结构体 *s = p; //将新malloc出来的地址赋值给原地址，让两个变成同一地址 p-&gt;top = -1; p-&gt;count = n;&#125; ¶图解： 此时再次调用gdb调试： 可以看出当从init函数返回后q指针已经变为malloc出来的地址，由此数据也被保存了下来。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中类的大小]]></title>
    <url>%2Fpost%2F18b3c611.html</url>
    <content type="text"><![CDATA[*** 类所占内存的大小是有成员变量（静态变量除外）决定的，成员函数是不计算在内的，他们只是名义上在类里，其实同一个类的多个对象共享函数代码，而我们访问类的成员函数是通过类中的自引用指针实现的，所以我们访问成员函数是间接获得地址的。 *** ¶空类 空类的大小为1： 目的标示这个类，c++要求每个实例在内存中都具有独一无二的地址。 ¶普通类(不继承，不含虚函数） 跟struct的原理一致，内存对齐原则，但静态变量不占用内存，原因是编译器将其放在了全局变量区。 ¶含有虚函数的类 c++类中有虚函数的时候有一个指向虚函数的指针(vptr),因此此指针要占用字节空间，虚函数个数和大小无关。 ¶继承的类 子类的大小是本身成员变量的大小加上父类的大小，若父类本身就含有虚函数，则子类无论有没有虚函数都不能算上。 当继承空类时，不加上空类的大小，而是只算本身子类的大小。 ¶实例（注：笔者是在64位操作系统下操作得出的结果 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;class cBase&#123;&#125;; //标识存在为1class cBase1&#123; int a; char p;&#125;;//内存对齐，4个字节和1个字节，1字节按4字节算class cBase2&#123; public: cBase2(); virtual ~cBase2();//virtual开辟一块指针，因此为8 private: int a;//4，因内存对齐则为8 char *p;//8&#125;;class c:public cBase&#123; virtual void fun() = 0;//纯虚函数&#125;;class b&#123;&#125;;class d:public b,public c&#123;&#125;;//共享虚函数的指针int main()&#123; cout &lt;&lt; &quot;cBase类的大小:&quot; &lt;&lt; sizeof(cBase) &lt;&lt; endl; cout &lt;&lt; &quot;cBase1类的大小:&quot; &lt;&lt; sizeof(cBase1) &lt;&lt; endl; cout&lt;&lt; &quot;cBase2类的大小:&quot; &lt;&lt; sizeof(cBase2) &lt;&lt; endl; cout&lt;&lt; &quot;c类的大小:&quot; &lt;&lt; sizeof(c) &lt;&lt;endl; cout &lt;&lt; &quot;d类的大小:&quot; &lt;&lt; sizeof(d) &lt;&lt;endl; return 0;&#125; 结果为： cBase类的大小：1 cBase1类的大小：8 cBase2类的大小：24 c类的大小：8 d类的大小：8]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程同步机制之互斥锁和条件变量]]></title>
    <url>%2Fpost%2F457105b7.html</url>
    <content type="text"><![CDATA[¶线程同步 Pthread是POSIX threads 的简称，是POSIX的线程标准。 Pthread线程同步指多个线程协调地，有序地同步使用共享资源。多线程共享进程资源，一个线程访问共享资源需要一段完整的时间才能完成其读写操作，如果在这段时间被其他线程打断，就会产生诸多不可预知的错误。 ¶互斥锁 ¶1.互斥量： 互斥量是一种线程同步对象，“互斥”的含义是同一时刻只能有一个线程获得互斥量。一个互斥量对应一个共享资源，互斥量状态：1.解锁状态意味着共享资源可用，2.加锁状态意味着共享资源不可用。 一个线程需要使用共享资源时，使用thread_mutex_lock申请：1.当互斥量为解锁状态，则占用互斥量，并给互斥量加锁，占用资源（互斥量为加锁状态，其他线程不能使用互斥量并等待互斥量变为解锁状态），2.如果互斥量为加锁状态，则线程等待，直到互斥量为解锁状态（其他线程使用完共享资源后会解锁互斥量，释放资源）。 ¶2.临界区： 临界区指的是一个访问共用资源的程序片断。通常由定义一个互斥量并加锁来保护这段临界区代码。 ¶3.互斥量的相关函数： 首先定义互斥量的结构体pthread_mutex_t。 1). 互斥量初始化函数： 12#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr) 第一个参数即互斥量结构体的指针，第二个变量则是互斥量的属性（当为NULL时是默认属性）。成功返回0，失败返回错误码。 2). 互斥量上锁函数： 12#include&lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex) 此函数参数即互斥量结构体，返回成功为0，失败返回错误码。 是阻塞的上锁函数。 3). 互斥量解锁函数： 12#include&lt;pthread.h&gt;int pthread_mutex_unlock(pthread_mutex_t *mutex) 参数和返回值同上锁函数。 4). 互斥量的另一种上锁函数 12#include&lt;pthread.h&gt;int pthread_mutex_trylock(pthread_mutex_t *mutex) 这是上锁函数的非阻塞版本。若已经上锁，返回EBUSY。 5). 互斥量的销毁函数 12#include&lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex) 参数和返回值同上锁函数。 ¶条件变量 ¶1.概念 条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。 ¶2.条件变量的相关函数 首先定义条件变量结构体pthread_cond_t 1). 条件变量初始化函数 12#include&lt;pthread.h&gt;int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr) 第一个参数即条件变量结构体指针，第二个变量即条件变量的属性（如果为NULL，则是默认属性）。成功返回0，失败返回错误码。 2).条件变量的销毁函数 12#include&lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond) 第一个参数即条件变量结构体指针。返回值同初始化函数。 3). 条件变量的广播函数 12#include&lt;pthread.h&gt;int pthread_cond_broadcast(pthread_cond_t *cond) 参数和返回值同销毁函数。 此函数以广播的方式唤醒所有等待目标条件变量的线程。 4). 条件变量的信号函数 12#include&lt;pthread.h&gt;int pthread_cond_signal(pthread_cond_t *cond) 参数返回值同销毁函数 此函数用于唤醒一个等待目标变量的线程。至于哪个线程被唤醒，则取决于线程的优先级和调度策略。 5). 条件变量的等待函数 12#include&lt;pthread.h&gt;int pthread_cond_wait(pthread_cond_t *cond) 参数和返回值同销毁函数。 在调用此函数之前必须保证互斥量已经加锁。 重点：模拟等待函数（pthread_cond_wait)调用前后的过程 第一个线程首先调用： pthread_mutex_lock(&amp;mymutex); 然后，它检查了列表。没有找到感兴趣的东西，于是它调用： pthread_cond_wait(&amp;mycond, &amp;mymutex); 然后，pthread_cond_wait() 调用在返回前执行许多操作： pthread_mutex_unlock(&amp;mymutex); 它对 mymutex 解锁，然后进入睡眠状态，等待 mycond 以接收 POSIX 线程“信号”。一旦接收到“信号”（加引号是因为我们并不是在讨论传统的 UNIX 信号，而是来自 pthread_cond_signal() 或 pthread_cond_broadcast() 调用的信号），它就会苏醒。但 pthread_cond_wait() 没有立即返回——它还要做一件事：重新锁定 mutex： pthread_mutex_lock(&amp;mymutex); pthread_cond_wait() 知道我们在查找 mymutex “背后”的变化，因此它继续操作，为我们锁定互斥对象，然后才返回。 ¶3.代码示例（互斥锁和条件变量一起用实现线程同步） 程序思路： 在这里利用多线程技术实现生产者和消费者问题，生产者线程向一缓冲区中写数据，消费 者线程从缓冲区中读取数据，由于生产者线程和消费者线程共享同一缓冲区，为了正确读 写数据，在使用缓冲队列时必须保持互斥。生产者线程和消费者线程必须满足：生产者写 入缓冲区的数目不能超过缓冲区容量，消费者读取的数目不能超过生产者写入的数目。 在程序中使用了一个小技巧来判断缓冲区是空还是满。在初始化时读指针和写指针为0; 如果读指针等于写指针,则缓冲区是空的;如果(写指针+ 1) % N 等于读指针,则缓冲区是满的, %表示取余数,这时实际上有一个单元空出未用。下面是完整的程序段和注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt;#include&lt;pthread.h&gt; #include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#define BUFFER_SIZE 8 #define OVER (-1)#if 0//互斥量和条件变量综合的结构体struct prodcons &#123; int buffer[BUFFER_SIZE]; pthread_mutex_t lock; //互斥LOCK int readpos , writepos; //定义写和读的位置 pthread_cond_t notempty; //缓冲区非空条件判断 pthread_cond_t notfull; //缓冲区未满条件判断&#125;;//获取时间的函数char * get_time(void)&#123; time_t rawtime; struct tm * timeinfo; time(&amp;rawtime); return asctime(localtime(&amp;rawtime));&#125;//对结构体初始化函数void init(struct prodcons * b)&#123; pthread_mutex_init(&amp;b-&gt;lock,NULL); pthread_cond_init(&amp;b-&gt;notempty,NULL); pthread_cond_init(&amp;b-&gt;notfull,NULL); b-&gt;readpos=0; b-&gt;writepos=0;&#125;//放数据的函数void put(struct prodcons* b,int data)&#123; pthread_mutex_lock(&amp;b-&gt;lock); if((b-&gt;writepos + 1) % BUFFER_SIZE == b-&gt;readpos)//这是缓冲区满了的情况，留一个空用于发送-1这个信号 &#123; pthread_cond_wait(&amp;b-&gt;notfull, &amp;b-&gt;lock); &#125;// pthread_mutex_lock(&amp;b-&gt;lock);// 大家仔细理解互斥锁的位置，以及pthread_cond_wait函数的内核实现（解锁，休眠让出cpu，条件满足后被内核唤醒，上锁，形成临界区，保护资源） b-&gt;buffer[b-&gt;writepos]=data; b-&gt;writepos++; if(b-&gt;writepos &gt;= BUFFER_SIZE) b-&gt;writepos=0; printf(&quot;put %d at %s \n&quot;, data, get_time()); pthread_mutex_unlock(&amp;b-&gt;lock); pthread_cond_signal(&amp;b-&gt;notempty);&#125;//取数据的函数int get(struct prodcons *b)&#123; int data; pthread_mutex_lock(&amp;b-&gt;lock); if(b-&gt;writepos == b-&gt;readpos) &#123; printf(&quot;0 == 0\n&quot;); pthread_cond_wait(&amp;b-&gt;notempty, &amp;b-&gt;lock); printf(&quot;start read \n&quot;); &#125; data = b-&gt;buffer[b-&gt;readpos]; b-&gt;readpos++; if(b-&gt;readpos &gt;= BUFFER_SIZE) b-&gt;readpos=0; printf(&quot;get the data is : %d\n&quot;, data); pthread_cond_signal(&amp;b-&gt;notfull); pthread_mutex_unlock(&amp;b-&gt;lock); return data;&#125;//定义全局结构体对象struct prodcons buffer;//生产者回调函数void *producer(void *data)&#123; int n; for(n = 0; n &lt; 10; n++) &#123; printf(&quot;before produce %d \n&quot;, n) ; put(&amp;buffer, n); &#125; put(&amp;buffer, OVER);//发信号说-1已经放进去了，说明没内容写了 return NULL;&#125;//消费者回调函数void *consumer(void * data)&#123; int d; while(1) &#123; d = get(&amp;buffer); if(d == OVER)//说明生产者已经写完 break; printf(&quot;consumerd the num is %d\n&quot;, d); &#125; return NULL;&#125;//主函数int main(void)&#123; pthread_t th_a, th_b; pthread_attr_t attr; void *retval; pthread_attr_init(&amp;attr); init(&amp;buffer); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);// pthread_create(&amp;th_b, &amp;attr, consumer, 0); pthread_create(&amp;th_b, NULL, consumer, 0); sleep(3); pthread_create(&amp;th_a, NULL, producer, 0); pthread_join(th_a, &amp;retval); pthread_join(th_b, &amp;retval); sleep(100); return 0;&#125; 由图中可以看出，当条件变量不空不满足条件时，调用了等待函数使得此线程睡眠，让出cpu，进行其他操作，但是当条件满足时并不是直接回到原线程进行到的地方，而是重新加锁，在读。 参考资料： http://blog.csdn.net/shanshanpt/article/details/ http://blog.csdn.net/lovecodeless/article/details/24885127 http://blog.sina.com.cn/s/blog_590be5290100ikh5.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析多线程并发及写微信红包遇到的问题]]></title>
    <url>%2Fpost%2F966f045a.html</url>
    <content type="text"><![CDATA[¶多线程并发 众所周知，多线程编程很容易遇上诸如丢失更新、脏读、死锁等烦人的线程冲突问题。多线程的问题一旦发生便很难定位和解决，所以要在编程的初始阶段就要注意避免多线程程序常见的错误。 微信红包程序应用线程基础API，采用多线程并发的方式进行抢红包操作。 多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。 ¶微信红包程序 思路： 创建抢红包人员的结构体，分别给定名字，所抢金额，以及是否已抢过字段。 创建生产者线程，用于产生红包，红包金额和红包数目从标注输入读入，并对生产者回调函数进行加锁操作。 创建多个消费者线程，用于多人抢红包操作，其中消费者回调函数进行红包的随机分配算法，并进行加锁操作。 下面是部分代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 /*结构体部分*/ typedef struct person &#123; int id; char name[20]; int flag; int money; &#125;Person;/* 生产者回调函数*/ void *producer(void* value)//生产者只负责产生红包金 额和红包个数 &#123; double n = *(double*)value; pthread_mutex_lock(&amp;lock); money = n; pthread_mutex_unlock(&amp;lock); pthread_exit(NULL); &#125;/*消费者回调函数*/ void *consumer(void *n)//消费者用于随机获取红包个数 &#123; int nn = *(int*)n; pthread_mutex_lock(&amp;lock); printf(&quot;number%d\n&quot;,nn); if(money &gt; 0 &amp;&amp; per[nn].flag == 0)//还没抢过 &#123; if(num &gt; 1) &#123; srand((unsigned)time(NULL));//初始化随机数种子 double avg = money / num;//获取平均值 double t = avg*2; double randmoney = (rand()%(int)(t*100) + (int)MIN*100)/100.00 + MIN;//初始化随机数 money-=randmoney; printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,randmoney); printf(&quot;剩余%.2lf元\n&quot;,money); per[nn].id = nn; per[nn].money = randmoney; per[nn].flag = 1; num--; &#125; else &#123; printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,money); printf(&quot;剩余0元\n&quot;); money = 0; per[nn].id = nn; per[nn].money = money; per[nn].flag = 1; num--; &#125; &#125; pthread_mutex_unlock(&amp;lock); pthread_cancel(pthread_self()); &#125;/*主函数中主要线程API使用部分*/ pthread_t th_a,th_b[Total]; pthread_mutex_init(&amp;lock,0); pthread_create(&amp;th_a,NULL,producer,(void*)&amp;value); pthread_join(th_a,NULL); int args[Total]; for(i = 0; i &lt; Total;i++) &#123; args[i] = i; if(per[i].flag == 0) &#123; pthread_create(&amp;th_b[i],NULL,consumer,(void*)&amp;args[i]); // usleep(100); printf(&quot;i = %d\n&quot;,i); &#125; &#125; for(i = 0; i &lt; Total; i++) &#123; pthread_join(th_b[i],NULL); &#125; pthread_mutex_destroy(&amp;lock);/* 全局变量声明*/ #define Total 20//线程个数 Person per[Total]; double money = 0.0;//初始金额 int num = 0;//初始红包个数 pthread_mutex_t lock;//创建锁 这是笔者在经过对线程的更深入理解后写好的版本。 在最初的版本中，代码的69行的最后一个参数传的是(void*)&amp;i,但程序运行后时而成功时而失败，失败时如下图： 由运行结果可以看出20个线程全部都已创建出，但是却出现了红包抢不完的情况，而且观察发现，抢红包的顺序是乱序，且出现了同一个number的线程抢了好几次红包。 ¶因此总结为以下几个问题被给出解答： ** 1. 为什么创建线程是for循环控制，而抢红包是乱序？** 答： 这是因为存在资源抢占现象，创建线程的顺序是有for循环控制的，但创建好线程之后，谁先调用回调函数顺序是不定的，谁的抢到cpu资源，谁就先进入回调函数，谁就先抢红包。 ** 2. 为什么看似是同一个线程抢了多次红包？** 答： 这是因为i++操作是三条指令，分别是找到i将其放入寄存器，而后+1，最后回赋。而在运行结果中出现多次number7的情况却并不是同一个线程抢红包多次。因为可能有某几个线程在执行回调函数时，i的值还没有进行回赋操作，就被剥夺了cpu，而pthread_create函数最后一个参数原本传的是i的地址，即从地址中取i的值，但此时i还是原来的值。 因此看似是同一个线程抢了多次红包，实则不同线程执行同一个i的回调函数。 ** 3. 为什么经过修改用数组存i值可以，但最初版本用i时不可以？** 答： 这是因为pthread_create函数最后一个参数存的是地址。 当存的是i的地址时，即i变一次，地址中的内容变一次，当创建出线程而不是立即调用回调函数，而是被剥夺cpu资源时，i值就随for循环变化而变化，因此当回调函数有了cpu资源后，i的地址中存的就不是当时地址中的内容了。 当用数组存i值时，数组共有Total个地址，创建线程时，当对应的i存到对应的地址，某个数组下表元素的地址只存其当时的值，因此即使不立即调用回调函数，之后拿到的也是当时参数地址中的值，这个值未发生变化。 ** 4. 为什么67行有flag控制，而同一个i还能进去呢？** 答： **这个if判断由外部for循环控制，for循环是满足条件后进入，结束一次循环后i++，因此每次进入if后的i值都不同，至于说number7打印好多次，好像线程也创建了多次是错误的，是回调函数导致此原因，同问题2，在此就不赘述。 ** 5. 为什么在for循环中加上sleep类的函数就可以正确抢红包，但是是顺序抢？** 答： 这是因为usleep函数和sleep函数的作用是挂起当前线程，即挂起当前运行的主线程。在线程创建之后，即挂起主线程，只能进入子线程调用回调函数，回调函数又加了互斥锁，因此直到解锁才能释放cpu资源，即抢红包过程是顺序的。 6.为什么在number8后会出现number7？（即为什么8号线程后才出现7号线程？ 答： 这其实还是存在资源抢占问题，7线程创建后，没进入回调函数就被其他线程剥夺了cpu，因此当轮到其执行回调函数时，已经过去了很久。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>多线程，linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析select函数及FD宏]]></title>
    <url>%2Fpost%2F606db69c.html</url>
    <content type="text"><![CDATA[select函数 这个函数允许进程指示内核等待多个事件中的任一个发生，并仅在一个或者多个事件发生或经过某指定时间后才唤醒进程。 ¶函数原型：### 12345#include&lt;sys/select.h&gt;#include&lt;sys/time.h&gt;int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); 返回：准备好的描述字正数目，0表示超时，-1表示出错 ¶函数参数解析： 参数maxfdp1指定被测试的描述字数目，即经过FD_SET之后，所关心的描述符的个数，（因为从0开始，因此一般这个值是测试描述符集下标最大值+1）并通知内核。 中间三个参数readset，writeset，exceptset指定我们要让内核测试读、写、异常条件所需的描述字。也就是说，对于readset，我们关心是否可以从这些文件中读取数据了，对于writeset，我们关心是否可以向这些文件中写入数据了，对于exceptset，我们关心这些文件是否发生异常。 参数timeout，它告诉内核等待一组指定的描述字中的任意一个准备好可花多长时间，结构timeval指定了秒数和微秒数成员： 12345struct timeval&#123;long tv-sec;//秒long tv-usec;//微秒&#125; 有三种可能： 、永远等待下去：仅在有一个描述符准备好I/O时才返回，要设置timeout为NULL。 、等待固定时间：在有一个描述符准备好I/O时返回，但不超过timeout参数指定的秒数和微秒数。 、根本不等待：检查描述字后立即返回，这称为轮询(polling),参数timeout要指向某一个timeval结构，且其中的秒数和微秒数要置0。 前两种是阻塞的，最后一种是不阻塞的 ¶fdset结构体解析: 12345678910111213141516171819#include&lt;typesizes.h&gt;#define __FD_SETSIZE 1024#include&lt;sys/select.h&gt;#define FD_SETSIZE __FD_SETSIZEtypedef long int __fd_mask;//64位系统上大小为8#undef __NFDBITS#define __NFDBITS (8*(int) sizeof(__fd_mask)) // 8*8 = 64typedef struct&#123;#ifdef __USE_XOPEN __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];//数组长度为1024/64 = 16 #define __FDS_BITS(set) ((set)-&gt;fds_bits) #else __fd_mask __fds_bits[____FD_SETSIZE / __NFDBITS]; #define __FDS_BITS(set) ((set)-&gt;fds_bits) #endif &#125;fd_set 因此fd_set结构体中仅包含一个整型数组，该数组的每个元素的每一位都会标记一个文件描述符。因此16个long int元素就是 1688 = 1024位 ，最多容纳1024个文件描述符！！** select中FD相关的4个宏 void FD_ZERO(fd_set *fdset);//使fd_set结构体中的整型数组清零 void FD_SET(int fd,fd_set *fdset); //设置感兴趣的文件描述符 void FD_CLR（int fd,fd_set *fdset);//关闭感兴趣的文件描述符 int FD_ISSET(int fd, fd_set *fdset); //用于判断某个文件描述符是否就绪，且在感兴趣的描述符集合中 对于几个宏和select的理解 fd_set是创建文件描述符集合 FD_SET是设置感兴趣的文件描述符放入描述符集合中，将对应位置为1，但是此文件描述符可能准备好了，也可能没有准备好，可以说是一类文件描述符。 select是监听这几个文件描述符看哪几个就绪了，就返回个数，没就绪的再次置回0，就绪的保留1。 FD_ISSET是真正查看哪个指定的文件描述符是否就绪，就绪就为1，未就绪就为0。 example： 为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。 （1）执行fd_set set; FD_ZERO(&amp;set);则set用位表示是0000,0000。 （2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1) （3）若再加入fd＝2，fd=1,则set变为0001,0011 （4）执行select(6,&amp;set,0,0,0)阻塞等待 （5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。 （6）此时FD_ISSET(1,&amp;set)返回1，而FD_ISSET(5,&amp;set)返回0]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程，c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++重载覆盖隐藏的区别和执行方式]]></title>
    <url>%2Fpost%2Fbdc66b1.html</url>
    <content type="text"><![CDATA[¶成员函数被重载（overload）的特征 相同的范围（在同一个类中） 函数名字相同 参数不同 virtual关键字可有可无 1234567class A&#123; private: int a public： void print(); void print(int aa); &#125;; ¶覆盖（override）的特征 不同的范围（分别于派生类和基类） 函数名字相同 参数相同 基类函数必须有virtual关键字 覆盖是指派生类函数覆盖基类函数 123456789class A&#123; public: virtual void print(); &#125;; class B:public A &#123; public: void print(); &#125;; ¶隐藏（redefining）的规则 派生类函数与基类函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数都会被隐藏。 若派生类函数与基类函数同名且参数相同，但是基类函数没有virtual，基类的函数会被隐藏。 隐藏是指派生类的函数屏蔽了与其同名的基类函数。 12345678910111213141516171819class A&#123;public: void print(); &#125;; class B:public A&#123; private: int a; public: void print(int aa); &#125;; ----------------------------------------------------- class A&#123; public: void print(); &#125;; class B:public A&#123; public: void print(); &#125;; ## 3种情况怎么执行 1. 重载：看参数 2. 隐藏：看指针类型 3. 覆盖：看实体对象类型]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中return函数和exit函数的区别]]></title>
    <url>%2Fpost%2Fccc09ca5.html</url>
    <content type="text"><![CDATA[区别： exit函数在头文件stdlib.h中。 exit（0）：正常运行程序并退出程序； exit（1）：非正常运行导致退出程序； return（）：返回函数，若在main主函数中，则会退出函数并返回一值，可以写为return（0），或return 0。 详细说： return返回函数值，是关键字；exit是一个函数。 return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束。 return是函数的退出(返回)；exit是进程的退出。 return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。 return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一 个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出，非0 为非正常退出。 非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。 当在vfork函数中调用exit函数和return函数时需要特别注意！ vfork函数父子进程共享物理内存，因此若在子进程用return函数的话，父进程子进程的栈都会被修改，导致父进程再次return 0 时会出现段错误。 再回到 return 和 exit，return会释放局部变量，并弹栈，回到上级函数执行。exit直接退掉。如果你用c++ 你就知道，return会调用局部对象的析构函数，exit不会。（注：exit不是系统调用，是glibc对系统调用 _exit()或_exitgroup()的封装）。 可见，子进程调用exit() 没有修改函数栈，所以，父进程得以顺利执行。 另外网上大牛还有另外一种解释： 实际上子进程return只会导致子进程自己的相关寄存器（特别是esp、ebp）被更改，不会对共享的栈内存空间的内容产生影响。而子进程修改自己的寄存器并不影响父进程的寄存器，所以本来return是不会导致问题的。问题出在当子进程return返回到main()函数的调用点之后，接下来的语句中会有一些别的函数调用，这个时候main()原来的栈内存空间内容被覆盖（主要是返回地址），导致了程序的不确定行为。 链接：https://www.zhihu.com/question/26591968/answer/33867796 另外还想说一下return在子函数中的返回机制： 函数中定义的局部变量： Linux等的C语言中return返回值的机制为：将返回值存入eax寄存器中，然后系统再将eax中的值赋给变量(i)。 函数内部返回局部指针（或数组）的过程： 在执行return语句时，首先将return后面的地址值返回存入到比如eax寄存器中，然后系统再将eax中的地址值给接收函数返回地址的指针变量。这看起来都没什么问题，但问题在于两个方面： [1]接收函数返回地址值的指针变量要访问此地址中的内容。 [2]子函数运行结束后，一切有关于局部变量的内存都已经释放回收。那么在用这个地址来操作就很危险:地址中没有内容。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[using关键字在c#中的使用]]></title>
    <url>%2Fpost%2F10c43199.html</url>
    <content type="text"><![CDATA[using关键字在C#中的3种用法 using 关键字有两个主要用途： (一).作为指令，用于为命名空间创建别名或导入其他命名空间中定义的类型。 (二).作为语句，用于定义一个范围，在此范围的末尾将释放对象。 ¶(一).作为指令 1、用在命名空间里 using + 命名空间名字，这样可以在程序中直接用命令空间中的类型，而不必指定类型的详细命名空间，类似于Java的import，这个功能也是最常用的，几乎每个cs的程序都会用到。 例如：using System; 一般都会出现在*.cs中。 2、为命名空间或类型创建别名，using + 别名 = 包括详细命名空间信息的具体的类型。 这种做法有个好处就是当同一个cs引用了两个不同的命名空间，但两个命名空间都包括了一个相同名字的类型的时候。当需要用到这个类型的时候，就每个地方都要用详细命名空间的办法来区分这些相同名字的类型。而用别名的方法会更简洁，用到哪个类就给哪个类做别名声明就可以了。注意：并不是说两个名字重复，给其中一个用了别名，另外一个就不需要用别名了，如果两个都要使用，则两个都需要用using来定义别名的。 12345678910111213141516171819202122232425262728using System; using aClass = NameSpace1.MyClass; using bClass = NameSpace2.MyClass; namespace NameSpace1 &#123; public class MyClass &#123; public override string ToString() &#123; return &quot;You are in NameSpace1.MyClass&quot;; &#125; &#125; &#125; namespace NameSpace2 &#123; class MyClass &#123; public override string ToString() &#123; return &quot;You are in NameSpace2.MyClass&quot;; &#125; &#125; &#125; namespace testUsing &#123; using NameSpace1; using NameSpace2; class Class1 &#123; [STAThread] static void Main(string[] args) &#123; aClass my1 = new aClass(); Console.WriteLine(my1); bClass my2 = new bClass(); Console.WriteLine(my2); Console.WriteLine(&quot;Press any key&quot;); Console.Read(); &#125; &#125; &#125; (二).作为语句 using 语句允许程序员指定使用资源的对象应当何时释放资源。 using 语句中使用的对象必须实现 IDisposable 接口。此接口提供了 Dispose 方法，该方法将释放此对象的资源。 ①可以在 using 语句之前声明对象。 1234567 Font font2 = new Font(“Arial”, 10.0f); using (font2) &#123; // use font2; &#125; ②可以在 using 语句之中声明对象。 using (Font font2 = new Font(“Arial”, 10.0f)) { // use font2; } ③可以有多个对象与 using 语句一起使用，但是必须在 using 语句内部声明这些对象。 1234567891011 using (Font font3=new Font(“Arial”,10.0f), font4=new Font(“Arial”,10.0f))&#123; // Use font3 and font4. &#125;***使用规则:***①using只能用于实现了IDisposable接口的类型，禁止为不支持IDisposable接口的类型使用using语句，否则会出现编译错误；②using语句适用于清理单个非托管资源的情况，而多个非托管对象的清理最好以try-finnaly来实现，因为嵌套的using语句可能存在隐藏的Bug。内层using块引发异常时，将不能释放外层using块的对象资源；③using语句支持初始化多个变量，但前提是这些变量的类型必须相同，例如： using(Pen p1 = new Pen(Brushes.Black), p2 = new Pen(Brushes.Blue)){ // } 1④针对初始化多个不同类型的变量时，可以都声明为IDisposable类型，例如： using (IDisposable font = new Font(“Verdana”, 12), pen = new Pen(Brushes.Black)) { float size = (font as Font).Size; Brush brush = (pen as Pen).Brush; } 123using实质 在程序编译阶段，编译器会自动将using语句生成为try-finally语句，并在finally块中调用对象的Dispose方法，来清理资源。所以，using语句等效于try-finally语句，例如： using (Font f2 = new Font(“Arial”, 10, FontStyle.Bold)） { font2.F(); } 1被编译器翻译为： Font f2 = new Font(“Arial”, 10, FontStyle.Bold); try{ font2.F(); } finally { if (f2 != null) ((IDisposable)f2).Dispose(); } 转载自 http://www.cnblogs.com/xiaobiexi/p/6179127.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADO.NET与外部数据库连接及查询等基本操作]]></title>
    <url>%2Fpost%2Ffb8e6b56.html</url>
    <content type="text"><![CDATA[¶建立与数据库连接: 需要连接字符串，用到System.Data.SqlClient类库。 方法： 使用一个类构建SQL Server 连接字符串 - 创建SqlconnectionStringBuider实例 - 根据需要设置其属性 - 访问该对象的ConnectionString属性 与SQL Server数据库建立连接 - 生成一个指向该数据库的连接字符串 - 创建SqlConnection实例，向构造函数传递连接字符串 - 调用Sqlconnection实例的open方法 ¶代码实例： /*建立连接字符串生成器*/ SqlConnectionStringBuilder connection = new SqlConnectionStringBuilder(); /*能连上本地服务器，以windows身份登录*/ if (LocalServer.Checked == true) connection.DataSource = &quot;(local)&quot;; /*以sql身份登录*/ else connection.DataSource = ServerName.Text; /*若sql server是express版本*/ if (IsExpressEdition.Checked == true) connection.DataSource += @&quot;\SQLEXPRESS&quot;; /*基于当前windows登陆的集成安全验证*/ if(AuthenticateWindows.Checked == true) { connection.IntegratedSecurity = true; } else { connection.IntegratedSecurity = false;//基于SQL用户的安全验证 connection.UserID = UserName.Text; connection.Password = UserPassword.Text; } SqlConnection linkToDB = new SqlConnection(connection.ConnectionString);//新建连接对象 linkToDB.Open();//打开数据库连接 linkToDB.close();//关闭数据库，或用dispose方法，或者用using语句就会自动关闭 ¶对数据库进行查询、修改、更新、删除等操作：## 需要用到System.Data.SqlClient类库中的sqlcommand类 方法： 通过一个ADO.NET连接运行SQL查询 - 创建Sqlcommandr实例 - 将其CommandText属性设置为SQL语句 - 将其Connection属性设置为一个有效的Sqlconnection实例 - 调用这个命令对象的ExecuteNonQuery方法 调用一个返回静态结果的SQL Server存储过程 - 创建Sqlcommandr实例 - 将其CommandText属性设置为这个存储过程的名字 - 将其Connection属性设置为一个有效的Sqlconnection实例 - 调用这个命令对象的ExecuteScalar方法，捕获返回值 ¶代码实例： /*对于对数据库采取操作但不返回存储数据的服务*/ string sqlText = @&quot;UPDATE WorkTable SET ProcessedOn = GETDATE() WHERE ProcessedOn IS NULL&quot;; SqlCommand dataAction = new SqlCommand(sqlText, linkToDB); dataAction.ExecuteNonQuery(); /*对于返回单个值的查询*/ string sqlText1 = &quot;select count(*) from WorkTable&quot;; SqlCommand dataAction1 = new SqlCommand(sqlText1, linkToDB); int total = (int)dataAction1.ExecuteScalar();//返回单个值 /*对于返回数据行的操作*/ string sqlText2 = &quot;select ID,FullName,ZipCode from Customer&quot;; SqlCommand dataAction2 = new SqlCommand(sqlText2, linkToDB); SqlDataReader scanCustomer = dataAction2.ExecuteReader();//一次返回一个数据行 if (scanCustomer.HasRows) while (scanCustomer.Read()); /*对于访问字段的值，用访问器*/ result = scanCustomer[0];//从起始位置查找 result = scanCustomer[“ID”];//按列名称查找 scanCustomer.NextResult();//若有多个列的返回时 /*查询中存在参数时，用@标识符替代*/ string test = @&quot;update Employee set Salary = @NewSalary where ID = @EmployeeID&quot;； SqlCommand salaryUpadate = new SqlCommand(test, linkToDB); paramValue.Value = 50000m;//设置参数的值 salaryUpadate.Parameters.Add(paramValue);//获取参数的值到原来的字符串中 salaryUpadate.Parameters.AddWithValue(&quot;@NewSalary&quot;, 50000m);//另外一种实例化方式，用于简单的参数时 salaryUpadate.ExecuteNonQuery(); /*对于存储过程的查询时*/ string test1 = &quot;dbo.AddLocation&quot;;//创建存储过程的字符串 SqlCommand locationCommand = new SqlCommand(test1, linkToDB); locationCommand.CommandType = CommandType.StoredProcedure;//把数据库命令的类型设置成存储过程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>.net</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的function自定义函数]]></title>
    <url>%2Fpost%2Fa73e2f66.html</url>
    <content type="text"><![CDATA[SQL自定义函数 产生背景（已经有了存储过程，为什么还要使用自定义函数） 发展历史 构成 使用方法 适用范围 注意事项 疑问 ¶内容 ¶产生背景（已经有了存储过程，为什么还要使用自定义函数） 与存储过程的区别（存在的意义）： 能够在select等SQL语句中直接使用自定义函数，存储过程不行。 自定义函数可以调用其他函数，也可以调用自己（递归） 可以在表列和 CHECK 约束中使用自定义函数来实现特殊列或约束 自定义函数不能有任何副作用。函数副作用是指对具有函数外作用域（例如数据库表的修改）的资源状态的任何永久性更改。函数中的语句唯一能做的更改是对函数上的局部对象（如局部游标或局部变量）的更改。不能在函数中执行的操作包括：对数据库表的修改，对不在函数上的局部游标进行操作，发送电子邮件，尝试修改 目录，以及生成返回至用户的结果集。存储过程没有此限制 函数只能返回一个变量。而存储过程可以返回多个 ¶发展历史 SqlServer 2000之后都支持用户自定义函数 ¶构成 在SQL Server 2000 中根据函数返回值形式的不同将用户自定义函数分为三种类型：标量函数（Scalar Function）、内嵌表值函数（Inline Function）、多声明表值函数（Multi-Statement Function） 标量函数：标量函数是对单一值操作，返回单一值。能够使用表达式的地方，就可以使用标量函数。像我们经常使用的left、getdate等，都属于标量函数。系统函数中的标量函数包括：数学函数、日期和时间函数、字符串函数、数据类型转换函数等 内嵌表值函数：内嵌表值函数的功能相当于一个参数化的视图。它返回的是一个表，内联表值型函数没有由BEGIN-END 语句括起来的函数体。其返回的表由一个位于RETURN 子句中的SELECT 命令段从数据库中筛选出来。 作用 多声明表值函数：可以看作标量型和内嵌表值型函数的结合体。它的返回值是一个表，但它和标量型函数一样有一个用BEGIN-END 语句括起来的函数体，返回值的表中的数据是由函数体中的语句插入的。由此可见，它可以进行多次查询，对数据进行多次筛选与合并，弥补了内联表值型函数的不足。 ¶使用方法 SQL Server 为三种类型的用户自定义函数 提供了不同的命令创建格式。 （1） 创建标量型用户自定义函数（Scalar functions） 其语法如下： 各参数说明如下： owner_name ：指定用户自定义函数的所有者。 function_name：指定用户自定义函数的名称。database_name.owner_name.function_name 应是惟一的。 @parameter_name：定义一个或多个参数的名称。一个函数最多可以定义1024 个参数每个参数前用“@”符号标明。参数的作用范围是整个函数。参数只能替代常量，不能替代表 名、列名或其它数据库对象的名称。用户自定义函数不支持输出参数。 scalar_parameter_data_type：指定标量型参数的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。 scalar_return_data_type：指定标量型返回值的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。 scalar_expression：指定标量型用户自定义函数返回的标量值表达式。 function_body：指定一系列的Transact-SQL 语句，它们决定了函数的返回值。 ENCRYPTION：加密选项。让SQL Server 对系统表中有关CREATE FUNCTION 的声明加密，以防止用户自定义函数作为SQL Server 复制的一部分被发布（Publish） 。 SCHEMABINDING：计划绑定选项将用户自定义函数绑定到它所引用的数据库对象如果指定 了此选项，则函数所涉及的数据库对象从此将不能被删除或修改，除非函数被删除或去掉此选项。应注意的是，要绑定的数据库对象必须与函数在同一数据库中。 2）创建内联表值型用户自定义函 数（Inline Table-valued Functions） 其语法如下： 各参数说明如下： TABLE：指定返回值为一个表。 select-stmt：单个SELECT 语句，确定返回的表的数据。 其余参数与标量型用户自定义函数相同。 （3） 创建多声明表值型用户自定义函数 其语法如下： 各参数说明如下： @return_variable ：一个TABLE 类型的变量，用于存储和累积返回的表中的数据行。 其余参数与标量型用户自定义函数相同。 在多声明表值型用户自定义函数的函数体中允许使用下列Transact-SQL 语句。 赋值语句（Assignment statements）； 流程控制语句（Control-of-Flow statements）； 定义作用范围在函数内的变量和 游标的DECLARE 语句； SELECT 语句； 编辑函数中定义的表变量的INSERT、 UPDATE 和DELETE 语句； 在函数中允许涉及诸如声明游 标、打开游标、关闭游标、释放游标这样的游标操作，对于读取游标而言，除非在FETCH 语句中使用INTO 从句来对某一变量赋值，否则不允许在函数中使用FETCH 语句来向客户端返回数据。此 外不确定性函数（Non-deterministic functions） 不能在用户自定义函数中使 用。所谓不确定性函数是指那些使用相同的调用参数在不同时刻调用得到的返回值不同的函数。 ¶适用范围 ¶用户自定义函数不能用于执行一系列改变数据库状态的操作在编写自定义函数时需要注意的： 对于标量函数： 所有的入参前都必须加@ create后的返回，单词是returns，而不是return returns后面的跟的不是变量，而是返回值的类型，如：int，char等。 在begin/end语句块中，是return。 内嵌表值函数： 只能返回table，所以returns后面一定是TABLE AS后没有begin/end，只有一个return语句来返回特定的记录。 多语句表值函数： returns后面直接定义返回的表类型，首先是定义表名，表明前面要加@，然后是关键字TABLE，最后是表的结构。 在begin/end语句块中，直接将需要返回的结果insert到returns定义的表中就可以了，在最后return时，会将结果返回。 最后只需要return，return后面不跟任何变量。 ¶疑问 自定义函数不能修改数据库，但它可以调用存储过程，那么在自定义函数中调用一个有修改数据库的操作的存储过程，这个自定义函数能不能执行？ 答： 自定义函数只能调用扩展存储过程，但是SQL Server 2008的后续版本将删除该功能，不再支持扩展存储过程，所以应避免在开发中使用扩展存储过程。因此，可以得出结论是：实际开发中，函数不会去调用存储过程，也就无法对数据库进行修改操作了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下安装命令的区别]]></title>
    <url>%2Fpost%2F46c05853.html</url>
    <content type="text"><![CDATA[ubuntu下安装命令的区别（dpkg、apt-get、aptitude） dpkg绕过apt包管理数据库对软件包进行操作，所以你用dpkg安装过的软件包用apt可以再安装一遍，系统不知道之前安装过了，将会覆盖之前dpkg的安装。 dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件 apt会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具 aptitude与 apt-get 一样，是 Debian 及其衍生系统***能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。 ¶安装软件包 123456dpkg -i package_name.deb #安装本地软件包，不解决依赖关系apt-get install package #在线安装软件包aptitude install pattern #同上apt-get install package –reinstall #重新安装软件包apitude reinstall package #同上 ¶移除软件包 1234567dpkg -r package #删除软件包apt-get remove package #同上aptitude remove package #同上dpkg -P #删除软件包及配置文件apt-get remove package –purge #删除软件包及配置文件apitude purge pattern #同上 ¶自动移除软件包 12apt-get autoremove #删除不再需要的软件包注：aptitude 没有，它会自动解决这件事 ¶清除下载的软件包 12345apt-get clean #清除 /var/cache/apt/archives 目录aptitude clean #同上apt-get autoclean #清除 /var/cache/apt/archives 目录，不过只清理过时的包aptitude autoclean #同上 ¶编译相关 1234apt-get source package #获取源码apt-get build-dep package #解决编译源码 package 的依赖关系aptitude build-dep pattern #解决编译源码 pattern 的依赖关系 ¶平台相关 123456apt-cross –arch ARCH –show package 显示属于 ARCH 构架的 package 软件包信息apt-cross –arch ARCH –get package #下载属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –install package #安装属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –remove package #移除属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –purge package #移除属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –update #升级属于 ARCH 构架的 package 软件包 注：慎重考虑要不要用这种方法来安装不同构架的软件包，这样会破坏系统。对于 amd64 的用户可能需要强制安装某些 i386 的包，千万不要把原来 amd64 本身的文件给 replace 了。最好只是安装一些 lib 到 /usr/lib32 目录下。同样地，可以用 apt-file 看某个其它构架的软件包包含哪些文件，或者是文件属于哪个包，不过记得最先要用 apt-file –architecture ARCH update 来升级 apt-file 的数据库，在 search 或 show 时也要指定 ARCH。 ¶更新源 12apt-get update #更新源aptitude update #同上 ¶更新系统 1234apt-get upgrade #更新已经安装的软件包aptitude safe-upgrade #同上apt-get dist-upgrade #升级系统aptitude full-upgrade #同]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中struct大小计算]]></title>
    <url>%2Fpost%2F8231f9f5.html</url>
    <content type="text"><![CDATA[struct 大小计算 结构体是一种复合数据类型，通常编译器会自动的进行其成员变量的对齐，已提高数据存取的效率。在默认情况下，编译器为结构体的成员按照自然对齐（natural alignment）条方式分配存储空间，各个成员按照其声明顺序在存储器中顺序存储。自然对齐是指按照结构体中成员size最大的对齐。 ¶默认对齐方式： 在默认对齐方式下，结构体成员的内存分配满足下面三个条件： 结构体第一个成员的地址和结构体的首地址相同 结构体每个成员地址相对于结构体首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节（internal adding）。 结构体总的大小要是其成员中最大size的整数倍，如果不是编译器会在其末尾添加填充字节（trailing padding）。 下面是一个示例： 123456789101112131415161718192021222324252627282930struct s1&#123; char ch; int a; double b; char c1;&#125;;struct s2&#123; char ch; int a; double b;&#125;;int main()&#123; cout &lt;&lt; &quot;s1的大小： &quot; &lt;&lt; sizeof(struct s1) &lt;&lt; endl; cout &lt;&lt; &quot;ch的地址偏移是 &quot; &lt;&lt; offsetof(s1, ch) &lt;&lt; endl; cout &lt;&lt; &quot;a 的地址偏移是 &quot; &lt;&lt; offsetof(s1, a) &lt;&lt; endl; cout &lt;&lt; &quot;b 的地址偏移是 &quot; &lt;&lt; offsetof(s1, b) &lt;&lt; endl; cout &lt;&lt; &quot;c1的地址偏移是 &quot; &lt;&lt; offsetof(s1, c1) &lt;&lt; endl; cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; endl; cout &lt;&lt; &quot;s2的大小: &quot; &lt;&lt; sizeof(struct s2) &lt;&lt; endl; cout &lt;&lt; &quot;ch的地址偏移是 &quot; &lt;&lt; offsetof(s2, ch) &lt;&lt; endl; cout &lt;&lt; &quot;a 的地址偏移是 &quot; &lt;&lt; offsetof(s2, a) &lt;&lt; endl; cout &lt;&lt; &quot;b 的地址偏移是 &quot; &lt;&lt; offsetof(s2, b) &lt;&lt; endl; getchar(); return 0;&#125; 代码中 offsetof函数可以得到结构体成员相对于该结构体首地址的偏移量。 其运行结果如下图： 对于结构体s1来说： ch是其第一个成员故其地址和结构体的地址是相同的也就是说偏移量为0； a是int型其大小为4个字节，按照条件（2） 结构体每个成员地址相对于结构首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节，所以其地址偏移应该是4，也就说编译器在第一个成员ch后面填充了3个字节。 b是double型占8个字节，其地址偏移应该是8的整数倍，由于a的地址偏移是4其大小为4个字节，正好b的偏移地址是8，不需要填充字节。 c1是char型占1个字节，偏移地址是16（b的偏移地址是8大小也是8，中间也没有填充字节）。 这时成员ch占1个字节后面有3个字节的填充，a占4个字节后面无填充，b占8个字节后面无填充，c1占1个字节，s1总的大小是1+3+4+8+1=17” role=”presentation”&gt;1+3+4+8+1=171+3+4+8+1=17。按照条件（3）结构体总的大小需是其最大成员所占空间的整数倍，其最大的成员b占有8字节，17显然是不符合条件的，所以需要在结构体的末尾填充7个字节，最后结构体总的大小是24字节。 结构体s2和s1的成员是非常相似的，唯一的区别是其末尾没有最后7个字节的填充，所以其大小是16个字节，这里用于和s1做对比说明s1末尾的填充字节。 ¶指定对齐方式 可以使用#pragma pack(N)来指定结构体成员的对齐方式 对于指定的对齐方式，其成员的地址偏移以及结构的总的大小也有下面三个约束条件： 结构体第一个成员的地址和结构体的首地址相同 结构体每个成员的地址偏移需要满足：N大于等于该成员的大小，那么该成员的地址偏移需满足默认对齐方式（地址偏移是其成员大小的整数倍）；Ｎ小于该成员的大小，那么该成员的地址偏移是N的整数倍。 结构体总的大小需要时N的整数倍，如果不是需要在结构体的末尾进行填充。 如果N大于结构体成员中最大成员的大小，则N不起作用，仍然按照默认方式对齐。 还是用上述示例： 1#pragma pack(4) //设定按照4字节对齐 运行结果为： ¶说明： 在使用#pragma pack设定对齐方式一定要是2的整数幂，也就是（1，2，4，8，16，…），不然不起作用的，仍然按照默认方式对齐。 当结构体中有其他的结构体作为成员时，计算最大成员是不能把结构体成员作为一个整体来计算，要看其每个成员的大小。 转载自： http://www.cnblogs.com/wangguchangqing/p/4853438.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const只读变量的内存分配]]></title>
    <url>%2Fpost%2Fbedd431b.html</url>
    <content type="text"><![CDATA[const只读变量与#define宏定义的常量的内存分配的区别 编译器通常不为普通 const 只读变量分配存储空间,而是将它们保存在符号表中,这使 得它成为一个编译期间的值,没有了存储与读内存的操作,使得它的效率也很高。 例如： 1234567#define M 3//宏常量const int N=5;//此时并未将 N 放入内存中......int i=N;//此时为 N 分配内存,以后不再分配int I=M;//预编译期间进行宏替换,分配内存int j=N;//没有内存分配int J=M;//再进行宏替换,又一次分配内存 const 定义的只读变量从汇编的角度来看,只是给出了对应的内存地址,而不是象#define 一样给出的是立即数,所以,const 定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量,存放在静态区),而#define 定义的宏常量在内存中有若干个拷贝。 #define 宏是在预编译阶段进行替换,而 const 修饰的只读变量是在编译的时候确定其值。 #define 宏没有类型,而 const 修饰的只读变量具有特定的类型。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git与github基本操作]]></title>
    <url>%2Fpost%2F4f2f9ce0.html</url>
    <content type="text"><![CDATA[git与github的基本操作 ¶一、准备： 1、git config --global user.name “Firstname Lastname” 2、git config --global user.email&quot;your_email@example.com&quot; 3、ssh-keygen -t rsa -C &quot;your_email@example.com&quot;添加ssh，一路回车略过 4、id_rsa.pub寻找公开公钥复制到github 5、ssh -T git@github.com 测试ssh是否生效 ¶二、向远程仓库提交本地文件： 方法一： 1、git clone git@github.com:username/example.git 2、cd example 3、git add filename//将文件发到缓存区 4、git diff HEAD//查看本次提交与之前提交的区别（可省略） 5、git commit -m “contribtion”//提交文件 6、git status//查看当前工作树情况（可省略） 7、git log -p//查看提交日志，并可查看修改的情况（可省 略） 8、git push//直接提交到远程仓库 方法二： 1.git init 2.git add filename//将文件发到缓存区 3.git diff HEAD//查看本次提交与之前提交的区别（可省略） 4.git commit -m “contribtion”//提交文件 5.git status//查看当前工作树情况（可省略） 6.git log -p//查看提交日志，并可查看修改的情况（可省略） 7.git remote add origin 8.git@github.com:usrname/example.git//创建远程仓库 9.git push -u origin master//把本地当前分支上的内容推送到远程origin库的master分支 -u参数可以在推送的同时,将 origin 仓库的 master 分 支设置为本地仓库当前分支的 upstream(上游)。添加了这个参数,将来 运行 git pull命令从远程仓库获取内容时,本地仓库的这个分支就可 以直接从 origin 的 master 分支获取内容,省去了另外添加参数的麻烦。 工作树（当前文件夹） ----&gt; 暂存区 -----&gt;本地仓库 -----&gt;远程仓库]]></content>
      <categories>
        <category>研发管理</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
