<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http历史及请求报文和响应报文]]></title>
    <url>%2Fhttp%E5%8E%86%E5%8F%B2%E5%8F%8A%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[书籍是人类进步的阶梯 高尔基 ¶前言 笔者最近看了&lt;&lt;图解HTTP&gt;&gt;这本书，了解了web开发人员需要了解的http协议的基础知识，并且在此整理一下重点的知识。 ¶http的历史 http在1990年面世，但最开始并没有作为正式的标准建立。这时候的http，更多的被称为HTTP/0.9版本。 之后在1996年的5月，http被正式作为标准公布，称为HTTP/1.0。 之后在1997年的1月，公布了HTTP/1.1是目前主流的HTTP协议版本。 目前HTTP/2.0正在制定中，但是仍然没有成为主流的版本。 ##http请求和响应 ¶http请求 请求报文 = 请求方法 + 请求URI + 请求协议版本 + 可选择的首部字段 + 内容实体 = 报文首部 + 空行(CR+LF) + 报文主体 请求行 = 请求方法 + 请求URI + 请求协议版本 可选择的首部字段 = 请求首部 + 通用首部 + 实体首部 + 其他 如图： ex: 123456789101112GET / HTTP/1.1 请求行Host: hackr.jp User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0.8Accept-Language: ja,en-us;q=0.7,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: keep-aliveIf-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMTIf-None-Match: &quot;45bae1-16a-46d776ac&quot;Cache-Control: max-age=0//空行(CR+LF) ¶http响应 响应报文 = 协议版本 + 状态码 + 原因原语 + 可选择的首部字段 + 内容实体 = 报文首部 + 空行(CR+LF) + 报文主体 状态行 = 协议版本 + 状态码 + 原因原语 可选择的首部字段 = 响应首部字段 + 通用首部字段 + 实体首部字段 + 其他 如图: ex: 1234567HTTP/1.1 200 OK 响应行Date: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html//空行&lt;html&gt; 内容实体...... ¶首部字段 首部字段包括通用首部字段、请求首部字段、响应首部字段、实体首部字段和其他。 通用首部字段：General Header Fields ​ 请求报文和响应报文两方都会使用的首部。 请求首部字段：Request Header Fields ​ 客户端发送请求报文给服务器时使用，补充了请求的附加内容，客户端信息，响应内容相关的优先级等信息 响应首部字段：Response Header Fields ​ 服务器向客户端返回响应报文时使用的首部，补充响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段：Entity header Fields ​ 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。 ¶http可使用的方法 GET方法： 用来请求访问被URI识别的资源。指定的资源经服务器解析处理后返回响应内容。 POST方法: 用来传输实体的主体，但其主要目的并不是获取响应的主体内容。 PUT方法： 用来传输文件，但HTTP/1.1的PUT方法本身不带验证机制，存在安全性问题，因此一般不使用。 HEAD方法： 用来查看URI指定的资源的有效性，仅返回响应头部，不返回实体主体。 DELETE方法： 用来删除请求URI指定的资源，与PUT方法相反，因此也一般不使用。 OPTIONS方法： 用来询问针对请求URI指定的资源支持的方法。 TRACE方法： 用来追踪路径，将客户端请求怎么发往服务器经过的路径反馈回去。 CONNECT方法： 此方法主要是与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议将通信内容加密后传输到隧道。 ¶http状态码 状态码的类别： 具体例子如下: 200 OK 表示从客户端发来的请求在服务器端被正常处理了。 204 No Content 表示服务器接收成功受理，但是返回的响应报文中不含实体的主体部分。 206 Partial Content 表示客户端请求一定的范围内容，然后获取成功返回状态 301 Moved Permanently 表示永久性重定向，所请求的资源已经分配到了新的URI，以后资源都指向这个URI 302 Found 表示临时性重定向，希望用户本次使用新的URI，实际运用中允许POST方法改成GET方法。 303 See Other 也表示临时性重定向，但指定客户端采用GET方法。 304 Not Modified 该状态码表示发送附带条件时,不满足条件，则返回这个。 307 Temporary Redirect也表示临时的重定向，且不会从POST变为GET. 400 Bad Request 表示请求报文出错 401 Unauthorized 表示发送的请求需要有通过HTTP认证信息。 403 Forbidden 该状态码表示对请求资源的访问被服务器拒绝了。 404 Not Found 服务器上无法找到请求的资源。 500 Internal Server Error 表示服务器端在执行请求时发生了错误。 503 Service Unavailable 表示服务器暂时处于超负载或正在停机维护，现在无法处理请求。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[划分子网与构造超网]]></title>
    <url>%2F%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E4%B8%8E%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91%2F</url>
    <content type="text"><![CDATA[¶前言 笔者上一篇分享了tcp层可靠传输和流量控制的4种协议，这次来分享一下ip层的重要知识，也就是划分子网和构造超网。 ¶前提 在讲述划分子网和构造超网之前，让我们先来回忆一下ip地址的划分。 1ip地址::=&#123;&lt;网络号&gt;,&lt;主机号&gt;&#125; ip地址的划分以下几个特点： ip地址划分为A类、B类、C类、D类、E类5种 A、B、C类地址都是常用的单播地址，而D类是多播地址，E类地址保留为以后用 ip地址都是32位的二进制代码，为提高可读性，IP地址每8位插入一个点，叫做点分十进制表示法 一般的，A类地址第一位二进制是0，B类地址前两位是10，C类地址前三位是110，D类地址前4位是1110，E类地址前4位地址是1111 A类地址前8位为网络号，7位可用，但7位全0（0.x.x.x)是个保留地址，表示本网络，7位全1(127.x.x.x)也是个保留地址，作为本地回环测试。因此可以指派2^7-2地址最为网络地址。 A类地址的主机号24位，但是全0(x.0.0.0)为网络地址即网关(网段)地址，全1(x.255.255.255)为该网段内的所有的主机 B类地址前16位为网络号，14为可用，但是14位中全1(128.0.0.0)不指派,因此B类地址可以指派网络数为2^14-1 B类地址主机号16位，全0，全1不指派，因此主机数为2^16-2 c类地址前24位为网络号，21位可用，但是21位全0(192.0.0.x)不指派，因此C类地址可以指派网络数为2^21-1 C类地址主机号8位，全0，全1不指派，因此主机数为2^8-2 特殊的不使用的ip地址 ¶划分子网 ¶背景 由于ip地址空间利用率低，ip地址不够用等原因，急需要一种措施解决，因此出现了划分子网。 ¶概念 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网，因此这个子网地址并不是真是网络通信中用到的外部地址，而是一个内部地址，因此这个单位对外仍表现为一个地址，即网关地址。 12ip地址 ::= &#123;&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;&#125;即从主机号拿出一部分作为子网号。 ¶实现 要想在路由转发时找到相应的子网，需要用到子网掩码。子网掩码是一个网络或一个子网的重要属性。 ![图2](划分子网与构造超网/1.png 子网划分举例： ¶求网络地址 网络地址: 即网关地址，一个单位千千万万台主机对外的地址 求法: ip地址 和 子网掩码 相与。 ex:已知ip地址为141.14.72.24，子网掩码为255.255.192.0，求网络地址(即子网地址)？ 解答： 将十进制转化成二进制，逐位相与。 ip十进制：141 . 14 . 72 . 24 ip二进制：10001101. 00001110 . 01001000. 00011000 子网掩码：11111111. 11111111 . 00000000 因此相与可得 网络地址二进制：10001101. 00001110. 01000000. 00000000 网络地址十进制：141.14.64.0 求主机号： 首先观察子网掩码与默认子网掩码的区别，比如此题，这是B类的ip，子网掩码默认应为255.255.0.0，而实际为255.255.192.0，即拿出了一部分主机号作为子网号。 从子网掩码二进制可以看出第三节前2位与默认子网掩码不同，那么也就是拿出了2位主机号作为子网号，子网号2位，主机号14位。 由ip地址可以看出主机号为001000.00011000，再化成10进制。 ¶子网规划 例题 ¶构造超网(无分类编址CIDR) ¶背景 划分子网缓解了一定的困难，但是ipv4地址眼看就要耗尽，人们研究出了无分类域间路由选择CIDR。 ¶概念 CIDR使ip地址从三级编址再次变为二级编址，但是无分类的二级编址，不分A.B.C类。记法为： 12IP地址 ::=&#123;&lt;网络前缀&gt;，&lt;主机号&gt;&#125;a.b.c.d/x x为地址中网络部分的位数，32-x为主机位数。 此外，CIDR还采用斜线/记法,然后写上网络前缀所占的位数。 ¶应用 由CIDR的某个IP地址可以看出子网掩码。 ex:128.14.35.7/20 隐含的指出子网掩码中有20个1，由观察可知此地址是B类地址，默认子网掩码为255.255.0.0，32-20=12位主机号，则4位主机号，因此子网掩码为255.255.240.0 使用CIDR地址块后，网络路由器中的路由表项可以表示很多个传统IP地址的路由信息，相当于把若干个网络合并为一个超网来进行路由，这种地址的聚合称为路由聚合，也称为构造超网.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp可靠传输和流量控制的4种协议的演变史]]></title>
    <url>%2Ftcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%844%E7%A7%8D%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[¶前言 学习了计算机网络之后，发现很多基础知识其中的奥秘是经过前人一步步探索得来的，故而搜索了很多的资料，在这里用几篇博文进行总结。 首先要说到的就是tcp可靠传输和流量控制的4种协议，这4种协议从无到有，从最初的单工停等协议(停止等待ARQ协议)到连续ARQ协议、选择重传ARQ协议，直到最终的滑动窗口协议，经过了一系列的演变过程。本博文就来浅析一下它们的区别和演变过程。 ¶单工停等协议 ¶定义 即发送方每次发送完一个分组(此处可能是tcp报文也可能是MAC帧)就停止发送，等待接收方的确认，只有在收到确认之后才能够再发送下一个分组。 ¶具体描述 工作原理: 发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。(利用超时计时器计时) 在等待过程中，发送点停止发送新的数据包。 当数据包没有成功被接收点接收时候，接收点不会发送ACK.这样发送点在等待一定时间后，重新发送数据包。 反复以上步骤直到收到从接收点发送的ACK. 原理图如下: 如图1即在无差错的情况下，A发送，B接收，只有A收到B的确认时才可以发送下一个分组。如图2即出现差错时利用的一种机制叫做超时重传机制，B没有收到A的报文，A也没收到来自B的确认报文，经过一个设定时间后，超时计时器到期，那么就要重传。 如图3即当A的发送分组没有差错和丢弃，但是B的确认分组出现差错，那么A收不到确认也就无法判断是确认出错还是发送分组出错,因此B需要丢弃当前接收的分组，等待超时计时器到期A重新发送，而后接收。 如图4即B的确认没有出错或者丢失，只是因为信道拥塞导致延时到达，因此A无法收到确认y而是需要重新发送之前的发送分组。 ¶缺点 这个协议的缺点是较长的等待时间导致低的数据传输速度。在低速传输时，对连接频道的利用率比较好，但是在高速传输时，频道的利用率会显著下降。 ¶连续ARQ协议 ¶定义 为了克服停止等待协议需要长时间等待的缺点，故而出现了连续ARQ协议，它是指发送方维护着一个窗口,这个窗口中不止一个分组,有好几个分组,窗口的大小是由接收方返回的win值决定的,所以窗口的大小是动态变化的,只要在窗口中的分组都可以被发送,这就使得TCP一次不是只发送一个分组了,从而大大提高了信道的利用率.并且它采用累积确认的方式,对于按序到达的最后一个分组发送确认。 ¶具体描述 原理： 如图可知发送方维护一个5分组大小的窗口，只有收到接收方的一个确认后才将窗口向前挪动。 但是接收方由于累计确认方式,虽然一次性仍然只能接收一个确认分组，但是发送方不必等待接收方确认便可以再次发送。因此，接收方可以在收到几个分组之后，对按序到达的最后一个分组发送确认，这就表示到这个分组之前的所有分组都正确收到了。 重传机制： 采用回退N机制(Go-back-N)即GBN,表示凡是被发送出去尚未被确认的分组都放在发送方提供的较大的缓冲区内，若得到确认则取出。当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧。其中利用超时计时器，若在规定时间内没有收到对应的应答帧，或者累计的应答帧，那么就说明出错了。 ¶缺点 虽然连续ARQ的链路效率大大提升，但是相应的需要更大的缓冲空间，且接收方窗口大小总是1，浪费很多链路的带宽。 ¶选择重传ARQ协议 ¶定义 发送方据一个指定大小的窗口持续发送若干分组，即使发送过程中丢失分组，也会继续发送。和Go-back-N ARQ不一样，接收进程在出错后还是继续接收和确认帧。 ¶具体描述 基本原理： 如果一个发送的帧没有到达接收方，发送方继续发送后面的帧，直到它填满发送窗口 。接收方持续用接收的帧填充它的接收窗口，并且每次回复一个带有序列号的ACK帧。一旦发送窗口所有帧都发送了 ，发送方重新发送的帧号与ACK不对应的帧，然后继续。 如图可知在2号分组出错时，继续发送其他的分组，接收方同时也接收其他的分组，但是并不提交给上层，只有等待重传的分组到达之后，再按序提交给高层。 注意： 接收方窗口大小与发送方要相同，并且最大的窗口值取最大序列号的一半。 ¶缺点 通信信道的利用率不高，也就是说，信道还远远没有被数据比特填满。 是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送数据包来纠正错误的方法也严重的影响了它的传输速度。 ¶滑动窗口协议 ¶定义 滑动窗口协议实际是选择重传ARQ的特殊情况。 ¶前提 TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收)。 发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区； 发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据； 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送； ¶具体实现 原理图： 分析图中可以看出： 初始时发送窗口前沿是0，后沿也是0，因为前沿是指下一发送的序号，而后沿是指下一应答序号。 而初始时接收窗口前沿是1，后沿是0，因为前沿和后沿之间的部分是指下一期望接收的序号。 发送方前沿是发送完一个分组后就移动，后沿是收到接收确认分组之后才移动。 接收方的前后沿同时移动，当接收到一个分组之后就向后移动。 ¶4种协议的比较 单工停等 连续ARQ 选择重传ARQ 滑动窗口 应答帧是否需要编号 否 是 是 是 分组是否按序 是 是 是 是 发送窗口大小 1 &gt;1 &gt;1,最大值为最大确认序列号的一半 同选择重传ARQ 接收窗口大小 1 1 &gt;1,同发送窗口 同选择重传ARQ ¶参考资料： http://blog.csdn.net/guoweimelon/article/details/50879588 http://blog.csdn.net/wbw1985/article/details/4879224 http://pmghong.blog.51cto.com/3221425/1242470]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中静态类、抽象类和接口类的区别]]></title>
    <url>%2Fphp%E4%B8%AD%E9%9D%99%E6%80%81%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[¶前言 最近笔者学习了php的基本知识，其基本语法像极了c语言，但是取消了指针等特性，且操作起来更加简便。下面就浅析一下php面向对象中的特性：静态类、抽象类和接口以及很好用的代码复用技术trait。 ¶静态类 ¶静态类定义： 类中含有static修饰的方法或者属性的类。 ¶静态类的特性和易错点 静态类中的成员不用实例化对象访问。用类名：：属性名/方法名 访问。 实例化的对象只能访问静态方法，不可访问静态属性。 继承时子类可以继承父类的公有和受保护的方法和属性。 可以说静态方法和属性不属于这个类，所以不能用自引用指针$this去引用，但却可以通过self或者parent访问。 ¶实例 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Foo&#123; public $my = &quot;zy&quot;; public static $my_static = &apos;foo&apos;;//初始化附常量 public function staticValue() &#123; echo $this-&gt;my; //echo $this-&gt;my_static;这些属性不属于类 return self::$my_static; &#125; public static function handle() &#123; //$this-&gt;$my_static;静态方法中没有$this这个伪变量 echo &quot;这是静态变量\n&quot;; &#125; protected static function func() &#123; echo &quot;protected static\n&quot;; &#125;&#125;class Bar extends Foo&#123; public function fooStatic()&#123; return parent::$my_static; &#125; public function funn() &#123; echo self::func().&quot;\n&quot;;//继承了 &#125;&#125;echo Foo::$my_static.&quot;\n&quot;;echo Foo::handle().&quot;\n&quot;;$foo = new Foo();//echo $foo-&gt;$my_static.&quot;\n&quot;;//不可用对象直接访问静态属性echo $foo-&gt;handle().&quot;\n&quot;;//用对象可直接访问静态方法echo $foo-&gt;staticValue().&quot;\n&quot;;echo Bar::$my_static.&quot;\n&quot;;$bar = new Bar();echo $bar-&gt;fooStatic().&quot;\n&quot;;echo $bar-&gt;handle();$bar-&gt;funn();?&gt; ¶抽象类 ¶抽象类的定义 *** 被abstract修饰的类。*** ¶抽象类的特性和易错点 抽象类不可被实例化 任何一个类，若其中至少有一个抽象方法，那么该类就必须定义为抽象类，类中可以有非抽象的方法或属性。 抽象方法只声明其调用方式，不定义具体功能。 继承某个抽象类后，其子类必须实现所有的抽象方法，且不论函数名、参数都不能改变，但是继承访问控制可以一致或更宽松。 若子类继承的父类抽象方法中参数列表是可选参数，那么也可以与父类参数个数不一致，即子类可以有个默认参数列表。 ¶实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpabstract class AbstractClass&#123;//此类不可实例化对象 abstract protected function getValue(); abstract protected function prefixValue($prefix);//只声明，不作具体实现 abstract public function pre($han); const i = 12; public $a = 13; public function printOut() &#123; echo $this-&gt;a.&quot;\n&quot;; echo $this-&gt;getValue().&quot;\n&quot;; &#125;&#125; class ConcreteClass1 extends AbstractClass&#123; protected function getValue() &#123; return &quot;ConcreteClass1&quot;;//实现具体实现，必须保持一致 &#125; public function prefixValue($prefix) &#123; return &quot;$prefix.ConcreteClass1&quot;; &#125; public function pre($han,$ren = &apos;a&apos;) &#123; echo $han.$ren.&quot;\n&quot;; &#125;&#125;class ConcreteClass2 extends AbstractClass&#123; public function getValue() &#123; return &quot;ConcreteClass2&quot;; &#125; public function prefixValue($prefix) &#123; return &quot;&#123;$prefix&#125;ConcreteClass2&quot;; &#125; public function pre($han,$ren = &apos;a&apos;) &#123; echo $han.$ren.&quot;\n&quot;; &#125;&#125;$class1 = new ConcreteClass1;//继承抽象类的类才可以实例化$class1-&gt;printOut();echo $class1-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;$class1-&gt;pre(&quot;zy&quot;);//可以打印出默认的参数$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue(&apos;FOO_&apos;) .&quot;\n&quot;;echo AbstractClass::i;//同样可以输出常量，无法输出变量?&gt; ¶接口 ¶接口的定义 *** interface修饰的一个特殊的抽象类，但不是类。*** ¶接口特性和易错点 接口定义的所有方法都是空的 接口中的所有方法都是公有的，这是接口的特性 接口的定义使用interface，但是接口的实现就要用到implements,实现接口的实际是类 接口实现过程中要实现全部定义的接口 接口可以继承，用extends实现，与接口的实现不是一个意思,继承之后用类实现时要全部实现 接口中可以声明常量但是不可声明变量 可以说接口是特殊的抽象类，他里面的方法也是不实现功能的抽象类但是为了方便，不写abstract还有定义成interface而非类 一个类虽然是单继承的，但是一个类可以实现多个接口,多个接口之间用逗号隔开 ¶实例 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpinterface iTemplate &#123; const name = &quot;ha&quot;; public function setVariable($name,$var);//必须是公有的方法 public function getHtml($template); &#125; interface inTel&#123; public function handle(); &#125; //一个接口类可以实现多个定义的接口 class Template implements iTemplate,inTel&#123; private $vars = array(); public function setVariable($name,$var) &#123; $this-&gt;vars[$name] = $var; &#125; public function getHtml($template) &#123; foreach($this-&gt;vars as $name =&gt; $value) &#123; $template = str_replace($name,$value,$template);//把字符串template中的name字符换成value &#125; return $template; &#125; public function handle() &#123; echo &quot;handle things\n&quot;; &#125; &#125;//用一个类去实现接口 //$te = new iTemplate();因为是一种特殊的抽象类，因此也是不能实例化对象的 $tel = new Template(); $tel-&gt;setVariable(&apos;zy&apos;,&apos;人才&apos;); echo $tel-&gt;getHtml(&apos;zyzsddw&apos;).&quot;\n&quot;; $tel-&gt;handle(); echo iTemplate::name;//输出接口中定义的常量 ?&gt; ¶trait ¶trait的定义 Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制 ¶trait的特性和易错点 trait是一种代码复用技术，相当于一种池技术，把好多功能(方法)写在其中，用的时候调用即可。可代替继承技术 他的调用优先级高于继承后的同名方法的优先级 它本身无法进行实例化 可以同时有多个trait，类中use声明时用逗号隔开 trait也可以使用多个trait作为成员 不可以声明静态成员，可在方法中定义静态变量 ¶实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass Base&#123; public function sayHello()&#123; echo &apos;hello&apos;; &#125;&#125;trait mysay&#123; public function mysays() &#123; echo &quot;this is my says\n&quot;; &#125;&#125;trait SayWorld&#123;//声明方式相当于一个类 //static public $c = 1;除非定义在方法中 public $name = &quot;zy&quot;; public function sayHello()&#123; parent::sayHello(); echo &quot;World\n&quot;; &#125; public function says()&#123; echo &quot;zwdfw\n&quot;; &#125; public static function func() &#123; static $c = 1; echo &quot;$c.this is static\n&quot;; &#125; protected function sayno() &#123; echo &quot;sayno&quot;.&quot;\n&quot;; &#125; abstract public function getworld();//允许定义抽象方法&#125;class Myhello extends Base&#123; use SayWorld,mysay;//用这种方式调用trait,相当于把所有的方法都继承到了 public function getworld() &#123; echo &quot;nihao world\n&quot;;//使用了trait就要实现抽象方法 &#125;&#125;$foo = new Myhello();$foo-&gt;sayHello();//优先级高于继承来的同名方法$foo-&gt;says();//随意调用其中的方法//$foo-&gt;sayno();//私有方法和受保护的方法无法从trait中获取$foo-&gt;func();$foo-&gt;mysays();mysay::mysays();//无法实例化trait的对象访问，可以用trait名::方法/变量的形式访问echo $foo-&gt;name.&quot;\n&quot;;//echo $foo-&gt;c.&quot;\n&quot;;?&gt; ¶这四种php中oo特性的代表的区别 静态类 抽象类 接口 trait 是否可以实例化对象 是 否 否 否 类外访问方式 1.类名::属性/方法 2.对象名-&gt;方法 子类继承实现，实例化子类，子类对象调用属性/方法 子类implements实现，子类实例化对象调用属性/方法 类中use实现，类外实例化对象调用属性/方法 方法是否立即实现 类内外都可以 子类实现 子类实现 类内外都可以 方法的访问控制 都可以 抽象方法公有或者受保护，普通方法都可以 均为公有 都可以 实现方式 类内类外都可以 子类继承实现 子类继承实现 内部实现 是否可以声明常量/变量 都可以 都可以，但变量无法类外访问 常量可以，变量不可以 都可以]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探寻psr标准]]></title>
    <url>%2F%E6%8E%A2%E5%AF%BBpsr%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[¶前言 笔者学习symfony框架，看源码之时，发现好多函数带有psr的后缀，心想这是个什么东东。。。于是乎google了一番，发现这正是“心仪已久”的PHP开发的标准规范啊！！！ 但是好多东西在对应的官方文档PSR标准规范文档都有，因此笔者在此只做代码的示范，用代码来表示规范。 ¶简介 PSR 是 PHP Standard Recommendations 的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。 目前已表决通过了 6 套标准，已经得到大部分 PHP 框架的支持和认可。 标准目录如下： ¶详解 ¶基本代码规范和编程风格规范 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php /** * psr标准中的大部分语言规范 * * @author zy *///php代码文件必须以这个标签或者&lt;?= 开始//每行的字符数控制在80~120之间namespace Vender\Package;//命名空间块后都有一个空行，命名空间和子命名空间必须和相应的文件基目录(文件绝对路径)匹配。namespace Symfony\Component\Routing;//完整的类名必须有个顶级命名空间和一个或多个子命名空间，末尾的类名与对应的.php文件同名use Symfony\Component\Routing\Route;use FooInterface;//use语句后面也要有一行空行,use务必声明在namespace之后//类名必须遵循StudlyCaps大写驼峰命名法即多个单词组成名字每个单词首字母大写class FooFunction extends Bars implements FooInterface, \ArrayAccess, \Countable&#123;//多实现可以多行显示，但是要有缩进，且每个接口自成一行 //类的前后花括号均自成一行 public $superStar;//每个属性都要添加访问修饰符 public $commonPeople;//类的普通属性用哪种命名方式均可，但要统一 protected $files = null;//null,true,false这些关键字都小写 const MAX_COUNT = 120;//const定义的变量必须大写且单词间用下划线分隔 //方法名遵循camelCase式的小写驼峰命名法即多个单词组成名字时首单词小写，之后的每个单词首字母大写 public function sampleFunction($a, $b = null) &#123;//方法的前后花括号也均自成一行 //缩进时不能使用tab要用4个空格进行缩进 if ($a === $b) &#123; //控制结构诸如if-else，switch-case，while，for，foreach等等书写时这些关键字后要有一个空格 //前括号之前也要有一个空格，且前括号在关键字同一行，后括号自成一行 bar(); &#125; elseif ($a &gt; $b) &#123;//变量与运算符之间要有空格 $foo-&gt;bar($arg1); &#125; else &#123; BazClass::bar($arg2, $arg3);//方法的参数每个逗号后必须要有一个空格，有默认值的放到参数列表末尾 &#125; &#125; //参数列表可以单独一行,结束括号必须和方法前花括号自成一行,final、abstract必须在访问修饰符前面，static在访问修饰符之后 final public static function aVeryLongMethod( ClassTypeHint $arg1, &amp;$arg2, array $arg3 = [] )&#123; switch ($expr) &#123;//case相对switch要有缩进 case 0: echo &apos;xxxxxxx&apos;;//执行语句相对case也要缩进 break; case 1://遇到这种case没有break的直穿语句，要有no break的注明 echo &apos;second&apos;; //no break case 2: case 3: echo &apos;third&apos;; break; default: echo &quot;default case&quot;; break; &#125; &#125; public function simpleFunction() &#123; while ($exp) &#123;//同样的诸如do-while，try-catch控制结构需要相同的结构 echo &apos;zzz&apos;; &#125; $clouseWith = function ($arg1, $arg2) use ($var1, $var2) &#123; /*对于闭包函数也就是匿名函数，function后要有一个空格，use的前后都要有一个空格，并且前括号要和关键字在同一行， 但后括号单独成行*/ &#125;; &#125;&#125;/*诸如此类产生副作用的操作，ex： 生成输出 直接的 require 或 include 连接外部服务 修改 ini 配置 抛出错误或异常 修改全局或静态变量 读或写文件等的操作不能和声明类、函数等在同一个php文件下include &quot;file.php&quot;;echo &quot;&lt;html&gt;\n&quot;;ini_set(&apos;error_reporting&apos;,E_ALL);*///纯php代码文件最后必须省略“?&gt;”标签//同时php文件最后必须要有一行空行作为结束 ¶其他规范 其他规范都是在框架或者项目中需要用的诸如日志、自动加载、缓存规范。因此就不在此赘述，贴出官方的规范：https://psr.phphub.org/]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC之管道通信的dup和dup2函数]]></title>
    <url>%2FIPC%E4%B9%8B%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%9A%84dup%E5%92%8Cdup2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[¶前言： 前面笔者详细分析了网络编程中重要的通信技术：I/O复用技术,接下来的几篇文章，我将重点来分析一下网络编程中另外一个重要的技术，即：管道通信技术。 ¶dup、dup2函数基础 由于利用管道实现进程间通信，是通过创建2个文件描述符，但是初始化文件描述符都是随机的，或者说是从可用的文件描述符中去除，并与相对应的文件建立映射关系，如果我们想要将管道的两头与其他流相关，或者说重定向一个文件描述符，那么，我们就需要dup和dup2函数。 可以说，这两个函数的作用就是： 1.重定向文件描述符 2.复制文件描述符 ¶dup函数： 12#include&lt;unistd.h&gt;int dup(int fd);//fd为文件描述符，失败返回-1 dup函数创建一个新的文件描述符，该文件描述符和原有文件描述符指向相同的文件、管道或者网络链接，并且此fd总是系统当前可用的最小的文件描述符。 ¶dup2函数： 123#include&lt;unistd.h&gt;int dup2(int fd1, int fd2);//fd1是指需要重定向的文件描述符，fd2是定向到的文件描述符。失败返回-1 dup2函数中fd2不做原本的工作，而改做fd1的工作，若此fd2文件描述符已经存在，则需要关闭他，再执行。 需要注意的是：这两个函数创建的文件描述符并不继承原有的文件描述符的属性(ex：close_on_exec,non-blocking等)，因为每个文件描述符都有一套文件描述符标志，新描述符执行时关闭(close_on_exec)标志总是由dup和dup2函数执行。只继承他的同一文件状态标志(读、写、添加等)。 其实对于文件描述符在内核中的存储有必要提一下： 每个进程在进程表中都有一个记录项，每个记录项中有一张打开文件描述符表，可将视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是： (1) 文件描述符标志(close_on_exec,close_on_exec是一个进程所有文件描述符的标记位图，每个比特位代表一个打开的文件描述符，用于确定在系统调用execve()时需要关闭的文件句柄)。 (2) 指向一个文件表项的指针。 内核为所有打开文件维持一张文件表。每个文件表项包含： (a) 文件状态标志(读、写、增写、同步、非阻塞等)。 (b) 当前文件位移量。 © 指向该文件v节点表项的指针。 节点表项。每个打开的文件都有一个v-node结构，v-node中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，V-node中还包含了文件inode节点信息，这些信息是打开文件时从磁盘上读入内存的，所以文件所有信息都是随时可用的。 1. v节点的信息 2. 当前文件的长度 3. i节点的信息 **也就是对应下图。 图解过程： 假设执行了dup(1)函数，下一个可用的文件描述符是3。两个文件描述符指向同一文件表项。因此文件状态标志、当前文件位移量、指向文件的v节点表项指针共享。 ¶函数的简单实例： 下面的例子便是运用dup函数或者dup2函数，将新建的文件描述符指向之前建立好的网络连接，因为关闭了标准输出，因此文件描述符1空闲下来，可以使用，即相当于将标准输出定向到了网络连接中，实现CGI服务器功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243int main(int argc, char* argv[])&#123; if(argc &lt;= 2) &#123; printf(&quot;error\n&quot;); return 1; &#125; const char* ip = argv[1]; int port = atoi(argv[2]); struct sockaddr_in address; bzero(&amp;address,sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET,ip,&amp;address.sin_addr); address.sin_port = htons(port); int sock = socket(PF_INET,SOCK_STREAM,0); assert(sock &gt;= 0); int ret = bind(sock,(struct sockaddr*)&amp;address,sizeof(address)); assert(ret != -1); ret = listen(sock,5); assert(ret != -1); struct sockaddr_in client; socklen_t client_addrlength = sizeof(client); int connfd = accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength); if(connfd &lt; 0) &#123; printf(&quot;errno is %d\n&quot;,errno); &#125; else &#123; close(STDOUT_FILENO); dup(connfd);//自动寻找最小的文件描述符 //dup2(connfd,1);//自己指定文件描述符，若已存在，则返回一个大于指定文件描述符的最小值 printf(&quot;abcd\n&quot;); close(connfd); &#125; close(sock); return 0;&#125; 利用telnet模拟客户端可以看出，的确本应该输出到标准输出的字符，送到了客户端，而没有打印到终端。实现了重定向功能。]]></content>
      <categories>
        <category>IPC进程通信</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O复用3个模型的比较]]></title>
    <url>%2FI-O%E5%A4%8D%E7%94%A83%E4%B8%AA%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[¶前言： 前面分析了I/O复用的3种模型，分别是select，poll，epoll，它们各有优缺点，并且应用广泛，今天就来分析一下他们的异同。 ¶开场： 分析之前还是讲一讲I/O复用在网络程序下的适用场合： 服务器同时监听socket和连接socket。 服务器端同时处理多个socket。 客户端程序同时处理用户输入和网络连接。 服务器同时处理TCP和UDP请求。 服务器监听多个端口，或者处理多个服务。 I/O复用函数本身是阻塞的，它们必须顺序处理每个就绪的文件描述符，要想实现并发执行，要用到多线程/多进程编程。但I/O复用的优势也是在此,不必创建大量进程或者线程，也不必去维护它们，大大节约系统资源。 ¶渐进： 三者的共同点： 这3种模型都能同时监听多个文件描述符，他们等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有时间就绪时返回，返回就绪的数量。 3者都是同步I/O模型，即在监听事件就绪后也需要自己来负责读写。 3者都通过某种结构体变量来告知内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。 ¶高潮： 三者的区别： poll、select是有事件就绪后就轮询所有的结构体数组中的文件描述符，看是否发生了感兴趣的事件。并将其中就绪的文件描述符返回给用户程序而epoll是有事件就绪后内核事件表将就绪事件放到一个结构体数组中，仅仅轮询这些就绪事件。即epoll_wait采用回调的方式，内核检测到就绪的文件描述符后，就触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。最后在适当时间将内容拷贝到用户空间。 select参数类型fd_set 没有将文件描述符和事件进行绑定，它仅仅是一个文件描述符集合。而epoll、poll是将文件描述符和事件放入一个结构体中，实现了绑定。 epoll最大的区别是实现了用户注册事件和内核检测就绪事件的分离，搜索就绪事件只搜索返回的就绪事件。epoll是通过内核与用户空间mmap同一块内存实现的。而select、poll需要轮询所有文件描述符或者其一一对应的注册事件。 epoll适用于连接数量多，但活跃链接少的情况。select适用于并发量不高，且活跃链接多的情况。 另外还有几个小区别，请看下表： ¶尾声 浅析三者的工作流程：]]></content>
      <categories>
        <category>IPC进程通信</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O复用之poll和epoll]]></title>
    <url>%2FI-O%E5%A4%8D%E7%94%A8%E4%B9%8Bpoll%E5%92%8Cepoll%2F</url>
    <content type="text"><![CDATA[¶poll函数 poll函数的定义： 12345678910#include&lt;poll.h&gt;int poll(struct pollfd* fds,nfds_t nfds,int timeout)typedef unsigned long int nfds_t;struct pollfd&#123; int fd; short events;//注册的事件 short revents;//实际发生的事件，有内核填充&#125;;timeout为0时，poll调用后立即返回，不阻塞 为-1时，poll调用将永远阻塞，直至某个事件发生。 poll函数实现监视的过程： 调用poll函数实现对感兴趣的文件描述符的某个事件的监听。 而后读取返回值，若返回值大于0，则轮询创建好的pollfd结构体数组，看每一个注册的事件是否发生感兴趣的事件。 ¶epoll函数 ¶epoll函数的定义： epoll函数不同于poll和select，它是由一组函数组成的。 1. epoll创建函数： 12#include&lt;sys/epoll.h&gt;int epoll_create(int size)//参数指定内核事件表的大小,返回一个指向内核事件表的fd：epollfd 2. epoll执行注册函数： 1234/*第一个参数为内核事件表的文件描述符，第二个参数为指定的操作类型,第三个为要操作的文件描述符，第4个为注册的事件*///返回0为成功，-1为失败int epoll_ctl(int epollfd,int op,int fd,struct epoll_event *event) 对于op操作类型，大体有3种： EPOLL_CTL_ADD:往内核事件表注册事件结构体 EPOLL_CTL_MOD:修改fd上的注册事件 EPOLL_CTL_DEL:删除fd上的注册事件 对于epoll_event结构体： 12345678910typedef union epoll_data&#123; void *ptr; int fd;//注册事件的文件描述符 uint32_t u32; uint64_t u64;&#125;epoll_data_t; struct epoll_event&#123; __uint32_t events;//epoll事件 epoll_data_t data;//用户的数据&#125;;//一般是将事件和epoll_data_t用户数据绑定 3. epoll等待就绪函数： 1234/*第一个参数指定内核事件表，第二个参数指定从内核事件表拷贝的就绪事件数组，第三个参数指定最多监听的事件个数，最后一个是设置超时时间同epoll*///该函数成功时返回就绪事件个数，与文件描述符无关，失败返回-1int epoll_wait(int epollfd,struct epoll_event* events, int max,int timeout) 4.epoll的事件类型 EPOLLIN ：数据可读（包括一般和优先数据） EPOLLOUT ：数据可写（包括一般和优先数据） EPOLLERR ：数据错误 EPOLLET ：epoll的边沿触发模式事件 EPOLLONESHOT ：该文件描述符上的可读、可写、错误事件最多触发其中一个且只触发一次 最后两个是epoll特有的，前三个去掉’E’即为poll的事件类型 5.epoll的模式： epoll中有两种模式，一种是LT模式，一种是ET模式。 LT模式： 所谓LT模式，就是指电平触发，这是epoll默认的工作方式，要想改变可以通过上面的EPOLLET事件。这种模式下的epoll相当于一个效率较高的poll。**这个模式下epoll_wait检测到有事件就绪后，应用程序可以不立即处理，那么下次调用epoll_wait仍会通告该事件，直至被处理。意味着每次epoll_wait()返回后，事件处理后，如果之后还有数据，会不断触发，也就是说，一个套接字上一次完整的数据，epoll_wait()可能会返回多次，直到没有数据为止。**这个模式下文件描述符可阻塞可不阻塞。该模式下只要在可读/可写 状态下epoll_wait都能检测到，因此可以不一次处理完。 ET模式 : 所谓ET模式，就是指边沿触发，当某个文件描述符注册EPOLLET事件时，eopll将使用ET模式操作该文件描述符。有数据过来后，epoll_wait()会返回一次，**一段时间内，该套接字就算有数据源源不断地过来，epoll_wait()也不会返回了。（即只会读出其中第一次的内容，再来数据是读不到的，但若是缓冲区不够的话，也会读到结束的）这里注意，是一段时间，不代表这个套接字上有数据就只触发一次。时间过长，还是会返回多次的。该模式与LT的最大区别就是当epoll_wait检测到事件就绪时，必须立即处理，后序再遇到epoll_wait不会在通告该事件，这样大大降低了同一个epoll事件被触发的次数。**该模式下文件描述符必须使用非阻塞。这种模式下发送多次否则，会因为缓冲区的不足造成发送或接收不到所有的数据。直到errno为EAGAIN时才算读(写)取完毕无数据可读(写）另外，该模式只有当某文件描述符由不可读/不可写 状态变为 可读/可写 状态时才能触发 因此，ET模式是高速工作模式，LT是缺省工作模式。 6.网络事件EAGIN 在一个非阻塞的socket上调用read/write函数, 返回EAGAIN或者EWOULDBLOCK。若遇到能read时，读缓冲区没有数据，或者write时，写缓冲区满了。这种情况下，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。 因此，对于non-blocking的socket，正确的读写操作为: 读：忽略掉errno = EAGAIN的错误，下次可继续读 写：忽略掉errno = EAGAIN的错误，下次可继续写 因此ET模式使用非阻塞IO模型下需要用EAGAIN这个标志来判断接受的数据是否读完。]]></content>
      <categories>
        <category>IPC进程通信</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体变量malloc的故事]]></title>
    <url>%2F%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8Fmalloc%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[这是一个关于结构体通过malloc初始化的悲伤的故事 ¶背景 因为本身结构体是不需要malloc就可以直接创建其对象，但是，当结构体中出现柔性数组或者是数组指针时，情况就截然不同了。因为这些数组都是要动态分配内存的，因此结构体也需要malloc。 ¶问题描述： 但是此时问题就出现了，本身创建结构体对象时会在栈区分配一块地址，但是malloc之后又有另外一块地址指向了此对象，这是该怎么办呢？ ¶代码实例： 12345678910111213141516171819202122232425262728/*这仅仅是个用数组动态创建栈的初始化过程*/#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;typedef struct stack&#123; int top; int count; int array[];//柔性数组，也可以方括号内定义为0，也可以定义为数组指针&#125;Stack;void Init(Stack *s,int n)&#123; s = (Stack*)malloc(sizeof(Stack) + n * sizeof(int)); s-&gt;top = -1; s-&gt;count = n;&#125;void Destroy(Stack **s)&#123; free(*s); *s = NULL;&#125;int main()&#123; Stack s; Stack *q = &amp;s; Init(q); Destroy(&amp;q); return 0;&#125; ¶gdb调试显示结果： 由图中可以看出原本传入Init函数的stack的地址为0x7fffffffde00，但malloc出来的新地址为0x602830,改变malloc出来地址上的内容，函数返回时自然而然没有保存下来。 再次打印s的地址，果然还是原地址，相应数据也没有保存下来 ¶解决方案： 思路: 既然一级指针会在init函数中被重新malloc，之后返回后保存不下来，那么可以启用2级指针，之后，让malloc出来的指针和原指针的地址相同(即2级指针也指向malloc出来的指针)这样返回时才能真正将malloc出来的指针保存下来。 具体解决方法 重写init方法: 1234567void Init(Stack **s,int n)&#123; Stack *p = (Stack *)malloc(sizeof(Stack) + n * sizeof(int));//新malloc出一块地址指向原来的结构体 *s = p; //将新malloc出来的地址赋值给原地址，让两个变成同一地址 p-&gt;top = -1; p-&gt;count = n;&#125; ¶图解： 此时再次调用gdb调试： 可以看出当从init函数返回后q指针已经变为malloc出来的地址，由此数据也被保存了下来。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中类的大小]]></title>
    <url>%2Fc%2B%2B%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[*** 类所占内存的大小是有成员变量（静态变量除外）决定的，成员函数是不计算在内的，他们只是名义上在类里，其实同一个类的多个对象共享函数代码，而我们访问类的成员函数是通过类中的自引用指针实现的，所以我们访问成员函数是间接获得地址的。 *** ¶空类 空类的大小为1： 目的标示这个类，c++要求每个实例在内存中都具有独一无二的地址。 ¶普通类(不继承，不含虚函数） 跟struct的原理一致，内存对齐原则，但静态变量不占用内存，原因是编译器将其放在了全局变量区。 ¶含有虚函数的类 c++类中有虚函数的时候有一个指向虚函数的指针(vptr),因此此指针要占用字节空间，虚函数个数和大小无关。 ¶继承的类 子类的大小是本身成员变量的大小加上父类的大小，若父类本身就含有虚函数，则子类无论有没有虚函数都不能算上。 当继承空类时，不加上空类的大小，而是只算本身子类的大小。 ¶实例（注：笔者是在64位操作系统下操作得出的结果 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;class cBase&#123;&#125;; //标识存在为1class cBase1&#123; int a; char p;&#125;;//内存对齐，4个字节和1个字节，1字节按4字节算class cBase2&#123; public: cBase2(); virtual ~cBase2();//virtual开辟一块指针，因此为8 private: int a;//4，因内存对齐则为8 char *p;//8&#125;;class c:public cBase&#123; virtual void fun() = 0;//纯虚函数&#125;;class b&#123;&#125;;class d:public b,public c&#123;&#125;;//共享虚函数的指针int main()&#123; cout &lt;&lt; &quot;cBase类的大小:&quot; &lt;&lt; sizeof(cBase) &lt;&lt; endl; cout &lt;&lt; &quot;cBase1类的大小:&quot; &lt;&lt; sizeof(cBase1) &lt;&lt; endl; cout&lt;&lt; &quot;cBase2类的大小:&quot; &lt;&lt; sizeof(cBase2) &lt;&lt; endl; cout&lt;&lt; &quot;c类的大小:&quot; &lt;&lt; sizeof(c) &lt;&lt;endl; cout &lt;&lt; &quot;d类的大小:&quot; &lt;&lt; sizeof(d) &lt;&lt;endl; return 0;&#125; 结果为： cBase类的大小：1 cBase1类的大小：8 cBase2类的大小：24 c类的大小：8 d类的大小：8]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程同步机制之互斥锁和条件变量]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[¶线程同步 Pthread是POSIX threads 的简称，是POSIX的线程标准。 Pthread线程同步指多个线程协调地，有序地同步使用共享资源。多线程共享进程资源，一个线程访问共享资源需要一段完整的时间才能完成其读写操作，如果在这段时间被其他线程打断，就会产生诸多不可预知的错误。 ¶互斥锁 ¶1.互斥量： 互斥量是一种线程同步对象，“互斥”的含义是同一时刻只能有一个线程获得互斥量。一个互斥量对应一个共享资源，互斥量状态：1.解锁状态意味着共享资源可用，2.加锁状态意味着共享资源不可用。 一个线程需要使用共享资源时，使用thread_mutex_lock申请：1.当互斥量为解锁状态，则占用互斥量，并给互斥量加锁，占用资源（互斥量为加锁状态，其他线程不能使用互斥量并等待互斥量变为解锁状态），2.如果互斥量为加锁状态，则线程等待，直到互斥量为解锁状态（其他线程使用完共享资源后会解锁互斥量，释放资源）。 ¶2.临界区： 临界区指的是一个访问共用资源的程序片断。通常由定义一个互斥量并加锁来保护这段临界区代码。 ¶3.互斥量的相关函数： 首先定义互斥量的结构体pthread_mutex_t。 1). 互斥量初始化函数： 12#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr) 第一个参数即互斥量结构体的指针，第二个变量则是互斥量的属性（当为NULL时是默认属性）。成功返回0，失败返回错误码。 2). 互斥量上锁函数： 12#include&lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex) 此函数参数即互斥量结构体，返回成功为0，失败返回错误码。 是阻塞的上锁函数。 3). 互斥量解锁函数： 12#include&lt;pthread.h&gt;int pthread_mutex_unlock(pthread_mutex_t *mutex) 参数和返回值同上锁函数。 4). 互斥量的另一种上锁函数 12#include&lt;pthread.h&gt;int pthread_mutex_trylock(pthread_mutex_t *mutex) 这是上锁函数的非阻塞版本。若已经上锁，返回EBUSY。 5). 互斥量的销毁函数 12#include&lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex) 参数和返回值同上锁函数。 ¶条件变量 ¶1.概念 条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。 ¶2.条件变量的相关函数 首先定义条件变量结构体pthread_cond_t 1). 条件变量初始化函数 12#include&lt;pthread.h&gt;int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr) 第一个参数即条件变量结构体指针，第二个变量即条件变量的属性（如果为NULL，则是默认属性）。成功返回0，失败返回错误码。 2).条件变量的销毁函数 12#include&lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond) 第一个参数即条件变量结构体指针。返回值同初始化函数。 3). 条件变量的广播函数 12#include&lt;pthread.h&gt;int pthread_cond_broadcast(pthread_cond_t *cond) 参数和返回值同销毁函数。 此函数以广播的方式唤醒所有等待目标条件变量的线程。 4). 条件变量的信号函数 12#include&lt;pthread.h&gt;int pthread_cond_signal(pthread_cond_t *cond) 参数返回值同销毁函数 此函数用于唤醒一个等待目标变量的线程。至于哪个线程被唤醒，则取决于线程的优先级和调度策略。 5). 条件变量的等待函数 12#include&lt;pthread.h&gt;int pthread_cond_wait(pthread_cond_t *cond) 参数和返回值同销毁函数。 在调用此函数之前必须保证互斥量已经加锁。 重点：模拟等待函数（pthread_cond_wait)调用前后的过程 第一个线程首先调用： pthread_mutex_lock(&amp;mymutex); 然后，它检查了列表。没有找到感兴趣的东西，于是它调用： pthread_cond_wait(&amp;mycond, &amp;mymutex); 然后，pthread_cond_wait() 调用在返回前执行许多操作： pthread_mutex_unlock(&amp;mymutex); 它对 mymutex 解锁，然后进入睡眠状态，等待 mycond 以接收 POSIX 线程“信号”。一旦接收到“信号”（加引号是因为我们并不是在讨论传统的 UNIX 信号，而是来自 pthread_cond_signal() 或 pthread_cond_broadcast() 调用的信号），它就会苏醒。但 pthread_cond_wait() 没有立即返回——它还要做一件事：重新锁定 mutex： pthread_mutex_lock(&amp;mymutex); pthread_cond_wait() 知道我们在查找 mymutex “背后”的变化，因此它继续操作，为我们锁定互斥对象，然后才返回。 ¶3.代码示例（互斥锁和条件变量一起用实现线程同步） 程序思路： 在这里利用多线程技术实现生产者和消费者问题，生产者线程向一缓冲区中写数据，消费 者线程从缓冲区中读取数据，由于生产者线程和消费者线程共享同一缓冲区，为了正确读 写数据，在使用缓冲队列时必须保持互斥。生产者线程和消费者线程必须满足：生产者写 入缓冲区的数目不能超过缓冲区容量，消费者读取的数目不能超过生产者写入的数目。 在程序中使用了一个小技巧来判断缓冲区是空还是满。在初始化时读指针和写指针为0; 如果读指针等于写指针,则缓冲区是空的;如果(写指针+ 1) % N 等于读指针,则缓冲区是满的, %表示取余数,这时实际上有一个单元空出未用。下面是完整的程序段和注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt;#include&lt;pthread.h&gt; #include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#define BUFFER_SIZE 8 #define OVER (-1)#if 0//互斥量和条件变量综合的结构体struct prodcons &#123; int buffer[BUFFER_SIZE]; pthread_mutex_t lock; //互斥LOCK int readpos , writepos; //定义写和读的位置 pthread_cond_t notempty; //缓冲区非空条件判断 pthread_cond_t notfull; //缓冲区未满条件判断&#125;;//获取时间的函数char * get_time(void)&#123; time_t rawtime; struct tm * timeinfo; time(&amp;rawtime); return asctime(localtime(&amp;rawtime));&#125;//对结构体初始化函数void init(struct prodcons * b)&#123; pthread_mutex_init(&amp;b-&gt;lock,NULL); pthread_cond_init(&amp;b-&gt;notempty,NULL); pthread_cond_init(&amp;b-&gt;notfull,NULL); b-&gt;readpos=0; b-&gt;writepos=0;&#125;//放数据的函数void put(struct prodcons* b,int data)&#123; pthread_mutex_lock(&amp;b-&gt;lock); if((b-&gt;writepos + 1) % BUFFER_SIZE == b-&gt;readpos)//这是缓冲区满了的情况，留一个空用于发送-1这个信号 &#123; pthread_cond_wait(&amp;b-&gt;notfull, &amp;b-&gt;lock); &#125;// pthread_mutex_lock(&amp;b-&gt;lock);// 大家仔细理解互斥锁的位置，以及pthread_cond_wait函数的内核实现（解锁，休眠让出cpu，条件满足后被内核唤醒，上锁，形成临界区，保护资源） b-&gt;buffer[b-&gt;writepos]=data; b-&gt;writepos++; if(b-&gt;writepos &gt;= BUFFER_SIZE) b-&gt;writepos=0; printf(&quot;put %d at %s \n&quot;, data, get_time()); pthread_mutex_unlock(&amp;b-&gt;lock); pthread_cond_signal(&amp;b-&gt;notempty);&#125;//取数据的函数int get(struct prodcons *b)&#123; int data; pthread_mutex_lock(&amp;b-&gt;lock); if(b-&gt;writepos == b-&gt;readpos) &#123; printf(&quot;0 == 0\n&quot;); pthread_cond_wait(&amp;b-&gt;notempty, &amp;b-&gt;lock); printf(&quot;start read \n&quot;); &#125; data = b-&gt;buffer[b-&gt;readpos]; b-&gt;readpos++; if(b-&gt;readpos &gt;= BUFFER_SIZE) b-&gt;readpos=0; printf(&quot;get the data is : %d\n&quot;, data); pthread_cond_signal(&amp;b-&gt;notfull); pthread_mutex_unlock(&amp;b-&gt;lock); return data;&#125;//定义全局结构体对象struct prodcons buffer;//生产者回调函数void *producer(void *data)&#123; int n; for(n = 0; n &lt; 10; n++) &#123; printf(&quot;before produce %d \n&quot;, n) ; put(&amp;buffer, n); &#125; put(&amp;buffer, OVER);//发信号说-1已经放进去了，说明没内容写了 return NULL;&#125;//消费者回调函数void *consumer(void * data)&#123; int d; while(1) &#123; d = get(&amp;buffer); if(d == OVER)//说明生产者已经写完 break; printf(&quot;consumerd the num is %d\n&quot;, d); &#125; return NULL;&#125;//主函数int main(void)&#123; pthread_t th_a, th_b; pthread_attr_t attr; void *retval; pthread_attr_init(&amp;attr); init(&amp;buffer); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);// pthread_create(&amp;th_b, &amp;attr, consumer, 0); pthread_create(&amp;th_b, NULL, consumer, 0); sleep(3); pthread_create(&amp;th_a, NULL, producer, 0); pthread_join(th_a, &amp;retval); pthread_join(th_b, &amp;retval); sleep(100); return 0;&#125; 由图中可以看出，当条件变量不空不满足条件时，调用了等待函数使得此线程睡眠，让出cpu，进行其他操作，但是当条件满足时并不是直接回到原线程进行到的地方，而是重新加锁，在读。 参考资料： http://blog.csdn.net/shanshanpt/article/details/ http://blog.csdn.net/lovecodeless/article/details/24885127 http://blog.sina.com.cn/s/blog_590be5290100ikh5.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析多线程并发及写微信红包遇到的问题]]></title>
    <url>%2F%E6%B5%85%E6%9E%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%8F%8A%E5%86%99%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[¶多线程并发 众所周知，多线程编程很容易遇上诸如丢失更新、脏读、死锁等烦人的线程冲突问题。多线程的问题一旦发生便很难定位和解决，所以要在编程的初始阶段就要注意避免多线程程序常见的错误。 微信红包程序应用线程基础API，采用多线程并发的方式进行抢红包操作。 多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。 ¶微信红包程序 思路： 创建抢红包人员的结构体，分别给定名字，所抢金额，以及是否已抢过字段。 创建生产者线程，用于产生红包，红包金额和红包数目从标注输入读入，并对生产者回调函数进行加锁操作。 创建多个消费者线程，用于多人抢红包操作，其中消费者回调函数进行红包的随机分配算法，并进行加锁操作。 下面是部分代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 /*结构体部分*/ typedef struct person &#123; int id; char name[20]; int flag; int money; &#125;Person;/* 生产者回调函数*/ void *producer(void* value)//生产者只负责产生红包金 额和红包个数 &#123; double n = *(double*)value; pthread_mutex_lock(&amp;lock); money = n; pthread_mutex_unlock(&amp;lock); pthread_exit(NULL); &#125;/*消费者回调函数*/ void *consumer(void *n)//消费者用于随机获取红包个数 &#123; int nn = *(int*)n; pthread_mutex_lock(&amp;lock); printf(&quot;number%d\n&quot;,nn); if(money &gt; 0 &amp;&amp; per[nn].flag == 0)//还没抢过 &#123; if(num &gt; 1) &#123; srand((unsigned)time(NULL));//初始化随机数种子 double avg = money / num;//获取平均值 double t = avg*2; double randmoney = (rand()%(int)(t*100) + (int)MIN*100)/100.00 + MIN;//初始化随机数 money-=randmoney; printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,randmoney); printf(&quot;剩余%.2lf元\n&quot;,money); per[nn].id = nn; per[nn].money = randmoney; per[nn].flag = 1; num--; &#125; else &#123; printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,money); printf(&quot;剩余0元\n&quot;); money = 0; per[nn].id = nn; per[nn].money = money; per[nn].flag = 1; num--; &#125; &#125; pthread_mutex_unlock(&amp;lock); pthread_cancel(pthread_self()); &#125;/*主函数中主要线程API使用部分*/ pthread_t th_a,th_b[Total]; pthread_mutex_init(&amp;lock,0); pthread_create(&amp;th_a,NULL,producer,(void*)&amp;value); pthread_join(th_a,NULL); int args[Total]; for(i = 0; i &lt; Total;i++) &#123; args[i] = i; if(per[i].flag == 0) &#123; pthread_create(&amp;th_b[i],NULL,consumer,(void*)&amp;args[i]); // usleep(100); printf(&quot;i = %d\n&quot;,i); &#125; &#125; for(i = 0; i &lt; Total; i++) &#123; pthread_join(th_b[i],NULL); &#125; pthread_mutex_destroy(&amp;lock);/* 全局变量声明*/ #define Total 20//线程个数 Person per[Total]; double money = 0.0;//初始金额 int num = 0;//初始红包个数 pthread_mutex_t lock;//创建锁 这是笔者在经过对线程的更深入理解后写好的版本。 在最初的版本中，代码的69行的最后一个参数传的是(void*)&amp;i,但程序运行后时而成功时而失败，失败时如下图： 由运行结果可以看出20个线程全部都已创建出，但是却出现了红包抢不完的情况，而且观察发现，抢红包的顺序是乱序，且出现了同一个number的线程抢了好几次红包。 ¶因此总结为以下几个问题被给出解答： ** 1. 为什么创建线程是for循环控制，而抢红包是乱序？** 答： 这是因为存在资源抢占现象，创建线程的顺序是有for循环控制的，但创建好线程之后，谁先调用回调函数顺序是不定的，谁的抢到cpu资源，谁就先进入回调函数，谁就先抢红包。 ** 2. 为什么看似是同一个线程抢了多次红包？** 答： 这是因为i++操作是三条指令，分别是找到i将其放入寄存器，而后+1，最后回赋。而在运行结果中出现多次number7的情况却并不是同一个线程抢红包多次。因为可能有某几个线程在执行回调函数时，i的值还没有进行回赋操作，就被剥夺了cpu，而pthread_create函数最后一个参数原本传的是i的地址，即从地址中取i的值，但此时i还是原来的值。 因此看似是同一个线程抢了多次红包，实则不同线程执行同一个i的回调函数。 ** 3. 为什么经过修改用数组存i值可以，但最初版本用i时不可以？** 答： 这是因为pthread_create函数最后一个参数存的是地址。 当存的是i的地址时，即i变一次，地址中的内容变一次，当创建出线程而不是立即调用回调函数，而是被剥夺cpu资源时，i值就随for循环变化而变化，因此当回调函数有了cpu资源后，i的地址中存的就不是当时地址中的内容了。 当用数组存i值时，数组共有Total个地址，创建线程时，当对应的i存到对应的地址，某个数组下表元素的地址只存其当时的值，因此即使不立即调用回调函数，之后拿到的也是当时参数地址中的值，这个值未发生变化。 ** 4. 为什么67行有flag控制，而同一个i还能进去呢？** 答： **这个if判断由外部for循环控制，for循环是满足条件后进入，结束一次循环后i++，因此每次进入if后的i值都不同，至于说number7打印好多次，好像线程也创建了多次是错误的，是回调函数导致此原因，同问题2，在此就不赘述。 ** 5. 为什么在for循环中加上sleep类的函数就可以正确抢红包，但是是顺序抢？** 答： 这是因为usleep函数和sleep函数的作用是挂起当前线程，即挂起当前运行的主线程。在线程创建之后，即挂起主线程，只能进入子线程调用回调函数，回调函数又加了互斥锁，因此直到解锁才能释放cpu资源，即抢红包过程是顺序的。 6.为什么在number8后会出现number7？（即为什么8号线程后才出现7号线程？ 答： 这其实还是存在资源抢占问题，7线程创建后，没进入回调函数就被其他线程剥夺了cpu，因此当轮到其执行回调函数时，已经过去了很久。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>多线程，linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析select函数及FD宏]]></title>
    <url>%2F%E6%B5%85%E6%9E%90select%E5%87%BD%E6%95%B0%E5%8F%8AFD%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[select函数 这个函数允许进程指示内核等待多个事件中的任一个发生，并仅在一个或者多个事件发生或经过某指定时间后才唤醒进程。 ¶函数原型：### 12345#include&lt;sys/select.h&gt;#include&lt;sys/time.h&gt;int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); 返回：准备好的描述字正数目，0表示超时，-1表示出错 ¶函数参数解析： 参数maxfdp1指定被测试的描述字数目，即经过FD_SET之后，所关心的描述符的个数，（因为从0开始，因此一般这个值是测试描述符集下标最大值+1）并通知内核。 中间三个参数readset，writeset，exceptset指定我们要让内核测试读、写、异常条件所需的描述字。也就是说，对于readset，我们关心是否可以从这些文件中读取数据了，对于writeset，我们关心是否可以向这些文件中写入数据了，对于exceptset，我们关心这些文件是否发生异常。 参数timeout，它告诉内核等待一组指定的描述字中的任意一个准备好可花多长时间，结构timeval指定了秒数和微秒数成员： 12345struct timeval&#123;long tv-sec;//秒long tv-usec;//微秒&#125; 有三种可能： 、永远等待下去：仅在有一个描述符准备好I/O时才返回，要设置timeout为NULL。 、等待固定时间：在有一个描述符准备好I/O时返回，但不超过timeout参数指定的秒数和微秒数。 、根本不等待：检查描述字后立即返回，这称为轮询(polling),参数timeout要指向某一个timeval结构，且其中的秒数和微秒数要置0。 前两种是阻塞的，最后一种是不阻塞的 ¶fdset结构体解析: 12345678910111213141516171819#include&lt;typesizes.h&gt;#define __FD_SETSIZE 1024#include&lt;sys/select.h&gt;#define FD_SETSIZE __FD_SETSIZEtypedef long int __fd_mask;//64位系统上大小为8#undef __NFDBITS#define __NFDBITS (8*(int) sizeof(__fd_mask)) // 8*8 = 64typedef struct&#123;#ifdef __USE_XOPEN __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];//数组长度为1024/64 = 16 #define __FDS_BITS(set) ((set)-&gt;fds_bits) #else __fd_mask __fds_bits[____FD_SETSIZE / __NFDBITS]; #define __FDS_BITS(set) ((set)-&gt;fds_bits) #endif &#125;fd_set 因此fd_set结构体中仅包含一个整型数组，该数组的每个元素的每一位都会标记一个文件描述符。因此16个long int元素就是 1688 = 1024位 ，最多容纳1024个文件描述符！！** select中FD相关的4个宏 void FD_ZERO(fd_set *fdset);//使fd_set结构体中的整型数组清零 void FD_SET(int fd,fd_set *fdset); //设置感兴趣的文件描述符 void FD_CLR（int fd,fd_set *fdset);//关闭感兴趣的文件描述符 int FD_ISSET(int fd, fd_set *fdset); //用于判断某个文件描述符是否就绪，且在感兴趣的描述符集合中 对于几个宏和select的理解 fd_set是创建文件描述符集合 FD_SET是设置感兴趣的文件描述符放入描述符集合中，将对应位置为1，但是此文件描述符可能准备好了，也可能没有准备好，可以说是一类文件描述符。 select是监听这几个文件描述符看哪几个就绪了，就返回个数，没就绪的再次置回0，就绪的保留1。 FD_ISSET是真正查看哪个指定的文件描述符是否就绪，就绪就为1，未就绪就为0。 example： 为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。 （1）执行fd_set set; FD_ZERO(&amp;set);则set用位表示是0000,0000。 （2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1) （3）若再加入fd＝2，fd=1,则set变为0001,0011 （4）执行select(6,&amp;set,0,0,0)阻塞等待 （5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。 （6）此时FD_ISSET(1,&amp;set)返回1，而FD_ISSET(5,&amp;set)返回0]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程，c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++重载覆盖隐藏的区别和执行方式]]></title>
    <url>%2Fc-%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[¶成员函数被重载（overload）的特征 相同的范围（在同一个类中） 函数名字相同 参数不同 virtual关键字可有可无 1234567class A&#123; private: int a public： void print(); void print(int aa); &#125;; ¶覆盖（override）的特征 不同的范围（分别于派生类和基类） 函数名字相同 参数相同 基类函数必须有virtual关键字 覆盖是指派生类函数覆盖基类函数 123456789class A&#123; public: virtual void print(); &#125;; class B:public A &#123; public: void print(); &#125;; ¶隐藏（redefining）的规则 派生类函数与基类函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数都会被隐藏。 若派生类函数与基类函数同名且参数相同，但是基类函数没有virtual，基类的函数会被隐藏。 隐藏是指派生类的函数屏蔽了与其同名的基类函数。 12345678910111213141516171819class A&#123;public: void print(); &#125;; class B:public A&#123; private: int a; public: void print(int aa); &#125;; ----------------------------------------------------- class A&#123; public: void print(); &#125;; class B:public A&#123; public: void print(); &#125;; ## 3种情况怎么执行 1. 重载：看参数 2. 隐藏：看指针类型 3. 覆盖：看实体对象类型]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中return函数和exit函数的区别]]></title>
    <url>%2Fc%E8%AF%AD%E8%A8%80%E4%B8%ADreturn%E5%87%BD%E6%95%B0%E5%92%8Cexit%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别： exit函数在头文件stdlib.h中。 exit（0）：正常运行程序并退出程序； exit（1）：非正常运行导致退出程序； return（）：返回函数，若在main主函数中，则会退出函数并返回一值，可以写为return（0），或return 0。 详细说： return返回函数值，是关键字；exit是一个函数。 return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束。 return是函数的退出(返回)；exit是进程的退出。 return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。 return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一 个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出，非0 为非正常退出。 非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。 当在vfork函数中调用exit函数和return函数时需要特别注意！ vfork函数父子进程共享物理内存，因此若在子进程用return函数的话，父进程子进程的栈都会被修改，导致父进程再次return 0 时会出现段错误。 再回到 return 和 exit，return会释放局部变量，并弹栈，回到上级函数执行。exit直接退掉。如果你用c++ 你就知道，return会调用局部对象的析构函数，exit不会。（注：exit不是系统调用，是glibc对系统调用 _exit()或_exitgroup()的封装）。 可见，子进程调用exit() 没有修改函数栈，所以，父进程得以顺利执行。 另外网上大牛还有另外一种解释： 实际上子进程return只会导致子进程自己的相关寄存器（特别是esp、ebp）被更改，不会对共享的栈内存空间的内容产生影响。而子进程修改自己的寄存器并不影响父进程的寄存器，所以本来return是不会导致问题的。问题出在当子进程return返回到main()函数的调用点之后，接下来的语句中会有一些别的函数调用，这个时候main()原来的栈内存空间内容被覆盖（主要是返回地址），导致了程序的不确定行为。 链接：https://www.zhihu.com/question/26591968/answer/33867796 另外还想说一下return在子函数中的返回机制： 函数中定义的局部变量： Linux等的C语言中return返回值的机制为：将返回值存入eax寄存器中，然后系统再将eax中的值赋给变量(i)。 函数内部返回局部指针（或数组）的过程： 在执行return语句时，首先将return后面的地址值返回存入到比如eax寄存器中，然后系统再将eax中的地址值给接收函数返回地址的指针变量。这看起来都没什么问题，但问题在于两个方面： [1]接收函数返回地址值的指针变量要访问此地址中的内容。 [2]子函数运行结束后，一切有关于局部变量的内存都已经释放回收。那么在用这个地址来操作就很危险:地址中没有内容。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[using关键字在c#中的使用]]></title>
    <url>%2Fusing%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8c%23%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[using关键字在C#中的3种用法 using 关键字有两个主要用途： (一).作为指令，用于为命名空间创建别名或导入其他命名空间中定义的类型。 (二).作为语句，用于定义一个范围，在此范围的末尾将释放对象。 ¶(一).作为指令 1、用在命名空间里 using + 命名空间名字，这样可以在程序中直接用命令空间中的类型，而不必指定类型的详细命名空间，类似于Java的import，这个功能也是最常用的，几乎每个cs的程序都会用到。 例如：using System; 一般都会出现在*.cs中。 2、为命名空间或类型创建别名，using + 别名 = 包括详细命名空间信息的具体的类型。 这种做法有个好处就是当同一个cs引用了两个不同的命名空间，但两个命名空间都包括了一个相同名字的类型的时候。当需要用到这个类型的时候，就每个地方都要用详细命名空间的办法来区分这些相同名字的类型。而用别名的方法会更简洁，用到哪个类就给哪个类做别名声明就可以了。注意：并不是说两个名字重复，给其中一个用了别名，另外一个就不需要用别名了，如果两个都要使用，则两个都需要用using来定义别名的。 12345678910111213141516171819202122232425262728using System; using aClass = NameSpace1.MyClass; using bClass = NameSpace2.MyClass; namespace NameSpace1 &#123; public class MyClass &#123; public override string ToString() &#123; return &quot;You are in NameSpace1.MyClass&quot;; &#125; &#125; &#125; namespace NameSpace2 &#123; class MyClass &#123; public override string ToString() &#123; return &quot;You are in NameSpace2.MyClass&quot;; &#125; &#125; &#125; namespace testUsing &#123; using NameSpace1; using NameSpace2; class Class1 &#123; [STAThread] static void Main(string[] args) &#123; aClass my1 = new aClass(); Console.WriteLine(my1); bClass my2 = new bClass(); Console.WriteLine(my2); Console.WriteLine(&quot;Press any key&quot;); Console.Read(); &#125; &#125; &#125; (二).作为语句 using 语句允许程序员指定使用资源的对象应当何时释放资源。 using 语句中使用的对象必须实现 IDisposable 接口。此接口提供了 Dispose 方法，该方法将释放此对象的资源。 ①可以在 using 语句之前声明对象。 1234567 Font font2 = new Font(“Arial”, 10.0f); using (font2) &#123; // use font2; &#125; ②可以在 using 语句之中声明对象。 using (Font font2 = new Font(“Arial”, 10.0f)) { // use font2; } ③可以有多个对象与 using 语句一起使用，但是必须在 using 语句内部声明这些对象。 1234567891011 using (Font font3=new Font(“Arial”,10.0f), font4=new Font(“Arial”,10.0f))&#123; // Use font3 and font4. &#125;***使用规则:***①using只能用于实现了IDisposable接口的类型，禁止为不支持IDisposable接口的类型使用using语句，否则会出现编译错误；②using语句适用于清理单个非托管资源的情况，而多个非托管对象的清理最好以try-finnaly来实现，因为嵌套的using语句可能存在隐藏的Bug。内层using块引发异常时，将不能释放外层using块的对象资源；③using语句支持初始化多个变量，但前提是这些变量的类型必须相同，例如： using(Pen p1 = new Pen(Brushes.Black), p2 = new Pen(Brushes.Blue)){ // } 1④针对初始化多个不同类型的变量时，可以都声明为IDisposable类型，例如： using (IDisposable font = new Font(“Verdana”, 12), pen = new Pen(Brushes.Black)) { float size = (font as Font).Size; Brush brush = (pen as Pen).Brush; } 123using实质 在程序编译阶段，编译器会自动将using语句生成为try-finally语句，并在finally块中调用对象的Dispose方法，来清理资源。所以，using语句等效于try-finally语句，例如： using (Font f2 = new Font(“Arial”, 10, FontStyle.Bold)） { font2.F(); } 1被编译器翻译为： Font f2 = new Font(“Arial”, 10, FontStyle.Bold); try{ font2.F(); } finally { if (f2 != null) ((IDisposable)f2).Dispose(); } 转载自 http://www.cnblogs.com/xiaobiexi/p/6179127.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADO.NET与外部数据库连接及查询等基本操作]]></title>
    <url>%2FADO-NET%E4%B8%8E%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%8F%8A%E6%9F%A5%E8%AF%A2%E7%AD%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[¶建立与数据库连接: 需要连接字符串，用到System.Data.SqlClient类库。 方法： 使用一个类构建SQL Server 连接字符串 - 创建SqlconnectionStringBuider实例 - 根据需要设置其属性 - 访问该对象的ConnectionString属性 与SQL Server数据库建立连接 - 生成一个指向该数据库的连接字符串 - 创建SqlConnection实例，向构造函数传递连接字符串 - 调用Sqlconnection实例的open方法 ¶代码实例： /*建立连接字符串生成器*/ SqlConnectionStringBuilder connection = new SqlConnectionStringBuilder(); /*能连上本地服务器，以windows身份登录*/ if (LocalServer.Checked == true) connection.DataSource = &quot;(local)&quot;; /*以sql身份登录*/ else connection.DataSource = ServerName.Text; /*若sql server是express版本*/ if (IsExpressEdition.Checked == true) connection.DataSource += @&quot;\SQLEXPRESS&quot;; /*基于当前windows登陆的集成安全验证*/ if(AuthenticateWindows.Checked == true) { connection.IntegratedSecurity = true; } else { connection.IntegratedSecurity = false;//基于SQL用户的安全验证 connection.UserID = UserName.Text; connection.Password = UserPassword.Text; } SqlConnection linkToDB = new SqlConnection(connection.ConnectionString);//新建连接对象 linkToDB.Open();//打开数据库连接 linkToDB.close();//关闭数据库，或用dispose方法，或者用using语句就会自动关闭 ¶对数据库进行查询、修改、更新、删除等操作：## 需要用到System.Data.SqlClient类库中的sqlcommand类 方法： 通过一个ADO.NET连接运行SQL查询 - 创建Sqlcommandr实例 - 将其CommandText属性设置为SQL语句 - 将其Connection属性设置为一个有效的Sqlconnection实例 - 调用这个命令对象的ExecuteNonQuery方法 调用一个返回静态结果的SQL Server存储过程 - 创建Sqlcommandr实例 - 将其CommandText属性设置为这个存储过程的名字 - 将其Connection属性设置为一个有效的Sqlconnection实例 - 调用这个命令对象的ExecuteScalar方法，捕获返回值 ¶代码实例： /*对于对数据库采取操作但不返回存储数据的服务*/ string sqlText = @&quot;UPDATE WorkTable SET ProcessedOn = GETDATE() WHERE ProcessedOn IS NULL&quot;; SqlCommand dataAction = new SqlCommand(sqlText, linkToDB); dataAction.ExecuteNonQuery(); /*对于返回单个值的查询*/ string sqlText1 = &quot;select count(*) from WorkTable&quot;; SqlCommand dataAction1 = new SqlCommand(sqlText1, linkToDB); int total = (int)dataAction1.ExecuteScalar();//返回单个值 /*对于返回数据行的操作*/ string sqlText2 = &quot;select ID,FullName,ZipCode from Customer&quot;; SqlCommand dataAction2 = new SqlCommand(sqlText2, linkToDB); SqlDataReader scanCustomer = dataAction2.ExecuteReader();//一次返回一个数据行 if (scanCustomer.HasRows) while (scanCustomer.Read()); /*对于访问字段的值，用访问器*/ result = scanCustomer[0];//从起始位置查找 result = scanCustomer[“ID”];//按列名称查找 scanCustomer.NextResult();//若有多个列的返回时 /*查询中存在参数时，用@标识符替代*/ string test = @&quot;update Employee set Salary = @NewSalary where ID = @EmployeeID&quot;； SqlCommand salaryUpadate = new SqlCommand(test, linkToDB); paramValue.Value = 50000m;//设置参数的值 salaryUpadate.Parameters.Add(paramValue);//获取参数的值到原来的字符串中 salaryUpadate.Parameters.AddWithValue(&quot;@NewSalary&quot;, 50000m);//另外一种实例化方式，用于简单的参数时 salaryUpadate.ExecuteNonQuery(); /*对于存储过程的查询时*/ string test1 = &quot;dbo.AddLocation&quot;;//创建存储过程的字符串 SqlCommand locationCommand = new SqlCommand(test1, linkToDB); locationCommand.CommandType = CommandType.StoredProcedure;//把数据库命令的类型设置成存储过程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>.net</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的function自定义函数]]></title>
    <url>%2FSQL%E4%B8%AD%E7%9A%84function%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SQL自定义函数 产生背景（已经有了存储过程，为什么还要使用自定义函数） 发展历史 构成 使用方法 适用范围 注意事项 疑问 ¶内容 ¶产生背景（已经有了存储过程，为什么还要使用自定义函数） 与存储过程的区别（存在的意义）： 能够在select等SQL语句中直接使用自定义函数，存储过程不行。 自定义函数可以调用其他函数，也可以调用自己（递归） 可以在表列和 CHECK 约束中使用自定义函数来实现特殊列或约束 自定义函数不能有任何副作用。函数副作用是指对具有函数外作用域（例如数据库表的修改）的资源状态的任何永久性更改。函数中的语句唯一能做的更改是对函数上的局部对象（如局部游标或局部变量）的更改。不能在函数中执行的操作包括：对数据库表的修改，对不在函数上的局部游标进行操作，发送电子邮件，尝试修改 目录，以及生成返回至用户的结果集。存储过程没有此限制 函数只能返回一个变量。而存储过程可以返回多个 ¶发展历史 SqlServer 2000之后都支持用户自定义函数 ¶构成 在SQL Server 2000 中根据函数返回值形式的不同将用户自定义函数分为三种类型：标量函数（Scalar Function）、内嵌表值函数（Inline Function）、多声明表值函数（Multi-Statement Function） 标量函数：标量函数是对单一值操作，返回单一值。能够使用表达式的地方，就可以使用标量函数。像我们经常使用的left、getdate等，都属于标量函数。系统函数中的标量函数包括：数学函数、日期和时间函数、字符串函数、数据类型转换函数等 内嵌表值函数：内嵌表值函数的功能相当于一个参数化的视图。它返回的是一个表，内联表值型函数没有由BEGIN-END 语句括起来的函数体。其返回的表由一个位于RETURN 子句中的SELECT 命令段从数据库中筛选出来。 作用 多声明表值函数：可以看作标量型和内嵌表值型函数的结合体。它的返回值是一个表，但它和标量型函数一样有一个用BEGIN-END 语句括起来的函数体，返回值的表中的数据是由函数体中的语句插入的。由此可见，它可以进行多次查询，对数据进行多次筛选与合并，弥补了内联表值型函数的不足。 ¶使用方法 SQL Server 为三种类型的用户自定义函数 提供了不同的命令创建格式。 （1） 创建标量型用户自定义函数（Scalar functions） 其语法如下： 各参数说明如下： owner_name ：指定用户自定义函数的所有者。 function_name：指定用户自定义函数的名称。database_name.owner_name.function_name 应是惟一的。 @parameter_name：定义一个或多个参数的名称。一个函数最多可以定义1024 个参数每个参数前用“@”符号标明。参数的作用范围是整个函数。参数只能替代常量，不能替代表 名、列名或其它数据库对象的名称。用户自定义函数不支持输出参数。 scalar_parameter_data_type：指定标量型参数的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。 scalar_return_data_type：指定标量型返回值的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。 scalar_expression：指定标量型用户自定义函数返回的标量值表达式。 function_body：指定一系列的Transact-SQL 语句，它们决定了函数的返回值。 ENCRYPTION：加密选项。让SQL Server 对系统表中有关CREATE FUNCTION 的声明加密，以防止用户自定义函数作为SQL Server 复制的一部分被发布（Publish） 。 SCHEMABINDING：计划绑定选项将用户自定义函数绑定到它所引用的数据库对象如果指定 了此选项，则函数所涉及的数据库对象从此将不能被删除或修改，除非函数被删除或去掉此选项。应注意的是，要绑定的数据库对象必须与函数在同一数据库中。 2）创建内联表值型用户自定义函 数（Inline Table-valued Functions） 其语法如下： 各参数说明如下： TABLE：指定返回值为一个表。 select-stmt：单个SELECT 语句，确定返回的表的数据。 其余参数与标量型用户自定义函数相同。 （3） 创建多声明表值型用户自定义函数 其语法如下： 各参数说明如下： @return_variable ：一个TABLE 类型的变量，用于存储和累积返回的表中的数据行。 其余参数与标量型用户自定义函数相同。 在多声明表值型用户自定义函数的函数体中允许使用下列Transact-SQL 语句。 赋值语句（Assignment statements）； 流程控制语句（Control-of-Flow statements）； 定义作用范围在函数内的变量和 游标的DECLARE 语句； SELECT 语句； 编辑函数中定义的表变量的INSERT、 UPDATE 和DELETE 语句； 在函数中允许涉及诸如声明游 标、打开游标、关闭游标、释放游标这样的游标操作，对于读取游标而言，除非在FETCH 语句中使用INTO 从句来对某一变量赋值，否则不允许在函数中使用FETCH 语句来向客户端返回数据。此 外不确定性函数（Non-deterministic functions） 不能在用户自定义函数中使 用。所谓不确定性函数是指那些使用相同的调用参数在不同时刻调用得到的返回值不同的函数。 ¶适用范围 ¶用户自定义函数不能用于执行一系列改变数据库状态的操作在编写自定义函数时需要注意的： 对于标量函数： 所有的入参前都必须加@ create后的返回，单词是returns，而不是return returns后面的跟的不是变量，而是返回值的类型，如：int，char等。 在begin/end语句块中，是return。 内嵌表值函数： 只能返回table，所以returns后面一定是TABLE AS后没有begin/end，只有一个return语句来返回特定的记录。 多语句表值函数： returns后面直接定义返回的表类型，首先是定义表名，表明前面要加@，然后是关键字TABLE，最后是表的结构。 在begin/end语句块中，直接将需要返回的结果insert到returns定义的表中就可以了，在最后return时，会将结果返回。 最后只需要return，return后面不跟任何变量。 ¶疑问 自定义函数不能修改数据库，但它可以调用存储过程，那么在自定义函数中调用一个有修改数据库的操作的存储过程，这个自定义函数能不能执行？ 答： 自定义函数只能调用扩展存储过程，但是SQL Server 2008的后续版本将删除该功能，不再支持扩展存储过程，所以应避免在开发中使用扩展存储过程。因此，可以得出结论是：实际开发中，函数不会去调用存储过程，也就无法对数据库进行修改操作了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下安装命令的区别]]></title>
    <url>%2Fubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ubuntu下安装命令的区别（dpkg、apt-get、aptitude） dpkg绕过apt包管理数据库对软件包进行操作，所以你用dpkg安装过的软件包用apt可以再安装一遍，系统不知道之前安装过了，将会覆盖之前dpkg的安装。 dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件 apt会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具 aptitude与 apt-get 一样，是 Debian 及其衍生系统***能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。 ¶安装软件包 123456dpkg -i package_name.deb #安装本地软件包，不解决依赖关系apt-get install package #在线安装软件包aptitude install pattern #同上apt-get install package –reinstall #重新安装软件包apitude reinstall package #同上 ¶移除软件包 1234567dpkg -r package #删除软件包apt-get remove package #同上aptitude remove package #同上dpkg -P #删除软件包及配置文件apt-get remove package –purge #删除软件包及配置文件apitude purge pattern #同上 ¶自动移除软件包 12apt-get autoremove #删除不再需要的软件包注：aptitude 没有，它会自动解决这件事 ¶清除下载的软件包 12345apt-get clean #清除 /var/cache/apt/archives 目录aptitude clean #同上apt-get autoclean #清除 /var/cache/apt/archives 目录，不过只清理过时的包aptitude autoclean #同上 ¶编译相关 1234apt-get source package #获取源码apt-get build-dep package #解决编译源码 package 的依赖关系aptitude build-dep pattern #解决编译源码 pattern 的依赖关系 ¶平台相关 123456apt-cross –arch ARCH –show package 显示属于 ARCH 构架的 package 软件包信息apt-cross –arch ARCH –get package #下载属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –install package #安装属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –remove package #移除属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –purge package #移除属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –update #升级属于 ARCH 构架的 package 软件包 注：慎重考虑要不要用这种方法来安装不同构架的软件包，这样会破坏系统。对于 amd64 的用户可能需要强制安装某些 i386 的包，千万不要把原来 amd64 本身的文件给 replace 了。最好只是安装一些 lib 到 /usr/lib32 目录下。同样地，可以用 apt-file 看某个其它构架的软件包包含哪些文件，或者是文件属于哪个包，不过记得最先要用 apt-file –architecture ARCH update 来升级 apt-file 的数据库，在 search 或 show 时也要指定 ARCH。 ¶更新源 12apt-get update #更新源aptitude update #同上 ¶更新系统 1234apt-get upgrade #更新已经安装的软件包aptitude safe-upgrade #同上apt-get dist-upgrade #升级系统aptitude full-upgrade #同]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中struct大小计算]]></title>
    <url>%2Fc%E8%AF%AD%E8%A8%80%E4%B8%ADstruct%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[struct 大小计算 结构体是一种复合数据类型，通常编译器会自动的进行其成员变量的对齐，已提高数据存取的效率。在默认情况下，编译器为结构体的成员按照自然对齐（natural alignment）条方式分配存储空间，各个成员按照其声明顺序在存储器中顺序存储。自然对齐是指按照结构体中成员size最大的对齐。 ¶默认对齐方式： 在默认对齐方式下，结构体成员的内存分配满足下面三个条件： 结构体第一个成员的地址和结构体的首地址相同 结构体每个成员地址相对于结构体首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节（internal adding）。 结构体总的大小要是其成员中最大size的整数倍，如果不是编译器会在其末尾添加填充字节（trailing padding）。 下面是一个示例： 123456789101112131415161718192021222324252627282930struct s1&#123; char ch; int a; double b; char c1;&#125;;struct s2&#123; char ch; int a; double b;&#125;;int main()&#123; cout &lt;&lt; &quot;s1的大小： &quot; &lt;&lt; sizeof(struct s1) &lt;&lt; endl; cout &lt;&lt; &quot;ch的地址偏移是 &quot; &lt;&lt; offsetof(s1, ch) &lt;&lt; endl; cout &lt;&lt; &quot;a 的地址偏移是 &quot; &lt;&lt; offsetof(s1, a) &lt;&lt; endl; cout &lt;&lt; &quot;b 的地址偏移是 &quot; &lt;&lt; offsetof(s1, b) &lt;&lt; endl; cout &lt;&lt; &quot;c1的地址偏移是 &quot; &lt;&lt; offsetof(s1, c1) &lt;&lt; endl; cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; endl; cout &lt;&lt; &quot;s2的大小: &quot; &lt;&lt; sizeof(struct s2) &lt;&lt; endl; cout &lt;&lt; &quot;ch的地址偏移是 &quot; &lt;&lt; offsetof(s2, ch) &lt;&lt; endl; cout &lt;&lt; &quot;a 的地址偏移是 &quot; &lt;&lt; offsetof(s2, a) &lt;&lt; endl; cout &lt;&lt; &quot;b 的地址偏移是 &quot; &lt;&lt; offsetof(s2, b) &lt;&lt; endl; getchar(); return 0;&#125; 代码中 offsetof函数可以得到结构体成员相对于该结构体首地址的偏移量。 其运行结果如下图： 对于结构体s1来说： ch是其第一个成员故其地址和结构体的地址是相同的也就是说偏移量为0； a是int型其大小为4个字节，按照条件（2） 结构体每个成员地址相对于结构首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节，所以其地址偏移应该是4，也就说编译器在第一个成员ch后面填充了3个字节。 b是double型占8个字节，其地址偏移应该是8的整数倍，由于a的地址偏移是4其大小为4个字节，正好b的偏移地址是8，不需要填充字节。 c1是char型占1个字节，偏移地址是16（b的偏移地址是8大小也是8，中间也没有填充字节）。 这时成员ch占1个字节后面有3个字节的填充，a占4个字节后面无填充，b占8个字节后面无填充，c1占1个字节，s1总的大小是1+3+4+8+1=17” role=”presentation”&gt;1+3+4+8+1=171+3+4+8+1=17。按照条件（3）结构体总的大小需是其最大成员所占空间的整数倍，其最大的成员b占有8字节，17显然是不符合条件的，所以需要在结构体的末尾填充7个字节，最后结构体总的大小是24字节。 结构体s2和s1的成员是非常相似的，唯一的区别是其末尾没有最后7个字节的填充，所以其大小是16个字节，这里用于和s1做对比说明s1末尾的填充字节。 ¶指定对齐方式 可以使用#pragma pack(N)来指定结构体成员的对齐方式 对于指定的对齐方式，其成员的地址偏移以及结构的总的大小也有下面三个约束条件： 结构体第一个成员的地址和结构体的首地址相同 结构体每个成员的地址偏移需要满足：N大于等于该成员的大小，那么该成员的地址偏移需满足默认对齐方式（地址偏移是其成员大小的整数倍）；Ｎ小于该成员的大小，那么该成员的地址偏移是N的整数倍。 结构体总的大小需要时N的整数倍，如果不是需要在结构体的末尾进行填充。 如果N大于结构体成员中最大成员的大小，则N不起作用，仍然按照默认方式对齐。 还是用上述示例： 1#pragma pack(4) //设定按照4字节对齐 运行结果为： ¶说明： 在使用#pragma pack设定对齐方式一定要是2的整数幂，也就是（1，2，4，8，16，…），不然不起作用的，仍然按照默认方式对齐。 当结构体中有其他的结构体作为成员时，计算最大成员是不能把结构体成员作为一个整体来计算，要看其每个成员的大小。 转载自： http://www.cnblogs.com/wangguchangqing/p/4853438.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const只读变量的内存分配]]></title>
    <url>%2Fconst%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[const只读变量与#define宏定义的常量的内存分配的区别 编译器通常不为普通 const 只读变量分配存储空间,而是将它们保存在符号表中,这使 得它成为一个编译期间的值,没有了存储与读内存的操作,使得它的效率也很高。 例如： 1234567#define M 3//宏常量const int N=5;//此时并未将 N 放入内存中......int i=N;//此时为 N 分配内存,以后不再分配int I=M;//预编译期间进行宏替换,分配内存int j=N;//没有内存分配int J=M;//再进行宏替换,又一次分配内存 const 定义的只读变量从汇编的角度来看,只是给出了对应的内存地址,而不是象#define 一样给出的是立即数,所以,const 定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量,存放在静态区),而#define 定义的宏常量在内存中有若干个拷贝。 #define 宏是在预编译阶段进行替换,而 const 修饰的只读变量是在编译的时候确定其值。 #define 宏没有类型,而 const 修饰的只读变量具有特定的类型。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git与github基本操作]]></title>
    <url>%2Fgit%E4%B8%8Egithub%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[git与github的基本操作 ¶一、准备： 1、git config --global user.name “Firstname Lastname” 2、git config --global user.email&quot;your_email@example.com&quot; 3、ssh-keygen -t rsa -C &quot;your_email@example.com&quot;添加ssh，一路回车略过 4、id_rsa.pub寻找公开公钥复制到github 5、ssh -T git@github.com 测试ssh是否生效 ¶二、向远程仓库提交本地文件： 方法一： 1、git clone git@github.com:username/example.git 2、cd example 3、git add filename//将文件发到缓存区 4、git diff HEAD//查看本次提交与之前提交的区别（可省略） 5、git commit -m “contribtion”//提交文件 6、git status//查看当前工作树情况（可省略） 7、git log -p//查看提交日志，并可查看修改的情况（可省 略） 8、git push//直接提交到远程仓库 方法二： 1.git init 2.git add filename//将文件发到缓存区 3.git diff HEAD//查看本次提交与之前提交的区别（可省略） 4.git commit -m “contribtion”//提交文件 5.git status//查看当前工作树情况（可省略） 6.git log -p//查看提交日志，并可查看修改的情况（可省略） 7.git remote add origin 8.git@github.com:usrname/example.git//创建远程仓库 9.git push -u origin master//把本地当前分支上的内容推送到远程origin库的master分支 -u参数可以在推送的同时,将 origin 仓库的 master 分 支设置为本地仓库当前分支的 upstream(上游)。添加了这个参数,将来 运行 git pull命令从远程仓库获取内容时,本地仓库的这个分支就可 以直接从 origin 的 master 分支获取内容,省去了另外添加参数的麻烦。 工作树（当前文件夹） ----&gt; 暂存区 -----&gt;本地仓库 -----&gt;远程仓库]]></content>
      <categories>
        <category>研发管理</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
