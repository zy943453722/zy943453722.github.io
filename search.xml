<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅析多线程并发及写微信红包遇到的问题]]></title>
    <url>%2F2017%2F09%2F25%2F%E6%B5%85%E6%9E%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%8F%8A%E5%86%99%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[多线程并发 众所周知，多线程编程很容易遇上诸如丢失更新、脏读、死锁等烦人的线程冲突问题。多线程的问题一旦发生便很难定位和解决，所以要在编程的初始阶段就要注意避免多线程程序常见的错误。 微信红包程序应用线程基础API，采用多线程并发的方式进行抢红包操作。 多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。 微信红包程序 思路： 创建抢红包人员的结构体，分别给定名字，所抢金额，以及是否已抢过字段。 创建生产者线程，用于产生红包，红包金额和红包数目从标注输入读入，并对生产者回调函数进行加锁操作。 创建多个消费者线程，用于多人抢红包操作，其中消费者回调函数进行红包的随机分配算法，并进行加锁操作。 下面是部分代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 /*结构体部分*/ typedef struct person &#123; int id; char name[20]; int flag; int money; &#125;Person;/* 生产者回调函数*/ void *producer(void* value)//生产者只负责产生红包金 额和红包个数 &#123; double n = *(double*)value; pthread_mutex_lock(&amp;lock); money = n; pthread_mutex_unlock(&amp;lock); pthread_exit(NULL); &#125;/*消费者回调函数*/ void *consumer(void *n)//消费者用于随机获取红包个数 &#123; int nn = *(int*)n; pthread_mutex_lock(&amp;lock); printf(&quot;number%d\n&quot;,nn); if(money &gt; 0 &amp;&amp; per[nn].flag == 0)//还没抢过 &#123; if(num &gt; 1) &#123; srand((unsigned)time(NULL));//初始化随机数种子 double avg = money / num;//获取平均值 double t = avg*2; double randmoney = (rand()%(int)(t*100) + (int)MIN*100)/100.00 + MIN;//初始化随机数 money-=randmoney; printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,randmoney); printf(&quot;剩余%.2lf元\n&quot;,money); per[nn].id = nn; per[nn].money = randmoney; per[nn].flag = 1; num--; &#125; else &#123; printf(&quot;%s取走%.2lf元\n&quot;,per[nn].name,money); printf(&quot;剩余0元\n&quot;); money = 0; per[nn].id = nn; per[nn].money = money; per[nn].flag = 1; num--; &#125; &#125; pthread_mutex_unlock(&amp;lock); pthread_cancel(pthread_self()); &#125;/*主函数中主要线程API使用部分*/ pthread_t th_a,th_b[Total]; pthread_mutex_init(&amp;lock,0); pthread_create(&amp;th_a,NULL,producer,(void*)&amp;value); pthread_join(th_a,NULL); int args[Total]; for(i = 0; i &lt; Total;i++) &#123; args[i] = i; if(per[i].flag == 0) &#123; pthread_create(&amp;th_b[i],NULL,consumer,(void*)&amp;args[i]); // usleep(100); printf(&quot;i = %d\n&quot;,i); &#125; &#125; for(i = 0; i &lt; Total; i++) &#123; pthread_join(th_b[i],NULL); &#125; pthread_mutex_destroy(&amp;lock);/* 全局变量声明*/ #define Total 20//线程个数 Person per[Total]; double money = 0.0;//初始金额 int num = 0;//初始红包个数 pthread_mutex_t lock;//创建锁 这是笔者在经过对线程的更深入理解后写好的版本。 在最初的版本中，代码的69行的最后一个参数传的是(void*)&amp;i,但程序运行后时而成功时而失败，失败时如下图： 由运行结果可以看出20个线程全部都已创建出，但是却出现了红包抢不完的情况，而且观察发现，抢红包的顺序是乱序，且出现了同一个number的线程抢了好几次红包。 因此总结为以下几个问题被给出解答： 1. 为什么创建线程是for循环控制，而抢红包是乱序？ 答： 这是因为存在资源抢占现象，创建线程的顺序是有for循环控制的，但创建好线程之后，谁先调用回调函数顺序是不定的，谁的抢到cpu资源，谁就先进入回调函数，谁就先抢红包。 2. 为什么看似是同一个线程抢了多次红包？ 答： 这是因为i++操作是三条指令，分别是找到i将其放入寄存器，而后+1，最后回赋。而在运行结果中出现多次number7的情况却并不是同一个线程抢红包多次。因为可能有某几个线程在执行回调函数时，i的值还没有进行回赋操作，就被剥夺了cpu，而pthread_create函数最后一个参数原本传的是i的地址，即从地址中取i的值，但此时i还是原来的值。 因此看似是同一个线程抢了多次红包，实则不同线程执行同一个i的回调函数。 3. 为什么经过修改用数组存i值可以，但最初版本用i时不可以？ 答： 这是因为pthread_create函数最后一个参数存的是地址。当存的是i的地址时，即i变一次，地址中的内容变一次，当创建出线程而不是立即调用回调函数，而是被剥夺cpu资源时，i值就随for循环变化而变化，因此当回调函数有了cpu资源后，i的地址中存的就不是当时地址中的内容了。当用数组存i值时，数组共有Total个地址，创建线程时，当对应的i存到对应的地址，某个数组下表元素的地址只存其当时的值，因此即使不立即调用回调函数，之后拿到的也是当时参数地址中的值，这个值未发生变化。 4. 为什么67行有flag控制，而同一个i还能进去呢？ 答： **这个if判断由外部for循环控制，for循环是满足条件后进入，结束一次循环后i++，因此每次进入if后的i值都不同，至于说number7打印好多次，好像线程也创建了多次是错误的，是回调函数导致此原因，同问题2，在此就不赘述。 5. 为什么在for循环中加上sleep类的函数就可以正确抢红包，但是是顺序抢？ 答： 这是因为usleep函数和sleep函数的作用是挂起当前线程，即挂起当前运行的主线程。在线程创建之后，即挂起主线程，只能进入子线程调用回调函数，回调函数又加了互斥锁，因此直到解锁才能释放cpu资源，即抢红包过程是顺序的。 6.为什么在number8后会出现number7？（即为什么8号线程后才出现7号线程？ 答：这其实还是存在资源抢占问题，7线程创建后，没进入回调函数就被其他线程剥夺了cpu，因此当轮到其执行回调函数时，已经过去了很久。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>多线程，linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析select函数及FD宏]]></title>
    <url>%2F2017%2F09%2F20%2F%E6%B5%85%E6%9E%90select%E5%87%BD%E6%95%B0%E5%8F%8AFD%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[select函数这个函数允许进程指示内核等待多个事件中的任一个发生，并仅在一个或者多个事件发生或经过某指定时间后才唤醒进程。 函数原型：12345#include&lt;sys/select.h&gt;#include&lt;sys/time.h&gt;int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); 返回：准备好的描述字正数目，0表示超时，-1表示出错 函数参数解析： 参数maxfdp1指定被测试的描述字数目，即经过FD_SET之后，所关心的描述符的个数，（因为从0开始，因此一般这个值是测试描述符集下标最大值+1）并通知内核。 中间三个参数readset，writeset，exceptset指定我们要让内核测试读、写、异常条件所需的描述字。也就是说，对于readset，我们关心是否可以从这些文件中读取数据了，对于writeset，我们关心是否可以向这些文件中写入数据了，对于exceptset，我们关心这些文件是否发生异常。 参数timeout，它告诉内核等待一组指定的描述字中的任意一个准备好可花多长时间，结构timeval指定了秒数和微秒数成员：12345struct timeval&#123;long tv-sec;//秒long tv-usec;//微秒&#125; 有三种可能： 1) 、永远等待下去：仅在有一个描述符准备好I/O时才返回，要设置timeout为NULL。 2) 、等待固定时间：在有一个描述符准备好I/O时返回，但不超过timeout参数指定的秒数和微秒数。 3) 、根本不等待：检查描述字后立即返回，这称为轮询(polling),参数timeout要指向某一个timeval结构，且其中的秒数和微秒数要置0。 前两种是阻塞的，最后一种是不阻塞的 fdset结构体解析: 12345678910111213141516171819#include&lt;typesizes.h&gt;#define __FD_SETSIZE 1024#include&lt;sys/select.h&gt;#define FD_SETSIZE __FD_SETSIZEtypedef long int __fd_mask;//64位系统上大小为8#undef __NFDBITS#define __NFDBITS (8*(int) sizeof(__fd_mask)) // 8*8 = 64typedef struct&#123;#ifdef __USE_XOPEN __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];//数组长度为1024/64 = 16 #define __FDS_BITS(set) ((set)-&gt;fds_bits) #else __fd_mask __fds_bits[____FD_SETSIZE / __NFDBITS]; #define __FDS_BITS(set) ((set)-&gt;fds_bits) #endif &#125;fd_set 因此fd_set结构体中仅包含一个整型数组，该数组的每个元素的每一位都会标记一个文件描述符。因此16个long int元素就是 1688 = 1024位 ，最多容纳1024个文件描述符！！ select中FD相关的4个宏 void FD_ZERO(fd_set *fdset);//使fd_set结构体中的整型数组清零 void FD_SET(int fd,fd_set *fdset); //设置感兴趣的文件描述符 void FD_CLR（int fd,fd_set *fdset);//关闭感兴趣的文件描述符 int FD_ISSET(int fd, fd_set *fdset); //用于判断某个文件描述符是否就绪，且在感兴趣的描述符集合中 对于几个宏和select的理解 fd_set是创建文件描述符集合 FD_SET是设置感兴趣的文件描述符放入描述符集合中，将对应位置为1，但是此文件描述符可能准备好了，也可能没有准备好，可以说是一类文件描述符。 select是监听这几个文件描述符看哪几个就绪了，就返回个数，没就绪的再次置回0，就绪的保留1。 FD_ISSET是真正查看哪个指定的文件描述符是否就绪，就绪就为1，未就绪就为0。 example： 为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。 （1）执行fd_set set; FD_ZERO(&amp;set);则set用位表示是0000,0000。 （2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1) （3）若再加入fd＝2，fd=1,则set变为0001,0011 （4）执行select(6,&amp;set,0,0,0)阻塞等待 （5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。 （6）此时FD_ISSET(1,&amp;set)返回1，而FD_ISSET(5,&amp;set)返回0]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程，c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++重载覆盖隐藏的区别和执行方式]]></title>
    <url>%2F2017%2F09%2F15%2Fc-%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[成员函数被重载（overload）的特征 相同的范围（在同一个类中） 函数名字相同 参数不同 virtual关键字可有可无 1234567class A&#123; private: int a public： void print(); void print(int aa); &#125;; 覆盖（override）的特征 不同的范围（分别于派生类和基类） 函数名字相同 参数相同 基类函数必须有virtual关键字 覆盖是指派生类函数覆盖基类函数 123456789class A&#123; public: virtual void print(); &#125;; class B:public A &#123; public: void print(); &#125;; 隐藏（redefining）的规则 派生类函数与基类函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数都会被隐藏。 若派生类函数与基类函数同名且参数相同，但是基类函数没有virtual，基类的函数会被隐藏。 隐藏是指派生类的函数屏蔽了与其同名的基类函数。 12345678910111213141516171819class A&#123;public: void print(); &#125;; class B:public A&#123; private: int a; public: void print(int aa); &#125;; ----------------------------------------------------- class A&#123; public: void print(); &#125;; class B:public A&#123; public: void print(); &#125;; 3种情况怎么执行 重载：看参数 隐藏：看指针类型 覆盖：看实体对象类型]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[using关键字在c#中的使用]]></title>
    <url>%2F2017%2F06%2F07%2Fusing%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8c%23%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[using关键字在C#中的3种用法using 关键字有两个主要用途： (一).作为指令，用于为命名空间创建别名或导入其他命名空间中定义的类型。 (二).作为语句，用于定义一个范围，在此范围的末尾将释放对象。 (一).作为指令1、用在命名空间里 using + 命名空间名字，这样可以在程序中直接用命令空间中的类型，而不必指定类型的详细命名空间，类似于Java的import，这个功能也是最常用的，几乎每个cs的程序都会用到。例如：using System; 一般都会出现在*.cs中。 2、为命名空间或类型创建别名，using + 别名 = 包括详细命名空间信息的具体的类型。 这种做法有个好处就是当同一个cs引用了两个不同的命名空间，但两个命名空间都包括了一个相同名字的类型的时候。当需要用到这个类型的时候，就每个地方都要用详细命名空间的办法来区分这些相同名字的类型。而用别名的方法会更简洁，用到哪个类就给哪个类做别名声明就可以了。注意：并不是说两个名字重复，给其中一个用了别名，另外一个就不需要用别名了，如果两个都要使用，则两个都需要用using来定义别名的。 12345678910111213141516171819202122232425262728using System; using aClass = NameSpace1.MyClass; using bClass = NameSpace2.MyClass; namespace NameSpace1 &#123; public class MyClass &#123; public override string ToString() &#123; return &quot;You are in NameSpace1.MyClass&quot;; &#125; &#125; &#125; namespace NameSpace2 &#123; class MyClass &#123; public override string ToString() &#123; return &quot;You are in NameSpace2.MyClass&quot;; &#125; &#125; &#125; namespace testUsing &#123; using NameSpace1; using NameSpace2; class Class1 &#123; [STAThread] static void Main(string[] args) &#123; aClass my1 = new aClass(); Console.WriteLine(my1); bClass my2 = new bClass(); Console.WriteLine(my2); Console.WriteLine(&quot;Press any key&quot;); Console.Read(); &#125; &#125; &#125; (二).作为语句 using 语句允许程序员指定使用资源的对象应当何时释放资源。 using 语句中使用的对象必须实现 IDisposable 接口。此接口提供了 Dispose 方法，该方法将释放此对象的资源。 ①可以在 using 语句之前声明对象。 1234567 Font font2 = new Font(“Arial”, 10.0f); using (font2) &#123; // use font2; &#125; ②可以在 using 语句之中声明对象。 using (Font font2 = new Font(“Arial”, 10.0f)) { // use font2; } ③可以有多个对象与 using 语句一起使用，但是必须在 using 语句内部声明这些对象。 1234567891011 using (Font font3=new Font(“Arial”,10.0f), font4=new Font(“Arial”,10.0f))&#123; // Use font3 and font4. &#125;***使用规则:***①using只能用于实现了IDisposable接口的类型，禁止为不支持IDisposable接口的类型使用using语句，否则会出现编译错误；②using语句适用于清理单个非托管资源的情况，而多个非托管对象的清理最好以try-finnaly来实现，因为嵌套的using语句可能存在隐藏的Bug。内层using块引发异常时，将不能释放外层using块的对象资源；③using语句支持初始化多个变量，但前提是这些变量的类型必须相同，例如： using(Pen p1 = new Pen(Brushes.Black), p2 = new Pen(Brushes.Blue)){ // } 1④针对初始化多个不同类型的变量时，可以都声明为IDisposable类型，例如： using (IDisposable font = new Font(“Verdana”, 12), pen = new Pen(Brushes.Black)) { float size = (font as Font).Size; Brush brush = (pen as Pen).Brush; } 123using实质 在程序编译阶段，编译器会自动将using语句生成为try-finally语句，并在finally块中调用对象的Dispose方法，来清理资源。所以，using语句等效于try-finally语句，例如： using (Font f2 = new Font(“Arial”, 10, FontStyle.Bold)）{ font2.F();}1被编译器翻译为： Font f2 = new Font(“Arial”, 10, FontStyle.Bold); try{ font2.F(); } finally { if (f2 != null) ((IDisposable)f2).Dispose(); } ``` 转载自http://www.cnblogs.com/xiaobiexi/p/6179127.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADO.NET与外部数据库连接及查询等基本操作]]></title>
    <url>%2F2017%2F05%2F21%2FADO-NET%E4%B8%8E%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%8F%8A%E6%9F%A5%E8%AF%A2%E7%AD%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[建立与数据库连接:需要连接字符串，用到System.Data.SqlClient类库。 方法： 使用一个类构建SQL Server 连接字符串- 创建SqlconnectionStringBuider实例 - 根据需要设置其属性 - 访问该对象的ConnectionString属性 与SQL Server数据库建立连接 - 生成一个指向该数据库的连接字符串 - 创建SqlConnection实例，向构造函数传递连接字符串 - 调用Sqlconnection实例的open方法 代码实例： /*建立连接字符串生成器*/ SqlConnectionStringBuilder connection = new SqlConnectionStringBuilder(); /*能连上本地服务器，以windows身份登录*/ if (LocalServer.Checked == true) connection.DataSource = &quot;(local)&quot;; /*以sql身份登录*/ else connection.DataSource = ServerName.Text; /*若sql server是express版本*/ if (IsExpressEdition.Checked == true) connection.DataSource += @&quot;\SQLEXPRESS&quot;; /*基于当前windows登陆的集成安全验证*/ if(AuthenticateWindows.Checked == true) { connection.IntegratedSecurity = true; } else { connection.IntegratedSecurity = false;//基于SQL用户的安全验证 connection.UserID = UserName.Text; connection.Password = UserPassword.Text; } SqlConnection linkToDB = new SqlConnection(connection.ConnectionString);//新建连接对象 linkToDB.Open();//打开数据库连接 linkToDB.close();//关闭数据库，或用dispose方法，或者用using语句就会自动关闭 对数据库进行查询、修改、更新、删除等操作：需要用到System.Data.SqlClient类库中的sqlcommand类 方法： 通过一个ADO.NET连接运行SQL查询 - 创建Sqlcommandr实例 - 将其CommandText属性设置为SQL语句 - 将其Connection属性设置为一个有效的Sqlconnection实例 - 调用这个命令对象的ExecuteNonQuery方法 调用一个返回静态结果的SQL Server存储过程 - 创建Sqlcommandr实例 - 将其CommandText属性设置为这个存储过程的名字 - 将其Connection属性设置为一个有效的Sqlconnection实例 - 调用这个命令对象的ExecuteScalar方法，捕获返回值 代码实例： /*对于对数据库采取操作但不返回存储数据的服务*/ string sqlText = @&quot;UPDATE WorkTable SET ProcessedOn = GETDATE() WHERE ProcessedOn IS NULL&quot;; SqlCommand dataAction = new SqlCommand(sqlText, linkToDB); dataAction.ExecuteNonQuery(); /*对于返回单个值的查询*/ string sqlText1 = &quot;select count(*) from WorkTable&quot;; SqlCommand dataAction1 = new SqlCommand(sqlText1, linkToDB); int total = (int)dataAction1.ExecuteScalar();//返回单个值 /*对于返回数据行的操作*/ string sqlText2 = &quot;select ID,FullName,ZipCode from Customer&quot;; SqlCommand dataAction2 = new SqlCommand(sqlText2, linkToDB); SqlDataReader scanCustomer = dataAction2.ExecuteReader();//一次返回一个数据行 if (scanCustomer.HasRows) while (scanCustomer.Read()); /*对于访问字段的值，用访问器*/ result = scanCustomer[0];//从起始位置查找 result = scanCustomer[“ID”];//按列名称查找 scanCustomer.NextResult();//若有多个列的返回时 /*查询中存在参数时，用@标识符替代*/ string test = @&quot;update Employee set Salary = @NewSalary where ID = @EmployeeID&quot;； SqlCommand salaryUpadate = new SqlCommand(test, linkToDB); paramValue.Value = 50000m;//设置参数的值 salaryUpadate.Parameters.Add(paramValue);//获取参数的值到原来的字符串中 salaryUpadate.Parameters.AddWithValue(&quot;@NewSalary&quot;, 50000m);//另外一种实例化方式，用于简单的参数时 salaryUpadate.ExecuteNonQuery(); /*对于存储过程的查询时*/ string test1 = &quot;dbo.AddLocation&quot;;//创建存储过程的字符串 SqlCommand locationCommand = new SqlCommand(test1, linkToDB); locationCommand.CommandType = CommandType.StoredProcedure;//把数据库命令的类型设置成存储过程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>.net</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的function自定义函数]]></title>
    <url>%2F2017%2F05%2F20%2FSQL%E4%B8%AD%E7%9A%84function%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SQL自定义函数 产生背景（已经有了存储过程，为什么还要使用自定义函数） 发展历史 构成 使用方法 适用范围 注意事项 疑问 内容产生背景（已经有了存储过程，为什么还要使用自定义函数）与存储过程的区别（存在的意义）： 能够在select等SQL语句中直接使用自定义函数，存储过程不行。 自定义函数可以调用其他函数，也可以调用自己（递归） 可以在表列和 CHECK 约束中使用自定义函数来实现特殊列或约束 自定义函数不能有任何副作用。函数副作用是指对具有函数外作用域（例如数据库表的修改）的资源状态的任何永久性更改。函数中的语句唯一能做的更改是对函数上的局部对象（如局部游标或局部变量）的更改。不能在函数中执行的操作包括：对数据库表的修改，对不在函数上的局部游标进行操作，发送电子邮件，尝试修改 目录，以及生成返回至用户的结果集。存储过程没有此限制 函数只能返回一个变量。而存储过程可以返回多个 发展历史SqlServer 2000之后都支持用户自定义函数 构成在SQL Server 2000 中根据函数返回值形式的不同将用户自定义函数分为三种类型：标量函数（Scalar Function）、内嵌表值函数（Inline Function）、多声明表值函数（Multi-Statement Function） 标量函数：标量函数是对单一值操作，返回单一值。能够使用表达式的地方，就可以使用标量函数。像我们经常使用的left、getdate等，都属于标量函数。系统函数中的标量函数包括：数学函数、日期和时间函数、字符串函数、数据类型转换函数等 内嵌表值函数：内嵌表值函数的功能相当于一个参数化的视图。它返回的是一个表，内联表值型函数没有由BEGIN-END 语句括起来的函数体。其返回的表由一个位于RETURN 子句中的SELECT 命令段从数据库中筛选出来。 作用 多声明表值函数：可以看作标量型和内嵌表值型函数的结合体。它的返回值是一个表，但它和标量型函数一样有一个用BEGIN-END 语句括起来的函数体，返回值的表中的数据是由函数体中的语句插入的。由此可见，它可以进行多次查询，对数据进行多次筛选与合并，弥补了内联表值型函数的不足。 使用方法SQL Server 为三种类型的用户自定义函数 提供了不同的命令创建格式。 （1） 创建标量型用户自定义函数（Scalar functions） 其语法如下： 各参数说明如下： owner_name ：指定用户自定义函数的所有者。 function_name：指定用户自定义函数的名称。database_name.owner_name.function_name 应是惟一的。 @parameter_name：定义一个或多个参数的名称。一个函数最多可以定义1024 个参数每个参数前用“@”符号标明。参数的作用范围是整个函数。参数只能替代常量，不能替代表 名、列名或其它数据库对象的名称。用户自定义函数不支持输出参数。 scalar_parameter_data_type：指定标量型参数的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。 scalar_return_data_type：指定标量型返回值的数据类型，可以为除TEXT、 NTEXT、 IMAGE、 CURSOR、TIMESTAMP 和TABLE 类型外的其它数据类型。 scalar_expression：指定标量型用户自定义函数返回的标量值表达式。 function_body：指定一系列的Transact-SQL 语句，它们决定了函数的返回值。 ENCRYPTION：加密选项。让SQL Server 对系统表中有关CREATE FUNCTION 的声明加密，以防止用户自定义函数作为SQL Server 复制的一部分被发布（Publish） 。 SCHEMABINDING：计划绑定选项将用户自定义函数绑定到它所引用的数据库对象如果指定 了此选项，则函数所涉及的数据库对象从此将不能被删除或修改，除非函数被删除或去掉此选项。应注意的是，要绑定的数据库对象必须与函数在同一数据库中。 2）创建内联表值型用户自定义函 数（Inline Table-valued Functions） 其语法如下： 各参数说明如下： TABLE：指定返回值为一个表。 select-stmt：单个SELECT 语句，确定返回的表的数据。 其余参数与标量型用户自定义函数相同。 （3） 创建多声明表值型用户自定义函数 其语法如下： 各参数说明如下： @return_variable ：一个TABLE 类型的变量，用于存储和累积返回的表中的数据行。 其余参数与标量型用户自定义函数相同。 在多声明表值型用户自定义函数的函数体中允许使用下列Transact-SQL 语句。 赋值语句（Assignment statements）； 流程控制语句（Control-of-Flow statements）； 定义作用范围在函数内的变量和 游标的DECLARE 语句； SELECT 语句； 编辑函数中定义的表变量的INSERT、 UPDATE 和DELETE 语句； 在函数中允许涉及诸如声明游 标、打开游标、关闭游标、释放游标这样的游标操作，对于读取游标而言，除非在FETCH 语句中使用INTO 从句来对某一变量赋值，否则不允许在函数中使用FETCH 语句来向客户端返回数据。此 外不确定性函数（Non-deterministic functions） 不能在用户自定义函数中使 用。所谓不确定性函数是指那些使用相同的调用参数在不同时刻调用得到的返回值不同的函数。 适用范围用户自定义函数不能用于执行一系列改变数据库状态的操作在编写自定义函数时需要注意的：对于标量函数： 所有的入参前都必须加@ create后的返回，单词是returns，而不是return returns后面的跟的不是变量，而是返回值的类型，如：int，char等。 在begin/end语句块中，是return。 内嵌表值函数： 只能返回table，所以returns后面一定是TABLE AS后没有begin/end，只有一个return语句来返回特定的记录。多语句表值函数： returns后面直接定义返回的表类型，首先是定义表名，表明前面要加@，然后是关键字TABLE，最后是表的结构。 在begin/end语句块中，直接将需要返回的结果insert到returns定义的表中就可以了，在最后return时，会将结果返回。 最后只需要return，return后面不跟任何变量。 疑问自定义函数不能修改数据库，但它可以调用存储过程，那么在自定义函数中调用一个有修改数据库的操作的存储过程，这个自定义函数能不能执行？ 答：自定义函数只能调用扩展存储过程，但是SQL Server 2008的后续版本将删除该功能，不再支持扩展存储过程，所以应避免在开发中使用扩展存储过程。因此，可以得出结论是：实际开发中，函数不会去调用存储过程，也就无法对数据库进行修改操作了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下安装命令的区别]]></title>
    <url>%2F2017%2F05%2F17%2Fubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ubuntu下安装命令的区别（dpkg、apt-get、aptitude）dpkg绕过apt包管理数据库对软件包进行操作，所以你用dpkg安装过的软件包用apt可以再安装一遍，系统不知道之前安装过了，将会覆盖之前dpkg的安装。 dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件 apt会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具 aptitude与 apt-get 一样，是 Debian 及其衍生系统*能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。 安装软件包123456dpkg -i package_name.deb #安装本地软件包，不解决依赖关系apt-get install package #在线安装软件包aptitude install pattern #同上apt-get install package –reinstall #重新安装软件包apitude reinstall package #同上 移除软件包1234567dpkg -r package #删除软件包apt-get remove package #同上aptitude remove package #同上dpkg -P #删除软件包及配置文件apt-get remove package –purge #删除软件包及配置文件apitude purge pattern #同上 自动移除软件包12apt-get autoremove #删除不再需要的软件包注：aptitude 没有，它会自动解决这件事 清除下载的软件包12345apt-get clean #清除 /var/cache/apt/archives 目录aptitude clean #同上apt-get autoclean #清除 /var/cache/apt/archives 目录，不过只清理过时的包aptitude autoclean #同上 编译相关1234apt-get source package #获取源码apt-get build-dep package #解决编译源码 package 的依赖关系aptitude build-dep pattern #解决编译源码 pattern 的依赖关系 平台相关123456apt-cross –arch ARCH –show package 显示属于 ARCH 构架的 package 软件包信息apt-cross –arch ARCH –get package #下载属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –install package #安装属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –remove package #移除属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –purge package #移除属于 ARCH 构架的 package 软件包apt-cross –arch ARCH –update #升级属于 ARCH 构架的 package 软件包 注：慎重考虑要不要用这种方法来安装不同构架的软件包，这样会破坏系统。对于 amd64 的用户可能需要强制安装某些 i386 的包，千万不要把原来 amd64 本身的文件给 replace 了。最好只是安装一些 lib 到 /usr/lib32 目录下。同样地，可以用 apt-file 看某个其它构架的软件包包含哪些文件，或者是文件属于哪个包，不过记得最先要用 apt-file –architecture ARCH update 来升级 apt-file 的数据库，在 search 或 show 时也要指定 ARCH。 更新源12apt-get update #更新源aptitude update #同上 更新系统1234apt-get upgrade #更新已经安装的软件包aptitude safe-upgrade #同上apt-get dist-upgrade #升级系统aptitude full-upgrade #同]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中struct大小计算]]></title>
    <url>%2F2017%2F05%2F16%2Fc%E8%AF%AD%E8%A8%80%E4%B8%ADstruct%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[struct 大小计算结构体是一种复合数据类型，通常编译器会自动的进行其成员变量的对齐，已提高数据存取的效率。在默认情况下，编译器为结构体的成员按照自然对齐（natural alignment）条方式分配存储空间，各个成员按照其声明顺序在存储器中顺序存储。自然对齐是指按照结构体中成员size最大的对齐。 默认对齐方式：在默认对齐方式下，结构体成员的内存分配满足下面三个条件： 结构体第一个成员的地址和结构体的首地址相同 结构体每个成员地址相对于结构体首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节（internal adding）。 结构体总的大小要是其成员中最大size的整数倍，如果不是编译器会在其末尾添加填充字节（trailing padding）。 下面是一个示例： 123456789101112131415161718192021222324252627282930struct s1&#123; char ch; int a; double b; char c1;&#125;;struct s2&#123; char ch; int a; double b;&#125;;int main()&#123; cout &lt;&lt; &quot;s1的大小： &quot; &lt;&lt; sizeof(struct s1) &lt;&lt; endl; cout &lt;&lt; &quot;ch的地址偏移是 &quot; &lt;&lt; offsetof(s1, ch) &lt;&lt; endl; cout &lt;&lt; &quot;a 的地址偏移是 &quot; &lt;&lt; offsetof(s1, a) &lt;&lt; endl; cout &lt;&lt; &quot;b 的地址偏移是 &quot; &lt;&lt; offsetof(s1, b) &lt;&lt; endl; cout &lt;&lt; &quot;c1的地址偏移是 &quot; &lt;&lt; offsetof(s1, c1) &lt;&lt; endl; cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; endl; cout &lt;&lt; &quot;s2的大小: &quot; &lt;&lt; sizeof(struct s2) &lt;&lt; endl; cout &lt;&lt; &quot;ch的地址偏移是 &quot; &lt;&lt; offsetof(s2, ch) &lt;&lt; endl; cout &lt;&lt; &quot;a 的地址偏移是 &quot; &lt;&lt; offsetof(s2, a) &lt;&lt; endl; cout &lt;&lt; &quot;b 的地址偏移是 &quot; &lt;&lt; offsetof(s2, b) &lt;&lt; endl; getchar(); return 0;&#125; 代码中 offsetof函数可以得到结构体成员相对于该结构体首地址的偏移量。其运行结果如下图： 对于结构体s1来说： ch是其第一个成员故其地址和结构体的地址是相同的也就是说偏移量为0； a是int型其大小为4个字节，按照条件（2） 结构体每个成员地址相对于结构首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节，所以其地址偏移应该是4，也就说编译器在第一个成员ch后面填充了3个字节。 b是double型占8个字节，其地址偏移应该是8的整数倍，由于a的地址偏移是4其大小为4个字节，正好b的偏移地址是8，不需要填充字节。 c1是char型占1个字节，偏移地址是16（b的偏移地址是8大小也是8，中间也没有填充字节）。 这时成员ch占1个字节后面有3个字节的填充，a占4个字节后面无填充，b占8个字节后面无填充，c1占1个字节，s1总的大小是1+3+4+8+1=17” role=”presentation”&gt;1+3+4+8+1=171+3+4+8+1=17。按照条件（3）结构体总的大小需是其最大成员所占空间的整数倍，其最大的成员b占有8字节，17显然是不符合条件的，所以需要在结构体的末尾填充7个字节，最后结构体总的大小是24字节。结构体s2和s1的成员是非常相似的，唯一的区别是其末尾没有最后7个字节的填充，所以其大小是16个字节，这里用于和s1做对比说明s1末尾的填充字节。 指定对齐方式可以使用#pragma pack(N)来指定结构体成员的对齐方式对于指定的对齐方式，其成员的地址偏移以及结构的总的大小也有下面三个约束条件： 结构体第一个成员的地址和结构体的首地址相同 结构体每个成员的地址偏移需要满足：N大于等于该成员的大小，那么该成员的地址偏移需满足默认对齐方式（地址偏移是其成员大小的整数倍）；Ｎ小于该成员的大小，那么该成员的地址偏移是N的整数倍。 结构体总的大小需要时N的整数倍，如果不是需要在结构体的末尾进行填充。 如果N大于结构体成员中最大成员的大小，则N不起作用，仍然按照默认方式对齐。 还是用上述示例： 1#pragma pack(4) //设定按照4字节对齐 运行结果为： 说明： 在使用#pragma pack设定对齐方式一定要是2的整数幂，也就是（1，2，4，8，16，…），不然不起作用的，仍然按照默认方式对齐。 当结构体中有其他的结构体作为成员时，计算最大成员是不能把结构体成员作为一个整体来计算，要看其每个成员的大小。 转载自： http://www.cnblogs.com/wangguchangqing/p/4853438.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const只读变量的内存分配]]></title>
    <url>%2F2017%2F05%2F16%2Fconst%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[const只读变量与#define宏定义的常量的内存分配的区别编译器通常不为普通 const 只读变量分配存储空间,而是将它们保存在符号表中,这使得它成为一个编译期间的值,没有了存储与读内存的操作,使得它的效率也很高。 例如： 1234567#define M 3//宏常量const int N=5;//此时并未将 N 放入内存中......int i=N;//此时为 N 分配内存,以后不再分配int I=M;//预编译期间进行宏替换,分配内存int j=N;//没有内存分配int J=M;//再进行宏替换,又一次分配内存 const 定义的只读变量从汇编的角度来看,只是给出了对应的内存地址,而不是象#define一样给出的是立即数,所以,const 定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量,存放在静态区),而#define 定义的宏常量在内存中有若干个拷贝。 #define 宏是在预编译阶段进行替换,而 const 修饰的只读变量是在编译的时候确定其值。 #define 宏没有类型,而 const 修饰的只读变量具有特定的类型。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git与github基本操作]]></title>
    <url>%2F2017%2F05%2F11%2Fgit%E4%B8%8Egithub%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[git与github的基本操作一、准备：1、git config –global user.name “Firstname Lastname” 2、git config –global user.email”your_email@example.com” 3、ssh-keygen -t rsa -C “your_email@example.com”添加ssh，一路回车略过 4、id_rsa.pub寻找公开公钥复制到github 5、ssh -T git@github.com 测试ssh是否生效 二、向远程仓库提交本地文件：方法一： 1、git clone git@github.com:username/example.git 2、cd example 3、git add filename//将文件发到缓存区 4、git diff HEAD//查看本次提交与之前提交的区别（可省略） 5、git commit -m “contribtion”//提交文件 6、git status//查看当前工作树情况（可省略） 7、git log -p//查看提交日志，并可查看修改的情况（可省略） 8、git push//直接提交到远程仓库 方法二： 1.git init 2.git add filename//将文件发到缓存区 3.git diff HEAD//查看本次提交与之前提交的区别（可省略） 4.git commit -m “contribtion”//提交文件 5.git status//查看当前工作树情况（可省略） 6.git log -p//查看提交日志，并可查看修改的情况（可省略） 7.git remote add origin 8.git@github.com:usrname/example.git//创建远程仓库 9.git push -u origin master//把本地当前分支上的内容推送到远程origin库的master分支 -u参数可以在推送的同时,将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream(上游)。添加了这个参数,将来运行 git pull命令从远程仓库获取内容时,本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容,省去了另外添加参数的麻烦。 工作树（当前文件夹） —-&gt; 暂存区 —–&gt;本地仓库 —–&gt;远程仓库]]></content>
      <categories>
        <category>研发管理</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
