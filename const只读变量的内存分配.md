---
title: const只读变量的内存分配
date: 2017-05-15 17:51:50
tags: [c,c++]
categories: 编程语言
comments: true
---
# const只读变量与#define宏定义的常量的内存分配的区别
编译器通常不为普通 const 只读变量分配存储空间,而是将它们保存在符号表中,这使
得它成为一个编译期间的值,没有了存储与读内存的操作,使得它的效率也很高。

**例如：**

```
#define M 3//宏常量
const int N=5;//此时并未将 N 放入内存中
......
int i=N;//此时为 N 分配内存,以后不再分配
int I=M;//预编译期间进行宏替换,分配内存
int j=N;//没有内存分配
int J=M;//再进行宏替换,又一次分配内存
```
const 定义的只读变量从汇编的角度来看,只是给出了对应的内存地址,而不是象#define
一样给出的是立即数,所以,const 定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量,存放在静态区),而#define 定义的宏常量在内存中有若干个拷贝。

#define 宏是在预编译阶段进行替换,而 const 修饰的只读变量是在编译的时候确定其值。

#define 宏没有类型,而 const 修饰的只读变量具有特定的类型。